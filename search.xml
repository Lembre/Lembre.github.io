<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JDBC之高级知识点]]></title>
    <url>%2F2018%2F09%2F25%2FJDBC%E4%B9%8B%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[事务管理事务的四大特性（ACID） 原子性:事务中的所有操作要么全部执行成功，要么执行全部失败。 一致性:事务执行后，数据库状态与其它业务规则保持一致。 隔离性:隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。 持久性:一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中。即使提交事务后数据库马上崩溃，在数据库重启后，也必须能保证通过某种机制恢复数据。 mysql中操作数据库 在控制台中输入语句:start transaction;即开始事务。 在控制台中输入语句:rollback;回滚事务，即在此事务中执行的操作全部无效，数据库回到start transaction;之前(但是前提是使用该语法前没有执行commit transaction;操作)。 在控制台中输入语句:commit transaction;即提交事务。 JDBC中操作事务事务的隔离级别事务的并发读问题 脏读:读取到另一份事务未提交数据，即读到了脏数据。 不可重复读：两次读取不一致。对统一记录的两次读取不一致，因为另一事务对该记录做了修改。 幻读：又叫虚读。对同一张表的两次查询不一致，因为另一事务进行了插入了一条记录的操作。 四大隔离级别(防止上述问题) SERIALIZABLE(串行化)：不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的。性能最差，可能导致死锁。 REPEATABLE READ(可重复读)(mysql默认级别)：防止脏读和不可重复读，不能处理幻读问题。性能比a的好。 READ COMMITTED(读已提交数据)(Oracle默认级别)：防止脏读，没有处理不可重复读，也没有处理幻读。性能比上述b好。 READ UNCOMMITTED(读未提交数据):可能出现任何事务并发问题。性能最好。但基本没人用。 查看mysql隔离级别 在控制台中输入语句:select @@tx_isolation;也可以通过下面命令来设置隔离级别:set transaction isolationlevel[4选1]; 在Jdbc中设置隔离级别con.setTransactionisolation[int lever]; 数据库连接池用户每次请求都需要向数据库获得链接，而数据库创建连接通常需要消耗相对较大的资源，创建时间也较长。假设网站一天10万访问量，数据库服务器就需要创建10万次连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。 数据库连接是一种关键的有限的昂贵的资源,这一点在多用户的网页应用程序中体现的尤为突出.。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正式针对这个问题提出来的。数据库连接池负责分配，管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中, 这些数据库连接的数量是由最小数据库连接数来设定的.无论这些数据库连接是否被使用,连接池都将一直保证至少拥有这么多的连接数量.连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数,当应用程序向连接池请求的连接数超过最大连接数量时,这些请求将被加入到等待队列中。 设置池参数设置初始化大小:connection.setInitialSize(); 设置最小空闲连接数:connection.setMinIdle(); 设置最大空闲连接数:connection.setMaxIdle(); 设置最小连接数:connection.setMinActive(); 设置最大连接数:connection.setMaxActive(); 设置增量:一次创建的最小单位。 设置最大的等待时间:connection.setMaxWait(); c3p0数据库连接池c3p0,全名叫ComboPooledDataSource; 需要导入的jar包连接池的实现:c3p0-0.9.5.2.jar和依赖库:mchange－commons.jar实例: public class Demo{ public static void main(String[] args) { //创建连接池对象 ComboPooledDataSource dataSource=new ComboPooledDataSource(); //进行四大参数的配置 dataSource.setDriverClass(“com.mysql.jdbc.Driver”); dataSource.setJdbcUrl(“jdbc:mysql://localhost:3306/mydb”); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;123&quot;); //池配置 dataSource.setAcquireIncrement(5); dataSource.setInitialPoolSize(20); dataSource.setMinPoolSize(2); dataSource.setMaxPoolSize(50); Connection con=dataSource.getConnection(); System.out.println(con); con.close(); } } c3p0配置文件的使用： 文件名称:必须叫c3p0-config.xml。文件的位置:必须在src下。 实例: public class Demo{ public static void main(String[] args) { //在创建连接池对象时，这个对象就会自动加载配置文件，不用我们来指定。 ComboPooledDataSource data=new comboPooledDataSource(); Connection con=data.getConnection(); System.out.println(con); } } Tomcat服务器配置数据库连接池JNDI:java命名和目录接口。作用:在服务器上配置资源，然后通过统一的方式来获取配置的资源。首先需要在Tomcat/conf/Catelina/localhost目录下新建文件名: 项目名.xml 获取资源的代码: Context initCtx=new InitialContext();//创建一个上下文。 Context envCtx=(Context) initCtx.lookup(“java:comp/env”);//这个路径是固定的不能改。 MyBean bean=(MyBean)envCtx.lookup(“bean/MyBeanFactory”);//通过该上下文进行二次查找才能找到资源 测试: dbtils结果集处理器介绍需要导入的jar包:common-dbutil.jar;c3p0.jar;mchange-commons.jar。关键要得到QueryRunner对象，然后调用其各种方法。 update()方法: int update(String sql,Object… params) 可执行增删改语句。重载方法int update(Connection con,String sql, Object… params)需要调用者提供Connection，这说明本方法不再管理Connection了。本重载方法支持事务。 query()方法: T query (String sql,ResultSetHandler rsh,Object… params)可执行查询操作。 重载方法:T query(Connection con,String sql,ResultSetHandler rsh,Object… params); 本重载方法支持事务。它会先得到ResultSet，然后调用rsh的handle()把rs转换成需要的类型。 ResultSetHandler接口 BeanHandler(单行)－－&gt;构造器需要一个class类型的参数，用来把一行结果转换成指定类型的javaBean对象。 BeanListHandler(多行)—&gt;构造器也是需要一个Class类型的参数，用来把一行结果集转换成一个javabean，哪么多行就是转换成List对象，一堆javabean。 MapHandler(单行)—&gt;把一行结果集转换成Map对象。 MapListHandler(多行)—&gt;把一行记录转换成一个Map，多行就是多个Map，即List。 ScalarHandler(单行单列)－&gt;同来用于select count(＊)from t_stu语句，结果集是单行单列的，它返回一个Object，就是count(*)的值，为long类型。 dbutil结果处理集原理代码: public class QR { private DataSource dataSource; public QR(DataSource dataSource) { this.dataSource=dataSource; } public QR(){ super(); } public int update(String sql,Object... params) { Connection con=null; PreparedStatement pstmt=null; try { con=dataSource.getConnection();//通过连接池得到连接对象 pstmt=con.prepareStatement(sql); initParams(pstmt,params);//给出参数 return pstmt.executeUpdate();//调用update执行增、删、该 }catch (Exception e) { throw new RuntimeException(e); }finally { try{ if (pstmt!=null) pstmt.close(); if (con!=null) con.close(); }catch (SQLException e){} } } //给参数赋值 public void initParams(PreparedStatement pstmt,Object... params) throws SQLException { for (int i = 0; i &lt; params.length; i++) { pstmt.setObject(i+1,params[i]); } } public T query(String sql,RsHandler&lt;T&gt; rh,Object... params) throws SQLException { Connection con=null; PreparedStatement pstmt=null; ResultSet rs=null; try { con=dataSource.getConnection();//通过连接池得到连接对象 pstmt=con.prepareStatement(sql); initParams(pstmt,params);//给出参数 rs=pstmt.executeQuery();//调用update执行增、删、该 return rh.handle(rs); }catch (Exception e) { throw new RuntimeException(e); }finally { if (rs!=null) rs.close(); if (pstmt!=null) pstmt.close(); if (con!=null) con.close(); } } interface RsHandler&lt;T&gt; { public T handle(ResultSet rs); } } 这样我们以后对数据库进行增、删、改操作时，只需写以下代码即可: 1.QueryRunner qr=new QueryRunner(JdbcUtils.getDataSource);//创建QueryRunner对象，并传入连接池对象 2.String sql=&quot;insert into user values(?,?,?,?);//给出sql语句模板 3.Object[] params={参数1，参数2，参数3，参数4};//传入参数 4.qr.update(sql,params);//调用qr方法。 通过这简单的四步就可以对数据库进行增删改了。 在jar包中，QueryRunner类的update(没有connection参数的)方法，在finally中将connection进行了关闭;在update(有connection参数的)方法中，在finally中没有对connection进行关闭(暂时这么记吧，不然要是进行关闭了的话，在传智播客写的小工具封装类TxQueryRunner中将connection传入JdbcUtils的releaseConnecion()方法中对connection进行关闭时会出现报错)。 在讲到事务时，我们会对QueryRunner进行再次封装。上述写出的QueryRunner的代码只是包中的QueryRunner源码方法的一部分(因为源码中还有很多的重载方法)，我们会通过另一个类TxQueryRunner(较QueryRunner多出的一个功能就是它支持事务)继承该类，在TxQueryrunner类中，对connection进行了判断:若connection为事务中的connection则在TxqueryRunner的update()方法中不对connection进行关闭，而是在commitTransaction()即提交事务时进行关闭;若connection为普通连接，则将connection进行关闭。那么以后我们在DAO中要获取的就不是QueryRunner对象，而是通过QueryRunner qr=new TxQueryRunner();获取TxQueryRunner对象了。 装饰者模式将对象增强的手段有: 继承 缺点:1.增强的内容是死的，不能动。2.被增强的对象也是死的。 装饰着模式 特点:1.增强的内容是不能修改的。2.被增强的对象可以是任意的。 动态代理AOP 下面通过一个简单的例子来对装饰者模式进行讲解 class 咖啡类 {}; class 加奶咖啡 extends 咖啡类 {}; class 加糖咖啡 extends 咖啡类 {}; class 加盐咖啡 extends 咖啡类 {}; 咖啡 a＝new 加糖咖啡(); 咖啡 b＝new 加盐咖啡(a);//对a进行装饰，就是给a加盐 咖啡 c＝new 加奶咖啡(b);//对b进行装饰，就是给b加奶 装饰者模式在Java API中的IO流中用到的很多。如BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter、ObjectInputStream、ObjectOutputStream这几个都是运用了装饰模式的装饰流。关于的IO流的详情见IO博文。 ThreadLocal早在JDK 1.2的版本中就提供Java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。 Thread API void set(Object value);设置当前线程的线程局部变量的值。 Object get();该方法返回当前线程所对应的线程局部变量。 void remove();将当前线程局部变量的值删除，目的是为了减少内存的占用。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。 ThreadLocal内部结构ThreadLocal内部用Map来保存数据。虽然在使用上述API时没有给出键，但其实它内部使用了当前线程作为键。内部结构见下面demo: class ThreadLocal { private Map&lt;Thread,T&gt; map=new HashMap&lt;Thread,T&gt;(); public void set(T value){ map.put(Thread.currentThread(),value); } public void remove(){ map.remove(Thread.currentThread()); } public T get(){ return map.get(Thread.currentThread()); } } 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>JDBC</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb之JDBC详解]]></title>
    <url>%2F2018%2F09%2F25%2FJavaWeb%E4%B9%8BJDBC%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概念JDBC，全称java database connectity,即Java数据库连接，意思是用Java语言操作数据库，可以为多种数据库提供统一的连接(MySql,Sql Server, Oracle)。原本我们都是通过在命令行或者在数据库图形化界面工具上面输入SQL语句操作数据库。而JDBC则是用Java语言向数据库发送SQL语句来操作数据库。 JDBC流程 获得Connection的对象 导jar包。mysql-connector-java jar 加载驱动类:Class.forName(“类名”); 配置url、username、password等参数 使用DriverManager类来的到Connection对象。 示例: public class Demo{ public void main(String[] args) throws ClassNotFoundException,SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载驱动类。 String url=&quot;jdbc:mysql://localhost:3306/数据库名&quot;; String username=&quot;数据库账号&quot;; String password=&quot;数据库密码&quot;; Connection con=DriverManager.getConnection(url,username,password); } } 代码分析: url的格式为–jdbc:厂商名称:子协议(由厂商自己来规定)。对于mysql而言，它的子协议结构的格式为://localhost:3306/数据库名。 出现SQLException的原因:1.url username password 是否正确。2.检查是否打开了sql服务器 出现ClassNotFoundException的原因:1.没导入驱动包。2.Class.forName()传入的驱动类错误。 JDBC之增删改查增，删，改示例: public class Demo{ public void main(String[] args) throws ClassNotFoundException,SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载驱动类。 String url=&quot;jdbc:mysql://localhost:3306/数据库名&quot;; String username=&quot;root&quot;; String password=&quot;123&quot;; Connection con=DriverManager.getConnection(url,username,password); Statement stmt=con.createStatement(); String sql＝&quot;insert into stu values(&apos;...&apos;,&apos;...&apos;,&apos;...&apos;,&apos;...&apos;)&quot;; stmt.executeUpdate(sql); } } 代码分析: 调用Connection的方法创建Statement对象，它是sql语句的发送器，功能就是向数据库发送sql语句 sql不需要打分号，打了就会出错，因为程序会自动帮我们加。 调用此方法向数据库发送sql语句。该语句返回的值为改变数据库的行数。 查询public class Demo{ public void main(String[] args) throws ClassNotFoundException,SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载驱动类。 String url=&quot;jdbc:mysql://localhost:3306/数据库名&quot;; String username=&quot;root&quot;; String password=&quot;123&quot;; Connection con=DriverManager.getConnection(url,username,password); Statement stmt=con.createStatement(); String sql=&quot;selece * from stu&quot;; ResultSet rs=stmt.execute(sql);//ResultSet提供了一系列的getXxx()方法 while(rs.next())//第一次调用next()方法是将光标移动到该表的第一行 { rs.getInt(1);//通过列编号来获取该列的值，如果第一列是id，此时得到id的值 rs.getString(&quot;name&quot;);//通过列名称来获取该列的值。 } } } 关闭资源数据库连接时重要的资源，不用时应该关闭。关闭资源时采用倒关的手法将对象进行处理:即先得到的对象后关，后得到的对象先关 PreparedStatement接口PrepaerdStatement是Statement的子接口示例: public class Demo{ public void main(String[] args) throws ClassNotFoundException,SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载驱动类。 String url=&quot;jdbc:mysql://localhost:3306/数据库名&quot;; String username=&quot;root&quot;; String password=&quot;123&quot;; Connection con=DriverManager.getConnection(url,username,password); String sql=&quot;insert into stu values(?,?)&quot;;//定义sql模板，即参数以问号的形式给出 PreparedStatement pst=con.prepaerStatement(sql); pst.setString(1,username);//数字1代表第一个问号 pst.setString(2.password);//数字2代表第二个问号 pst.executeUpdate();//向数据库发送sql语句 } } 原理： 检验sql语句的语法 编译：一个与函数相似的东西 执行：调用函数 Java中的时间类型和mysql中的时间类型转换数据库类型与Java中类型的对应关系 数据库中的DATE–&gt;java.sql.Date–&gt;java.util.Date; 数据库中的TIME–&gt;java.sql.Time–&gt;java.util.Date; 数据库中的TIMESTAMP–&gt;java.sql.Timestamp–&gt;java.util.Date; 需要注意的是: 领域对象(domain)中的所有属性不能出现java.sql包下的东西，即不能使用java.sql.Date、java.sql.Time、java.sql.TimeStamp。 ResultSet的getDate()返回的是java.sql.Date()。 PreparedStatment的setDate(int,Date),其中第二个参数是sql包下的java.sql.Date()。为了在java中使用sql包下的时间类型，这时就出现了时间类型的转换。 具体的转换将util包下的Date转换为sql包下的Date、Time、Timestamp 把util的的Date转换成毫秒值。 使用毫秒值创建sql的Date、Time、Timestamp java.util.Date date=new java.util.Date(); long l=date.getTime(); java.sql.Date sqlDate=new java.sql.Date(l); 将sql包下的Date、Time、Timestamp转换为util包下的Date 因为sql包下的Date、Time、和Timestamp继承自util包下的Date。所以可以直接用: JDBC之数据库存取大文件示例:存 String sql = “INSERT INTO tab_bin VALUES(?,?,?)”; PreparedStatement pstmt = con.prepareStatement(sql); pstmt.setInt(1,001); pstmt.setString(2,”hello.mp3”); // mp3 保存为 blob 类型的数据 // 通过 commons-io 工具类, 将 mp3 转换成 byte[] Byte[] bytes = IOUtils.toByteArray(new FileInputStream(&quot;/Users/姓名/Desktop/hello.mp3&quot;)); // 使用 bytes, 创建 Blob 对象 Blob blob = new SerialBlob(bytes); pstmt.setBlob(3,blob); // 发送 sql 语句 pstmt.executeUpdate(); 示例:取 String sql = “SELECT * FROM tab_bin”; PreparedStatement pstmt = con.prepareStatement(sql); ResultSet rs = pstmt.executeQuery(); // 将 rs 中名为 data 列的数据 if(rs.next()){ Blob blob = rs.getBlob(&quot;data&quot;); // 把 blob 转换成硬盘上的 mp3 文件 // 1. 通过 blob 得到输入流对象 // 2. 自己创建输出流对象 // 3. 把输入流的数据写入到输出流中 InputStream in = blob.getBinaryStream(); OutputStream out = new FileOutputStream(&quot;/Users/姓名/Document/world.mp3&quot;); // 使用io流工具类中的方法 IOUtils.copy(in,out); 批处理批处理只针对更新(增、删、改)当需要向数据库发送多条sql语句时, 为了提升执行效率, 可以考虑采用JDBC的批处理机制.JDBC的批处理机制主要涉及Statement或PreparedStatement对象的以下方法： addBatch(String sql) ：Statement类的方法, 多次调用该方法可以将多条sql语句添加到Statement对象的命令列表中. addBatch(): PreparedStatement类的方法, 多次调用该方法可以将多条预编译的sql语句添加到PreparedStatement对象的命令列表中.执行批处理时将一次性的把这些sql语句发送给数据库进行处理. executeBatch()：把Statement对象或PreparedStatement对象命令列表中的所有sql语句发送给数据库进行处理. clearBatch(): 清空当前sql命令列表. 采用Statement.addBatch(sql)方式实现批处理的优缺点： 优点：可以向数据库发送多条不同的ＳＱＬ语句。 缺点：SQL语句没有预编译。当向数据库发送多条语句相同，但仅参数不同的SQL语句时，需重复写上很多条SQL语句 采用PreparedStatement.addBatch()方式实现批处理的优缺点: 优点：发送的是预编译后的SQL语句，执行效率高。 缺点：只能应用在SQL语句相同，但参数不同的批处理中。因此此种形式的批处理经常用于在同一个表中批量插入数据，或批量更新表的数据。 注意:mysql默认批处理是关闭的，需要在url参数后面加上?rewriteBatchedStatement=true; 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>JDBC</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码检查规范CheckStyle和PMD的配置使用]]></title>
    <url>%2F2018%2F09%2F21%2F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E8%A7%84%E8%8C%83CheckStyle%E5%92%8CPMD%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[CheckStyle是SourceForge下的一个项目，提供了一个帮助JAVA开发人员遵守某些编码规范的工具。它能够自动化代码规范检查过程，从而使得开发人员从这项重要，但是枯燥的任务中解脱出来。PMD是一种开源分析Java代码错误的工具。与其他分析工具不同的是，PMD通过静态分析获知代码错误。也就是说，在不运行Java程序的情况下报告错误。PMD附带了许多可以直接使用的规则，利用这些规则可以找出Java源程序的许多问题。现在就来看看它们的安装配置和使用吧。 CheckStyle插件的安装与配置安装CheckStyle插件 CheckStyle插件的配置 当安装好插件，打开 IDEA的设置页面 settings -&gt; Other Settings 你会发现默认的 Checkstyle , 勾选就OK了,如上图。其实在还可以点击上面绿色加号添加自定义checkstyle文件，该文件放在项目的根目录。在里面可以设置你想要的格式。基本的配置就完毕了。现在 IDEA的控制面板会多一个 CheckStyle，你可以在这里方便的进行代码检查。可以点击面板的左上角下拉框 Rules 去动态切换不同的 checkstyle。 CheckStyle插件的使用完成安装与配置之后CheckStyle，便可以运行CheckStyle。根据CheckStyle扫描结果对应修改。 定制专属CheckStyle检查规则 CheckStyle不管是插件方式还是脚本方式，使用都是相当方便快捷的，而难点在于如何定制专属于我们项目的CheckStyle检查规则。 定制CheckStyle规则大致思路：通过对Google 提供的checkStyle检查规则修改完善，打造出属于自己的检查规则。谷歌配置文件规则 在配置文件中中主要由module 、property、message等节点构成： module节点 主要是指检查项，如MethodName （检查方法命名）module中有两个比较重要的节点，它们分别是Checker（checkStyle配置文件的根节点，必须存在）、TreeWalker（树遍历器），TreeWalker会自动去检查指定范围内的每一个java源文件，TreeWalker内部会定义很多module。 property 节点对应module 检查项中具体检查属性，如果使用默认值，property节点可以省略 message节点 checkStyle检查出来，是否打印出message消息，message节点可以省略 如何添加过滤能力？ 解决办法：在定制好的checkStyle.xml文件中，添加一个名为SuppressionFilter的moudle，在过滤规则文件suppressions.xml中添加相应的过滤规则。 PMD插件的安装和使用 自动安装：file –&gt; settings –&gt; plugins 搜索 pmd 用户可以选择在单个或者多个文件或文件夹上运行PMD：选中 文件或文件夹 –&gt; 右击 –&gt; Run PDM –&gt; 选择规则集 联系 Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于抽象类和接口]]></title>
    <url>%2F2018%2F09%2F20%2F%E5%85%B3%E4%BA%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[对于面向对象编程来说，抽象是它的一大特征之一。在Java中，可以通过两种形式来体现OOP的抽象：接口和抽象类。这两者有太多相似的地方，又有太多不同的地方。很多人在初学的时候会以为它们可以随意互换使用，但是实际则不然。下面我们一起来学习一下Java中的接口和抽象类： 什么是抽象方法和抽象类在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法和抽象类的声明格式分别为： 抽象方法: abstract void fun(); 抽象类:abstract class ClassName {abstract void fun();} 关于抽象类 抽象类是为了继承而存在的，它并不能被实例化 如果一个类继承于一个抽象类，那么它必须实现父类的抽象方法，除非它自己也是抽象类。 什么是接口在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对行为的抽象。 接口中可以含有变量，而方法会被隐式地指定为public abstract方法，它是一种极度抽象的类型，它比抽象类更加“抽象” 接口中的变量会被隐式地指定为public static final变量，但是一般情况下不在接口中定义变量。 ##抽象类和接口的区别 1.语法层面上的区别 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法； 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 2.设计层面上的区别 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 什么时候用抽象类，什么时候用接口 如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。 如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。 联系 Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码重构的方式理解MVC模式]]></title>
    <url>%2F2018%2F09%2F20%2F%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E7%9A%84%E6%96%B9%E5%BC%8F%E7%90%86%E8%A7%A3MVC%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[MVC模式是基于WEB系统模块化框架的大思想，繁衍出的一个把视图和处理做低耦合分离的一种模式。核心就是尽可能让一个后台系统，在几乎不做任何修改的情况下，同时支持多种视图。但是它的缺点是由于它没有明确的定义，所以完全理解MVC并不是很容易。使用MVC需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。 接下来我将以代码重构的方式帮助我们更好地理解MVC设计模式。 关于MVC设计模式MVC模式（Model-View-Controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）： Model——业务功能编写（例如算法实现）、数据库设计以及数据存取处理等操作实现 Controller——负责转发请求并对请求进行处理 View——负责界面显示 在JSP/Servlet开发的软件系统中，这三个部分的实现如下所示： Web浏览器发送HTTP请求到服务端，被Controller(Servlet)获取并进行处理（例如参数解析、请求转发） Controller(Servlet)调用核心业务逻辑——Model部分，获得结果 Controller(Servlet)将逻辑处理结果交给View（JSP），动态输出HTML内容 动态生成的HTML内容返回到浏览器显示 MVC模式在Web开发中的好处是非常明显，它规避了JSP与Servlet各自的短板，Servlet只负责业务逻辑而不会通过out.append()动态生成HTML代码；JSP中也不会充斥着大量的业务代码。这大大提高了代码的可读性和可维护性。本博文相关github代码如下点击进入github 具体体现 在进行代码重构之前的Servlet代码: @SuppressWarnings(&quot;serial&quot;) public class ListServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { try { //设置编码 req.setCharacterEncoding(&quot;UTF-8&quot;); //获取页面的值 String command = req.getParameter(&quot;command&quot;); String description = req.getParameter(&quot;description&quot;); //向页面传接到的值 req.setAttribute(&quot;command&quot;, command); req.setAttribute(&quot;description&quot;, description); Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis&quot;, &quot;root&quot;, &quot;123456&quot;); StringBuilder sql = new StringBuilder(&quot;select ID, COMMAND, DESCRIPTION, CONTENT from MESSAGE where 1 = 1&quot;) ; List&lt;String&gt; paramList = new ArrayList&lt;&gt;();//缓冲,添加动态传参 if (command != null &amp;&amp; !&quot;&quot;.equals(command.trim())) { sql.append( &quot; and COMMAND = ?&quot;); paramList.add(command); } if (description != null &amp;&amp; !&quot;&quot;.equals(description.trim())) { sql.append( &quot; and DESCRIPTION like &apos;%&apos; ? &apos;%&apos;&quot;); paramList.add(description); } PreparedStatement statement = conn.prepareStatement(sql.toString()); for (int i = 0; i &lt; paramList.size(); i++) { //sql语句从1开始的，所以i+1 statement.setString(i+1, paramList.get(i)); } ResultSet rs = statement.executeQuery(); List&lt;Message&gt; messageList = new ArrayList&lt;&gt;(); while(rs.next()) { Message message = new Message(); messageList.add(message); message.setId(rs.getString(&quot;ID&quot;)); message.setCommand(rs.getString(&quot;COMMAND&quot;)); message.setDescription(rs.getString(&quot;DESCRIPTION&quot;)); message.setContent(rs.getString(&quot;CONTENT&quot;)); } //查询消息列表并传给页面 req.setAttribute(&quot;messageList&quot;, messageList); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } req.getRequestDispatcher(&quot;/WEB-INF/jsp/back/list.jsp&quot;).forward(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } 上述servlet代码不仅负责了业务逻辑代码，如获取页面的值，向页面传接收到的值，还包括了获取数据库驱动，获取数据库连接和相关的数据库操作代码。这样使得servlet的代码过于冗长，代码的可读性，可维护性差 下面是代码重构之后的servlet @SuppressWarnings(&quot;serial&quot;) public class ListServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //设置编码 req.setCharacterEncoding(&quot;UTF-8&quot;); //获取页面的值 String command = req.getParameter(&quot;command&quot;); String description = req.getParameter(&quot;description&quot;); //向页面传接到的值 req.setAttribute(&quot;command&quot;, command); req.setAttribute(&quot;description&quot;, description); ListService listService = new ListService(); //查询消息列表并传给页面 req.setAttribute(&quot;messageList&quot;, listService.queryMessageList(command, description)); req.getRequestDispatcher(&quot;/WEB-INF/jsp/back/list.jsp&quot;).forward(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } 下面的代码是重构之后的dao代码: public class MessageDao { public List&lt;Message&gt; queryMessageList(String command, String description){ List&lt;Message&gt; messageList = new ArrayList&lt;&gt;(); try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis&quot;, &quot;root&quot;, &quot;123456&quot;); StringBuilder sql = new StringBuilder(&quot;select ID, COMMAND, DESCRIPTION, CONTENT from MESSAGE where 1 = 1&quot;) ; List&lt;String&gt; paramList = new ArrayList&lt;String&gt;();//缓冲,添加动态传参 if (command != null &amp;&amp; !&quot;&quot;.equals(command.trim())) { sql.append( &quot; and COMMAND = ?&quot;); paramList.add(command); } if (description != null &amp;&amp; !&quot;&quot;.equals(description.trim())) { sql.append( &quot; and DESCRIPTION like &apos;%&apos; ? &apos;%&apos;&quot;); paramList.add(description); } PreparedStatement statement = conn.prepareStatement(sql.toString()); for (int i = 0; i &lt; paramList.size(); i++) { statement.setString(i+1, paramList.get(i)); } ResultSet rs = statement.executeQuery(); while(rs.next()) { Message message = new Message(); //先放和后放是一样的，因为容器里面放的都是引用，不是真正的对象本身，所以接下来对这个对象操作依然有效 messageList.add(message); message.setId(rs.getString(&quot;ID&quot;)); message.setCommand(rs.getString(&quot;COMMAND&quot;)); message.setDescription(rs.getString(&quot;DESCRIPTION&quot;)); message.setContent(rs.getString(&quot;CONTENT&quot;)); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } return messageList; } } 下面是重构之后的数据库连接代码 public class DBHelper { private static final String driver = &quot;com.mysql.jdbc.Driver&quot;; //因为这些变量都是，全局的不需要修改的，固定的写法，所以设置为静态的私有的 private static final String url=&quot;jdbc:mysql://localhost:3306/shopping?useUnicode=true&amp;characterEncoding=UTF-8&quot;; private static final String username=&quot;root&quot;; private static final String password=&quot;123456&quot;; private static Connection conn=null; //静态代码块负责加载驱动 static { try { Class.forName(driver); } catch(Exception ex) { ex.printStackTrace(); } } public static Connection getConnection() throws Exception//static关键字表示类方法，直接通过类名调用 { if(conn==null) { conn = DriverManager.getConnection(url, username, password); return conn; } return conn; } public static void main(String[] args) { try { Connection conn = DBHelper.getConnection(); if(conn!=null) { System.out.println(&quot;数据库连接正常&quot;); } else { System.out.println(&quot;数据库连接异常&quot;); } } catch(Exception ex) { ex.printStackTrace(); } } } 通过代码重构可以清楚的发现，使用MVC设计模式的项目的代码可读性更高，可维护性更高。但是其实MVC设计模式也有它的不足: 增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。 视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。 联系如果需要联系作者，请在主页点击右下角的微信图标，或者通过以下方式: Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合工程的搭建]]></title>
    <url>%2F2018%2F09%2F17%2FSSM%E6%95%B4%E5%90%88%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[当我们系统的学完了Spring、Spring MVC以及Mybatis之后就可以进行这三者的整合工作了，也就是SSM框架的整合，其实就是将这三个框架的配置文件提取出来放在一个项目中，然后便可以进行开发，是不是觉得挺简单的。这篇文章我们将在前篇文章Mybatis与Spring整合的基础上将Spring MVC的配置引入进来完成SSM框架的整合。 整合的思路 在Mybatis与Spring3整合的基础上再进行Spring MVC框架的整合。 Spring要管理Spring MVC编写的Handler(controller)、Mybatis的SqlSessionFactory、mapper、数据源。其实整合思路就是下面这三步: 第一步:整合dao(即mapper)，完成Spring与Mybatis的整合 第二步:整合service，Spring管理service接口，service中可以调用Spring容器中的dao(mapper)。 第三步:整合controller，Spring管理controller接口，在controller调用service。 pom.xml的需要导入的依赖&lt;!--添加mybatis-generator-core.jar依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.30&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;${log4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- 映入JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传组件包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; pom.xml的需要导入的配置&lt;properties&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt; &lt;!-- log4j日志文件管理包版本 --&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;!-- 强制将xml文件打到war包中 s--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; spring-mybatis.xml,spring-mvc.xml和web.xml spring-mybatis.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;dao&quot; /&gt; &lt;context:component-scan base-package=&quot;pojo&quot; /&gt; &lt;context:component-scan base-package=&quot;mapping&quot; /&gt; &lt;context:component-scan base-package=&quot;service&quot; /&gt; &lt;context:component-scan base-package=&quot;serviceimpl&quot; /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;${initialSize}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;${maxActive}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;${maxIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;${minIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;${maxWait}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapping/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; spring-mvc.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package=&quot;controller&quot; /&gt; &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;mappingJacksonHttpMessageConverter&quot; /&gt; &lt;!-- JSON转换器 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 默认编码 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot; /&gt; &lt;!-- 文件大小最大值 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760000&quot; /&gt; &lt;!-- 内存中的最大值 --&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring和mybatis的配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 防止Spring内存溢出监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Spring MVC servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 此处可以可以配置成*.do，对应struts的后缀习惯 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 然后，在src下创建各个包:mapper、po、controller、service，在web包下创建页面包jsp。经过上述步骤，我们便完成了Spring、Spring MVC与Mybatis的整合，是不是很简单?没错就是这么简单。 联系如果需要联系作者，请在主页点击右下角的微信图标，或者通过以下方式: Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA创建MyBatis逆向工程]]></title>
    <url>%2F2018%2F09%2F17%2FIDEA%E5%88%9B%E5%BB%BAMyBatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[过去我们在开发时都需要通过数据库中的表然后自己在po包下手动建立相对应的pojo类，并要创建相应的mapper.xml写出对表的所有操作，而使用插件mybatis-generator-core生成mybatis逆向工程就不用我们自己再编写pojo类与相应的mapper类和相应的xml文件，它可以自动对单表生成sql，包括:mapper.xml、mapper.java、表名.java(po类)。这是非常方便快捷的。下面我将为你们介绍如何使用插件生成mybatis的逆向工程，只需三步而已。 逆向工程的部署话不多说，直接上图，点击运行即可生成相应的entity类，dao接口和mapper.xml。相关代码文件请移步我的github点击进入我的github pom.xml的需要导入的依赖和配置 需要导入的jar包和依赖 &lt;!-- -添加mybatis-generator-core插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;/dependency&gt; 此外还需要右击项目新建一个Direcrory,命名为lib,将数据库驱动包放进去 需要更改的配置 &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; 逆向工程的配置文件generatorConfig.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;!-- 数据库驱动--&gt; &lt;classPathEntry location=&quot;lib/mysql-connector-java-5.0.5-bin.jar&quot;/&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/ssmtest&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;!--设置为 true 可以获取 tables 信息, 解决生成文件缺少 xxxByPrimaryKey 的问题 --&gt; &lt;property name=&quot;useInformationSchema&quot; value=&quot;true&quot;/&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置--&gt; &lt;javaModelGenerator targetPackage=&quot;pojo&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage=&quot;mapping&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;dao&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName=&quot;user_t&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 关键的属性: javaModelGenerator,生成PO类的位置 sqlMapGenerator,mapper映射文件生成的位置 javaClientGenerator,mapper接口生成的位置 table,其tableName属性对应数据库中相应表 配置相应的运行命令点击Edit Configuration，点击+号，在Command line中输入mybatis-generator:generate -e然后点击应用，选择运行，等一会逆向工程便成功地建立！ ###需要注意的地方1.多次运行生成逆向工程然后进行SpringJUnit集成测试时，报错Result Maps collection already contains value for … 原因及解决办法:多次使用逆向工程生成mapper接口和xml文件时，是增加，而不是覆盖。所以需要将已经生成的文件删除，重新运行逆向工程。解决问题的根本方法是:在配置文件中 2.使用数据库驱动为8.0.11时生成的DAO接口只生成insert方法,这是特别的坑点，希望大家不要被坑了。 解决的办法:如果使用的mysql驱动是6.x,8.x的，那就无法生成，使用5.x版本的就可以生成。即本博文中的5.0.5. 3.有的人可能会问为什么mapper文件夹会跑到resources目录下。实际上，这个逆向工程生成文件的位置是可以任意的，只要把生成的文件复制到自己的项目下就可以了。我为了后续的开发，把xnl,文件同一放在resource下，但我又懒得改路径，所以直接剪切mapper文件夹到resources目录下了。 联系如果需要联系作者，请在主页点击右下角的微信图标，或者通过以下方式: Github@codinglembre Zhihu@codinglembre Blog@codinglembre -]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis和Spring整合]]></title>
    <url>%2F2018%2F09%2F17%2FMyBatis%E5%92%8CSpring%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[MyBatis是一种开源的半自动的持久化框架，它通过抽象jdbc模板代码提供简单的api交互简化持久层实现。通过读取mybatis.xml，Mapper.xml，Mapper映射了相应的JavaBean，通过SqlSessionFactory的实例化出来的SqlSession，执行对应方法，根据方法名回到Mapper.xml中找到和方法名相对应的id(注释方式的话找到接口类里面注释id对应的方法)，根据sql语句，还有传入的参数，还有Bean，这几者的联系形成的映射，进行CURD操作，省去JDBC那些模板方法代码。Spring也是开源框架，简化了Java开发，其主要功能是依赖注入和面向切面工程。 mybatis和spring整合的思路 使用spring管理SqlSessionFactory 使用spring管理mapper对象和dao 使用spring和mybatis整合开发mapper代理及原始dao接口。自动开启事务，自动管理sqlsession 让spring管理数据源(即数据库连接池) 开始整合工作pom.xml的需要导入的依赖和配置 需要导入的依赖 &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.30&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;${log4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- 映入JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; 整合配置文件spring-MyBatis.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;dao&quot; /&gt; &lt;context:component-scan base-package=&quot;pojo&quot; /&gt; &lt;context:component-scan base-package=&quot;mapping&quot; /&gt; &lt;context:component-scan base-package=&quot;service&quot; /&gt; &lt;context:component-scan base-package=&quot;serviceimpl&quot; /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;${initialSize}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;${maxActive}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;${maxIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;${minIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;${maxWait}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapping/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 至此，MyBatis便和Spring整合成功。 联系如果需要联系作者，请在主页点击右下角的微信图标，或者通过以下方式: Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Markdown语法]]></title>
    <url>%2F2018%2F05%2F27%2F%E5%B8%B8%E7%94%A8Markdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[其实这周挺忙的，各种考试，实验，作业统统集中到一起（内心os:麻木到习以为常了QAQ），但是还是抽空搭建了自己的个人博客网站，第一篇博文也不知道该写什么好，就把昨天自学的Markdown语法写下来了。 关于Markdown，你需要了解的概念Markdown 是一种可以使用 普通文本编辑器编写的轻量级 标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的 语法很简单。常用的标记符号不超过十个。让我们开始学习MarkDown语法吧！ Markdown语法因为MarkDown并不是我的学习方向，我学Markdown只是为了更好的写博文。因此，对于实现的效果相同的语法，我只列出最容易记的那种。若需要系统的学习MarkDown语法，请百度官方文档或者打开点击打开链接链接。 1.段落，标题和区块代码①段落: 一个以上的空行则会划分出不同的段落,一般的段落不需要用空白或换行缩进。(标题和正文之间会自动添加阴影线以及段落) ②标题: 推荐使用ATX形式。即在行首插入1到六个#，对应到标题的1到六阶。 ③区块代码: 区块引用则使用 email 形式的 ‘&gt;’ 角括号。 2.强调 可以在需要强调的位置前后加 两个星号 来标记需要强调的区段。 3.列表(共有两种形式)①无序列表:使用星号， 加号，减号来进行标记,例如 +Candy. +Gum. 效果： Candy. Gum. ②有序列表:使用一般的数字接着一个英文句点,例如 Red Green 效果: Red Green 4.链接(不区分大小写，共有两种形式) ①行内形式: []里写 链接文字，()里写 链接地址, 此外还可以为链接指定title属性，title属性可加可不加 ②参考形式:文中的写法 [链接文字]接上[链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 5图片(类似于链接，分为两种形式) ①行内形式： ![图片Alt]接上(图片地址 “图片Title”) ②参考形式:在文档要插入图片的地方写 ![图片Alt]接上[标记],在文档的最后写上[标记]:图片地址 “Title” 6代码和代码段 ①段落文字中存在代码区段，可以用 反引号 在代码区段左右加一个 `来标记代码区段 ②代码区块已经被格式化,可以使用 tab或者空四个格 ③代码段可以使用 ‘’’代码段’’’ 来实现 需要注意的地方 在设置标题时，#后面务必加上个空格，否则会导致标题效果渲染失败 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>
