<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[理解session和cookie机制]]></title>
    <url>%2F2018%2F09%2F26%2F%E7%90%86%E8%A7%A3session%E5%92%8Ccookie%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[sessionHttpSession概述与作用 HttpSession是由JavaWeb提供的，用来会话跟踪的类。session是服务器端对象，保存在服务器端。 HttpSession是Servlet三大域对象(request、session、application)之一，所以它也有setAttribute()、getAttribute()、removeAttribute()三个方法。 HttpSession底层依赖Cookie，或是URL重写。 HttpSession的作用 会话范围:会话范围是某个用户从首次访问服务器开始，到该用户关闭浏览器结束。(会话:一个用户对服务器的多次连贯性请求！所谓连贯请求，就是该用户多次请求 中间没有关闭浏览器) 服务器会为每个客户端创建一个session对象，session就好比客户在服务器端的账户，它们被服务器保存到一个Map中，这个Map被称之为session缓存。 Servlet中得到session对象的方法为:HttpSession session=request.getSession(); Jsp中得到session对象的方法:session是JSP内置对象之一，不用创建就可以直接使用。 session域相关方法: void setAttribute(String name,Object value); Object getAttribute(String name); void removeAttribute(String name); session保存用户登录信息login.jsp LoginServlet.java success.jsp HttpSession原理初入HttpSession原理 1.每当客户端与服务器建立了一个会话，服务器就会为该客户端建立一个session对象，将session对象保存在服务器端的同时服务器还会给客户端发送一个带有JSESSIONID的Cookie(放在响应头中)；2.当客户端在不关闭浏览器的情况下再次访问该服务器时，客户端就会通过这个JSESSIONID来取出保存在服务器端相应session对象。3.当客户关闭了浏览器时，意味着与服务器断开连接然后会话session也随着就结束了，此时能识别存在服务器端的HttpSession对象的JSESSIONID也就跟着丢失了。4.但是此HttpSession对象依旧保存在服务器端。5.当再次打开浏览器时，就会重新建立新连接，服务器给过来的JSESSIONID也是新的了。 这就好比你第一次去银行办卡，1.银行给你办了一张带有独特帐号的银行卡(JSESSIONID)然后你回家了，你存在银行卡里的钱保存在银行里(相应的HttpSession对象)(对应上面的步骤1)；2.当你再次访问该银行取钱时，你首先要给银行你的带有独特帐号的银行卡(将JSESSIONID给服务器),然后银行会给你要取的钱(获取相应的HttpSession对象)(对应上面的步骤2)。3.当你丢失了你的银行卡，而银行的工作人员又不小心在数据库中删除了你银行卡对应的帐号(对应上面的步骤3关闭浏览器)。4.但是你的钱还保存在银行里(对应上面的步骤4)。5.这时当你再次返回该银行时，你就需要重新办一张银行卡(由于工作人员删除了你原先的帐号所以不能补办),并且新办理的银行卡会对应新的帐号(新的JSESSIONID)。 对于断开连接后保存在服务器端的HttpSession对象不会一直存在，它有它的生命时间，一般为30分钟，到达这个时间后服务器端就会将它删除。还有一种情况就是当客户端与服务器建立一个会话后，但是该客户却很长时间不对服务器发请求，当时间到达该session对象存活的时间后服务器也会删除该session对象。就比如你登录了淘宝的主页，然后你半天时间不去碰电脑，当你想起要去购物时，你点击一个超链接后服务器就会要求你重新登录，因为由于你长时间不给服务器发起请求，服务器就误认为这是一个没用的session，然后服务器就将它删了。 深入HttpSession原理只有当客户端请求的Servlet中调用了request.getSession()方法要求获取HttpSession对象时服务器才会创建；但是若请求的是jsp页面，则服务器会立刻创建HttpSession对象，因为jsp对应的Servlet类中已经默认调用了request.getSession()。 HttpSession的其它方法 String getId():获取JSESSIONID。 int getMaxInactiveInterval():获取session可以的最大不活动时间(秒),默认为30分钟，当session在30分钟内没有使用，哪么Tomcat会在session缓存中删掉这个session。 void invalidate():让session失效。调用这个方法会被session失效，当session失效后，客户端再次请求，服务器会给客户端创建一个新的session，并在响应中创建一个新的JSESSIONID。 boolean isNew():查看session是否为新。当客户端第一次请求时，服务器为客户端创建session，并把JSESSIONID存在Cookie中发给客户端，这时调用这个方法返回的就是新session；当再次发起请求时，JSESSIONID放在Cookie中作为请求头发给服务器，这时调用此方法，返回的就是false，即此session不是新的。 cookieHttp协议与Cookie(了解) Cookie是Http协议制定的。先有服务器保存Cookie到浏览器，再下次浏览器请求服务器时把上一次请求得到的Cookie归还给服务器。 由服务器创建保存到客户端的一个键值对。服务器保存Cookie的响应头,使用response发送响应头:Set-Cookie:aaa=AAA;Set-Cookie:bbb=BBB;例如: response.addHeader(“Set-Cookie”,”aaa=AAA”); response.addHeader(“Set-Cookie”,”bbb=BBB”); 当浏览器请求服务器时，会把该服务器保存的Cookie随请求发送给服务器。浏览器归还Cookie的请求头:Cookie:aaa=AAA;bbb=BBB。多个键值对间用分号隔开。Http协议规定(为了不给浏览器太大压力) 1个Cookie最大4KB 1个服务器最多向1个浏览器保存20个Cookie 1个浏览器最多可以保存300个Cookie Cookie的用途 服务器使用Cookie来跟踪客户端状态。 保存购物车(购物车中的商品不能使用request域来保存，因为它是一个用户向服务器发送的多个请求信息) 显示上次登录用户名(并记住密码) Java Web中使用Cookie. Cookie详解 Cookie不只有name和value两个属性。 Cookie的maxAge:指Cookie的最大生命，即Cookie可保存在客户端中的最大时长，以秒为单位。 maxAge&gt;0:浏览器会把Cookie保存到客户端硬盘上，有效时长为maxAge的值决定，例如:cookie.setMaxAge(60)表示这个Cookie会被浏览器保存到硬盘上60秒。 maxAge&lt;0:Cookie只会在浏览器内存中存在，当用户关闭浏览器时浏览器进程结束，同时Cookie也就死亡了。 maxAge=0:浏览器会马上删除这个Cookie。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet请求转发和请求包含]]></title>
    <url>%2F2018%2F09%2F26%2FServlet%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E8%AF%B7%E6%B1%82%E5%8C%85%E5%90%AB%2F</url>
    <content type="text"><![CDATA[为什么需要这样的操作呢？因为很多时候一个请求需要多个Servlet协作才能完成，所以需要在一个Servlet中跳转到另一个Servlet中处理。 请求转发和请求包含的语法格式 ResquestDispatcher rd=request.getRequestDispatcher(“/MyServlet”); 参数为被包含或被转发的目标Servlet路径。 请求转发: rd.forward(request,response); 请求包含: rd.include(request,response); 这样就完成我们的请求转发和请求包含。二者的区别为: 请求转发:由当前Servlet设置响应头(不能设置响应体)，下一个Servlet既可设置响应头也可设置响应体。 请求包含:当前Servlet和下一个Servlet共同完成相应头和响应体 请求转发具体效果请看下图输出结果是 This is Two Servlet 由响应结果我们可以看到OneServlet中设置的响应体没有在网页中显示出来，只有TwoServlet中设置的响应体显示出来了。 请求包含具体效果请看下图 This is One ServletThis is Two Servlet 从响应结果中我们可以看到在OneServlet和TwoServlet中设置的响应体都显示了出来。 需要注意的是无论是请求转发还是请求包含，都在一个请求范围内，所以多个Servlet中使用的是同一个request和response。 请求转发和请求重定向的区别 请求转发是一个请求一次响应，而重定向是两次请求两次响应。 请求转发地址栏不变化，而重定向会显示后一个请求的地址。 请求转发只能转发到本项目其他Servlet，而重定向不只能重定向到本项目的其它Servlet，还能定向到其它项目。 请求转发是服务器端行为，只需给出转发的Servlet路径，而重定向需要给出requestURI,即包含项目名。 请求转发和重定向二者效率前者高，因为前者只发出一个请求。 什么时候用请求转发/重定向 很多时候我们需要地址栏发生变化，那时候必须使用重定向。需要在下一个Servlet中获取到request域中的数据，必须用请求转发。 Servlet间传递数据之request域何为域？上一篇文章中提到对ServletContext域对象的介绍时已经说过域的功能，即具有能存数据和取数据的功能(Servlet三大域对象request,session,application) 同一请求范围内使用request.setAttribute()来传值、使用request.getAttribute()方法来取值即前一个Servlet使用request.setAttribute()来传值、后一个Servlet使用request.getAttribute()方法来取值 而当想清除request中的值时，调用request.removeAttribute()方法即可清除。 三大域对象的生命周期长度为: request&lt;session&lt;application 扩展: 注意上图中三个方法和请求参数方法的区别，请求参数是客户端传给服务器的，我们不能修改；而此处的setAttribute()是我们自己设置的属性与属性值。另外Servlet类中有上述三大域，而JSP中有四大域，多了一个pageContext域。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet的生命周期与创建时机]]></title>
    <url>%2F2018%2F09%2F26%2FServlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Servlet的生命周期指的是 Servlet从被Web服务器加载到它被销毁的整个生命过程。那么他的生命周期主要分为哪几个阶段以及它的工作原理是怎么样的呢？本博文接下来将讨论这些内容。 Servlet的生命周期的详细分析Servlet的生命周期分为三个阶段 初始化阶段，调用init()方法 响应客户请求阶段，调用service()方法 终止阶段，调用destory()方法 一个Servlet的具体步骤以及和JSP的区别(web.xml和Service方法) Web服务器加载Servlet：Web服务器启动后，它会根据每个工程的web.xml文件去查找该工程的Servlet，并且找到这些Servlet的Class文件所在的地址，将它们载入到Web容器中，不同的Servlet被Web容器加载的次序不同，通过web.xml文件可以配置每个Servlet载入的次序。 一般来说，Servlet在服务器启动时就会被Web服务器加载，而JSP文件只有在用户访问到该页面时才会被动态载入。 创建一个Servlet实例：这时会调用该Servlet的构造函数去创建一个具体的对象。 经过以上的两个步骤后，这时如果有客户端请求，Web服务器就会调用Servlet对象的init()方法 接着Web服务器调用Servlet的service()方法去接收请求，处理请求，并把处理结果返回。 销毁：Servlet实例被销毁，这是通过调用Servlet的destory()方法来实现的。 在以上的几个阶段中，Servlet对外提供服务阶段最重要的。service()方法是编程人员真正要关心的方法，因为它才是Servlet真正开始响应客户端请求，并且处理业务逻辑的方法。Service()接收到客户端请求后，再调用Servlet的doGet()方法或者doPost()方法去处理请求。所以在编写自己的Servlet时，一般只需要重写doGet()和doPost()方法，在该方法中去处理客户端请求，并把处理结果返回。 过程分析: Web Client向Servlet容器(tomcat)发出Http请求 Servlet容器接收Web Client的请求 Servlet容器创建一个HttpRequest对象，将Web Client请求的信息封装到这个对象中。 Servlet容器创建一个HttpResponse对象 Servlet容器调用HttpServlet对象的service方法，把HttpRequest对象与HttpResponse对象作为参数传递给HttpServlet对象。 HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息 HttpServlet调用HttpResponse对象的有关方法，生成响应数据 Servlet容器把HttpServlet的响应结果传入Web Client。 Servlet工作原理:首先客户发送个请求，Servlet容器会创建特定于这个请求的ServletRequest对象和ServletResponse对象，然后调用Servlet的service()方法。Service()方法从ServletRequest对象获得客户请求信息，处理该请求，然后通过ServletResponse对象向客户返回响应信息。 创建Servlet对象的时机: Servlet容器启动时：读取web.xml配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，同时将ServletConfig对象作为参数来调用Servlet对象的init方法。 在Servlet容器启动后：客户首次向Servlet发出请求，Servlet容器会判断内存中是否存在指定的Servlet对象，如果没有则创建它，然后根据客户的请求创建HttpRequest、HttpResponse对象，从而调用Servlet 对象的service方法。 Servlet容器在启动时自动创建Servlet，这是由在web.xml文件中为Servlet设置的属性决定的。从中我们也能看到同一个类型的Servlet对象在Servlet容器中以单例的形式存在。 &lt;servlet&gt; &lt;servlet-name&gt;Init&lt;/servlet-name&gt; &lt;servlet-class&gt;org.xl.servlet.InitServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 在servlet的配置当中，1的含义是：标记容器是否在启动的时候就加载这个servlet。当值为0或者大于0时，表示容器在应用启动时就加载这个servlet；当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。正数的值越小，启动该servlet的优先级越高。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb之Servlet学习]]></title>
    <url>%2F2018%2F09%2F26%2FJavaWeb%E4%B9%8BServlet%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Servlet（Servlet Applet），全称Java Servlet,是用Java编写的服务器端程序。而这些Servlet都要事先Servlet接口或继承了HttpServlet的java代码(一般用继承的方法)。其主要功能在于交互式的浏览和修改数据，生成动态Web内容。Servlet运行于支持Java的应用服务器中。HttpServlet 重写doGet 和 doPost 方法或者你也可以重写service方法完成对get和post请求响应。 ServletServlet是Java Web三大组件之一(Filter、Servlet、Listener)，它属于动态资源。Servlet的作用是处理请求，服务器会把接收到的请求交给Servlet来处理，在Servlet中通常需要: 接受数据请求 处理请求 完成响应 客户端发出登录请求，或者输入注册请求，这些请求都应该由Servlet来完成处理。当然Servlet类需要我们自己来编写，每个Servlet类都必须实现javax.servlet.Servlet接口。 实现Servlet的方式(需要我们自己来写) 实现javax.servlet.Servlet接口; 继承javax.servlet.GenericServlet类; 继承javax.servlet.http.HttpServlet类; 一般来说我们都选择实现HttpServlet类来完成我们的Servlet，但学习Servlet还要从javax.servlet.Servlet接口来学起。 实现javax.servlet.Servlet接口 其中只有三个生命周期的方法是由服务器(例如我用的Tomcat)在认为需要调用的时候自动调用的(即我们自己是无法调用的)，另外的两个方法由我们自己需要的时候调用。 继承javax.servlet.GenericServlet类有人会说，那我每次实现Servlet接口都要重写这5个方法岂不是很麻烦？那肯定麻烦！所以GenericServlet类派上用场了。GenericServlet类实现了Servlet接口，所以在GenericServlet类中实现了Servlet接口中的5个抽象方法，另外在GenerecServlet类中还定义了自己的方法，将其作为我们要定义的xxxServlet类的父类，这样我们在自己定义的xxxServlet类中便可以不用全部实现Servlet接口中的方法。GenericServlet类中的方法如下: GenericServlet类除了实现Servlet接口中的四个方法外，还定义了getInitParameter()返回Servlet的参数值、getInitParameterNames()返回Servlet的参数名、getServletName()返回Servlet名、getServletContext()返回Servlet上下文、不带参数的init()、log()等方法。这些自己定义的方法中，前面四个是ServletConfig接口中的方法，不带参数的init()方法跟Servlet接口中的init(ServletConfig config)方法要区别，在init()方法中，我们可以添加当xxxServlet被初始化的操作，此方法在初始化方法init(ServletConfig config)中被调用(若是文字解析看不懂见下图GenericServlet源代码中注释)。 图中只有service()方法属于抽象方法，所以当我们定义的xxxServlet类去继承GenericServlet类时我们只需重写这一个方法即可，其他方法可重写可不重写。 JavaWeb，Servlet，JSP的域对象扩展:对ServletContext的解释: 服务器会为每个应用创建一个ServletContext对象，一个应用只有一个ServletContext对象！我们可以在N多个Servlet中来获取这个唯一的对象，使用它可以给多个Servlet传递数据。此对象在Tomcat(服务器)启动时就创建，在服务器关闭时就销毁。 ServletContext是Java Web四大域对象(PageContext、ServletRequest、HttpSession、ServletContext)之一，域对象所具有的特点是: 能够存数据 能够取数据 所有的域对象都有存取数据的功能，因为域对象内部有一个Map，用来存储数据，下面是ServletContext对象用来操作数据的方法: 扩展:Servlet类三大域对象: request:在Servlet中直接用，因为实现的doPost()方法中有request这个参数。 session:在Servlet中通过HttpSession session=request.getSession();得到。 application:在Servlet中通过ServletContext application=this.getServletContext();得到。 扩展:JSP中四大域对象 page域:即9大内置对象中的pageContext，为PageContext的实例。 request域:即9大内置对象中的request，为HttpServletRequest的实例。 session域:即9大内置对象中的session,为HttpSession的实例。 application:即9大内置对象中的ServletContext的实例 注意:“page域”不同于9大内置对象中“page”。 继承HttpServlet类HttpServlet类是我们用到次数最多的，也是最简单的。由类名可知，该类总是跟http协议相关的。HttpServlet类中的方法如下图: 方法中值得我们注意的有doGet()、doPost()、还有两个service()方法。其中doGet()和doPost()方法是需要我们重写的，我来解释下两个service()方法的区别。 其中一个service()方法是Serlvet接口中的生命周期方法，另外一个是跟http协议有关的方法。二者方法的解释见下两站图的说明(图1中指出HttpServlet类是继承自GenderServlet类): 图中405的含义是说服务器不支持客户端(即浏览器)用此种方法访问。因为HttpServlet类的源代码中的doGet()和doPost()方法体里面就是这样写的，你在定义的xxxservlet中如果不重新重写这两个方法就会出现405的响应状态码。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之Socket编程与应用]]></title>
    <url>%2F2018%2F09%2F26%2FJava%E4%B9%8BSocket%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本博文首先是对TCP的简单介绍，然后在分析Socket通信的模型后进行Java Socket实现TCP编程的代码编写，最后是利用Socket的知识编写一个简单的聊天室 TCP(基于字节流)与数据传递TCP(Transmission Control Protocol 传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能。在因特网协议族(Internet protocol suite)中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。网络模型中的数据传递:应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段(通常受该计算机连接的网络的数据链路层的最大传输单元(MTU)的限制)。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。 Socket通信模型(描述IP地址和端口)所谓socket 通常也称作”套接字“，用于描述IP地址和端口，是一个通信链的句柄。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。首先我们看看Socket基于TCP的通信模型图:图中通信模型的各个步骤如下: 在服务端建立一个ServerSocket,绑定相应的端口，并且在指定的端口进行侦听，等待客户端的连接。 当客户端创建连接Socket并且向服务端发送请求。 服务器收到请求，并且接受客户端的请求信息。一旦接收到客户端的连接请求后，会创建一个连接socket，用来与客户端的socket进行通信。通过相应的输入/输出流进行数据的交换，数据的发送接收以及数据的响应等等。 当客户端和服务端通信完毕后，需要分别关闭socket，结束通信。 基于TCP的Socket服务端开发 创建ServerSocket对象，绑定监听器 通过accept（）方法监听客户端请求 连接建立以后通过读取客户端发送请求消息 通过输出流向客户端发送响应信息，关闭资源 ServerSocket类中涉及到的常用方法: ServerSocket(int port)——创建并绑定到特定端口的服务器套接字 accept()——侦听并接受到此套接字的连接 close()——关闭此套接字 getInetAddress()——得到ServerSocket对象绑定的IP地址。如果ServerSocket对象未绑定IP地址，返回0.0.0.0 getLocalPort()——返回此套接字在其上侦听的端口 public class Server { public static void main(String[] args) { //1.创建一个服务器Socket，即ServerSocket,指定绑定的端口，并坚挺 try { ServerSocket serverSocket=new ServerSocket(8888); //2，调用accept()开始监听，等待客户端的链接 System.out.println(&quot;****服务器即将启动，等待客户端的连接****&quot;); Socket socket=serverSocket.accept(); //3.获取输入流并获取客户信息 InputStream in=socket.getInputStream(); InputStreamReader isr=new InputStreamReader(in,&quot;utf-8&quot;); BufferedReader br=new BufferedReader(isr); String info; StringBuilder sb=new StringBuilder(); while ((info=br.readLine())!=null) { sb.append(info); } System.out.println(&quot;我是服务器，客户端发来的消息为:&quot;+sb); socket.shutdownInput();//关闭输入流 //4.获取输出流，用于响应客户端的请求 OutputStream os=socket.getOutputStream(); PrintWriter pw=new PrintWriter(os); pw.write(&quot;欢迎您&quot;); pw.flush();//将缓冲输出 //4.关闭相关资源 pw.close(); os.close(); br.close(); isr.close(); in.close(); socket.close(); serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } 基于TCP的Socket客户端开发客户端需要完成的工作是: 创建Socket对象，指明需要连接的服务器地址和端口号(1023以后的端口,因为0~1023之间的端口号是我们系统需要使用的端口号) 连接建立后，通过输出流向服务器端请求 通过输入流获取服务器响应信息, 关闭资源 Socket类中常用的方法: Socket(InetAddress address, int port)——创建一个套接字并将其连接到指定ip地址的指定端口号 Socket(String host, int port)——创建一个套接字并将其连接到指定主机上的指定端口号 close()——关闭此套接字 getInetAddress()——返回套接字连接的地址 getInputStream()——返回此套接字的输入流 getOutputStream——返回此套接字的输出流 public class Client { public static void main(String[] args) { //1.创建客户端Socket,指定服务器端地址和端口号 try { Socket socket=new Socket(&quot;localhost&quot;,8888); //2.获取输出流，用来向服务器端发送登录信息 OutputStream os=socket.getOutputStream(); PrintWriter pw=new PrintWriter(os);//将输出流打包成打印流 pw.write(&quot;用户名:codinglembre;密码:123&quot;); pw.flush();//刷新缓存 socket.shutdownOutput();//关闭输出流 //3.获取服务器传过来的输入流，读取服务器的响应信息 InputStream in=socket.getInputStream(); BufferedReader br=new BufferedReader(new InputStreamReader(in,&quot;utf-8&quot;)); String info; StringBuilder sb=new StringBuilder(); while ((info=br.readLine())!=null) { sb.append(info); } System.out.println(&quot;我是客户端，服务器给我的信息为:&quot;+sb); //3.关闭资源 br.close(); in.close(); pw.close(); os.close(); socket.close(); } catch (IOException e) { e.printStackTrace(); } } } 代码执行过程运行服务器Server.java，代码在执行到Socket socket=serverSocket.accept();时会在此阻塞，控制台输出: 服务器即将启动，等待客户端的连接 直到等到客户端连接到该端口号的服务器后服务器的代码才会向下执行，此时运行客户端Client.java，客户端的控制台输出: 我是客户端，服务器给我的信息为:欢迎您 然后此时切换到服务器的控制台，发现输出信息: **服务器即将启动，等待客户端的连接我是服务器，客户端发来的消息为:用户名:codinglembre;密码:123 服务器端多线程接收客户端传递过来的信息的代码编写线程类: public class ServerThread extends Thread { private Socket socket; public ServerThread(Socket socket) { this.socket=socket; } public void run() { //3.获取输入流并获取客户信息 InputStream in= null; InputStreamReader isr=null; BufferedReader br=null; OutputStream os=null; PrintWriter pw=null; try { in = socket.getInputStream(); isr=new InputStreamReader(in,&quot;utf-8&quot;); br=new BufferedReader(isr); String info; StringBuilder sb=new StringBuilder(); while ((info=br.readLine())!=null) { sb.append(info); } System.out.println(&quot;我是服务器，客户端发来的消息为:&quot;+sb); socket.shutdownInput();//关闭输入流 //4.获取输出流，用于响应客户端的请求 os=socket.getOutputStream(); pw=new PrintWriter(os); pw.write(&quot;欢迎您&quot;); pw.flush();//将缓冲输出 } catch (IOException e) { e.printStackTrace(); }finally { //4.关闭相关资源 try { if (pw!=null) pw.close(); if (os!=null) os.close(); if (br!=null) br.close(); if (isr!=null) isr.close(); if (in!=null) in.close(); if (socket!=null) socket.close(); }catch (Exception e) { e.printStackTrace(); } } } } 之后修改Server.java中的代码为: public class Server { public static void main(String[] args) { //1.创建一个服务器Socket，即ServerSocket,指定绑定的端口，并坚挺 try { ServerSocket serverSocket=new ServerSocket(8888); //2，调用accept()开始监听，等待客户端的链接 System.out.println(&quot;****服务器即将启动，等待客户端的连接****&quot;); //记录客户端的数量 int count=0; while (true) { //调用accept()方法开始监听，等待客户端的连接 Socket socket = serverSocket.accept(); //创建一个新的线程 ServerThread serverThread=new ServerThread(socket); //启动线程 serverThread.start(); //如果不要启动线程的话这里直接调用run()也行. count++;//统计客户端的数量 System.out.println(&quot;客户端的数量：&quot;+count); InetAddress address=socket.getInetAddress(); System.out.println(&quot;当前客户端的IP：&quot;+address.getHostAddress()); } } catch (IOException e) { e.printStackTrace(); } } } 运行Server.java，服务器控制台输出信息: 服务器即将启动，等待客户端的连接 然后运行Client.java，客户端控制台输出信息: 我是客户端，服务器给我的信息为:欢迎您 此时跳转到服务器控制台，信息变为: 服务器即将启动，等待客户端的连接我是服务器，客户端发来的消息为:用户名:codinglembre;密码:123客户端的数量：1当前客户端的IP：127.0.0.1 然后更改Client.java中传递给服务器的数据代码为:pw.write(“用户名:codingxiaxw;密码:456”);，再运行Client.java，发现服务器的控制台输出信息变为: 服务器即将启动，等待客户端的连接我是服务器，客户端发来的消息为:用户名:codingxiaxw;密码:13客户端的数量：1当前客户端的IP：127.0.0.1我是服务器，客户端发来的消息为:用户名:codingxiaxw;密码:456客户端的数量：2当前客户端的IP：127.0.0.1 QQ的通信模式c/sqq中的用户A发送信息给用户B，过程是这样的:当A打开和B的聊天窗口时即和B还有服务器建立了一个聊天室(同时服务器和客户端开启连接)，A发送信息，其实是发送到了qq聊天室服务器的接收容器中，然后qq服务器将该客户端地址(即qq头像)和信息内容显示在聊天室中(即聊天窗口)，你每和一个好友进行聊天打开一个窗口就等于和她(另一个客户端)还有我们的qq服务器组成了一个聊天室(当然聊天室的服务器肯定是多线程的)。qq上还有多人聊天的功能，实现道理也是这样，只是该聊天室中有多个客户端给服务器发送消息罢了 qq服务器挂在腾讯的某台主机上，相当于起了一个中转站的成分，这种聊天功能的实现对于客户端数量比较少时服务器端还能接受，但是在客户端数量很多时服务器肯定要瘫痪。所以为了减少服务器端的压力，需要实现客户端和客户端之间的直接通信，这样客户端上的qq既要实现服务器端的功能(用于接收信息)又要实现客户端的功能(用于发送信息)。此时qq服务器就不再作为一个中转站的功能了，它主要用于:用于客户端程序登陆,验证用户名密码,获取其他在线好友信息等等。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之IO流深入理解]]></title>
    <url>%2F2018%2F09%2F26%2FJava%E4%B9%8BIO%E6%B5%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[大多数程序都要实现和设备之间的数据传输，例如键盘可以输入数据，显示器可以显示程序的运行结果等。在Java中，将这种通过不同输入输出设备(键盘，内存，显示器，网络等)之间的数据传输抽象表述为”流”，程序允许通过流的方式与输入输出设备进行数据的传输。Java中的”流”都位于java.io包中，称为IO(输入输出)流。 IO流的四大抽象类 InputStream:输入字节流。 OutputStream:输出字节流 Reader:输入字符流 Writer:输出字符流 其中，前两个是字节流，后两个是字符流 字节流概念在计算机中，无论文本，图片，视频，音频，所有的文件都是以二进制(字节)形式存在。IO流中针对字节的输入输出设备提供了一系列的流，统称为字节流。字节流是程序中最常用的流，根据数据的传输方向可将其分为字节输入流和字节输出流。在JDK中，提供了两个抽象类InputStream和OutputStream，它们是字节流的顶级父类，所有的字节输入流都继承自InputStream，所有的字节输出流都继承自OutputStream。 字节输入流(InputStream)常用API方法: int read()从输入流读取一个8位的字节，把它转换成0~255之间的整数，并返回这一整数。 int read(byte[] b);从输入流读取若干字节，把它们保存到参数b指定的字节数组中，返回的整数表示读取字节数。 int read(byte[] b,int off,int len);从输入流读取若干字节，把它们保存到参数b指定的字节数组中，off指定字节数组开始保存数据的起始下标，len表示读取的字节数目 void close();关闭此输入流并释放与该流关联的所有系统资源。 前三个read()方法都是用来读数据的，其中，第一个read()方法是从输入流中逐个读入字节，而第二个和第三个read()方法则将若干字节以字节数组的形式一次性读入，从而提高读数据的效率。在进行IO流操作时，当前IO流会占用一定的内存，由于系统资源宝贵，因此，在IO流操作结束后，应该调用close()方法关闭流，从而释放当前IO流所占的系统资源。实例: import java.io.*; public class Example{ public static void main(String[] args){ FileInputStream in=new FileInputStream(&quot;text.txt&quot;); int b;//定义一个int类型的变量，记住每次读取的一个字节。 while((b=in.read())!=-1) { System.out.prinln(b);//逐个打印出读取的每一个字节 } in.close(); } 字节输入流(OutputStream) void write(int b);向输出流写入一个字节。 void write(byte[] b);把参数b指定的字节数组的所有字节写到输出流。 void write(byte[] b,int off,int len);将指定byte数组中从偏移量off开始的len个字节写入输出流。 void flush();刷新此输出流并强制写出所有缓冲的输出字节。 void close();关闭此输出流并释放与此流相关的所有系统资源。 实例: import java.io.*; public class Example{ public static void main(String[] args){ FileOutputStream out=new FileOutputStream(目标文件的路径); String str=&quot;hello world&quot;; byte[] b=str.getBytes();//字符串调用getBytes()方法即可转换成字节数组。 for(int i=0;i&lt;b.length;i++) { out.write(b[i]); } out.close(); } } InputStream和OutputStream这两个类虽然提供了一系列和读写数据有关的方法，但是这两个类都是抽象类，不能被实例化。因此，针对不同的功能，二者提供了不同的子类。 代码示例import java.io.*; public class Example{ public static void main(String[] args){ String fileName=&quot;xxx&quot;;//源文件路径 String fileName2=&quot;xxx&quot;;//目标文件路径 InputStream in=null; OutputStream out=null; try { in = new FileInputStream(fileName); out = new FileOutputStream(fileName2); int b; while ((b = in.read())!= -1) { out.write(b); } }catch (Exception e) { throw new RuntimeException(e); }finally { try { if (in != null) in.close(); if (out!=null) out.close(); }catch (Exception e) { throw new RuntimeException(e); } } } } 字节缓冲流(BufferedInputStream和BufferedOutputStream)上面的例子实现了对文件的复制，但是一个字节一个字节的读写，需要频繁的操作文件，效率非常低。为了提高效率，需要使用两个带缓冲的字节流，分别是BufferedInputStream和BufferedOutputStream,它们两个同时也属]JDBC之高级知识点中讲到的装饰流。下面通过增加字节缓冲流来对上述例子进行变动: import java.io.*; public class Example{ public static void main(String[] args){ String fileName=&quot;XXX&quot;;//源文件路径 String fileName2=&quot;XXX&quot;;//目标文件路径 InputStream in=null; OutputStream out=null; BufferedInputStream bis=null; BufferedOutputStream bos=null; try { in = new FileInputStream(fileName); bis = new BufferedInputStream(in);//将输入流对象作为参数传递给输入缓冲流 out = new FileOutputStream(fileName2); bos = new BufferedOutputStream(out); int len; while((len=bis.read())!=-1) { bos.write(len); } catch (Exception e) { throw new RuntimeException(e); }finally { try { if (in != null) in.close(); if (bis!=null) bis.close(); if (out!=null) out.close(); if (bos!=null) bos.close(); }catch (Exception e) { throw new RuntimeException(e); } } } } 字符流定义前面我们讲过的InputStream和OutputStream类在读写文件时操作的都是字节，如果希望在程序中操作字符，使用这两个类就不太方便，为此JDK提供了字符流。同字节流一样，字符流也有两个抽象的顶级父类，分别是Reader和Writer。其中Reader是字符输入流，用于从某个源设备读取字符，Writer是字符输出流，用于向某个目标设备写入字符。其API跟字节流的类似。 输入字符流(FileReader)import java.io.*; public class Example{ public static void main(String[] args){ FileReader reader=new FileReader(&quot;reader.txt&quot;); int ch; while((ch=reader.read())!=-1) { System.out.println((char)ch);//通过read()方法读取到的是int类型的值，所以需要进行强制转换。 } reader.close(); } } 输出字符流(FileWrite)import java.io.*; public class Example{ public static void main(String[] args){ FileWrite out=new FileWrite(目标文件的路径); String str=&quot;hello world&quot;; out.write(str); out.close(); } } 字符缓冲流(BufferedWriter和BufferedReader) 字符流同样提供了带缓冲区的包装流，分别是BufferedWriter和BufferedReader,其中BufferedReader用于对字符输入流的包装，BufferedWriter用于对字符输出流的包装。需要注意的是，在BufferedReader中有一个重要的方法readLine()，该方法用于一次读取一行文本。 import java.io.*; public class Example{ public static void main(String[] args){ String fileName=&quot;xxx&quot;;//源文件路径 String fileName2=&quot;xxx&quot;;//目标文件路径 Reader reader=null; BufferedReader bf=null; Writer writer=null; BufferedWriter bw=null; try { reader = new Reader(fileName); br=new BufferedReader(reader); writer = new Writer(fileName2); bw=new BufferedWriter(writer); String str; while ((str = bf.readLine())!= null) { bw.write(str); bw.newLine();//写入一个换行符，该方法会根据不同的操作系统生成相应的换行符。 } }catch (Exception e) { throw new RuntimeException(e); }finally { try { if (reader != null) reader.close(); if (br !=null) br.close(); if (writer!=null) writer.close(); if (bw !=null) bw.close(); }catch (Exception e) { throw new RuntimeException(e); } } } } 字节字符转换流(InputStreamReader和OutputStreamWriter)转换流也是一种包装流，其中OutputStreamWriter是Writer的子类，它可以将一个字节输出流包装成字符输出流，方便直接写入字符，而InputStreamReader是Reader的子类，它可以将一个字节输入流包装成字符输入流，方便直接读取字符。 import java.io.*; public class Example{ public static void main(String[] args){ String fileName=&quot;XXX&quot;;//源文件路径 String fileName2=&quot;XXX&quot;;//目标文件路径 InputStreamReader isr=new InputStreamReader(new FileInputStream(fileName1)); BufferedReader br=new BufferedReader(isr); OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream(fileName2)); BufferedWriter bw=new BufferedWriter(osw); String line; while((line=br.readLine())!=null) { bw.write(line); } br.close(); bw.close(); } } 其他IO流ByteArrayInputStream和ByteArrayOutputStream在前面的学习中，都是将文件直接存储到硬盘，但有时候我们希望将文件临时存储到缓冲区，方便以后读取。为此JDK中提供了一个ByteArrayOutputStream类。该类会在创建对象时就创建一个byte型数组的缓冲区，当向数组中写数据时，该对象会把所有的数据先写入缓冲区，最后一次行写入文件。Demo:将数据写入缓冲区 import java.io.*; public class Example{ public static void main(String[] args){ String fileName1=&quot;/Users/codingBoy/Desktop/example1.jpg&quot;;//源文件路径 String fileName2=&quot;/Users/codingBoy/Desktop/example2.jpg&quot;;//目标文件路径 FileInputStream in=new FileInputStream(fileName1); ByteArrayOutputStream bos=new ByteArrayOutputStream(); FileOutputStream out=new FileOutputStream(fileName2); int b; while((b=in.read())!=-1) { bos.write(b); } in.close(); bos.close(); out.write(bos.toByteArray());//先将数据写入缓冲区，当需要写入目标文件中的时候再调用输出流的write(bos.toByteArray())方法。 out.close(); } 将从fileName1文件中读取的字节全部写入该对象的缓冲区，通过FileOutputStream对象将缓冲区的数据一次性写入fileName2文件。与ByteArrayOutputStream类似，ByteArrayInputStream是从缓冲区中读取数据，接下来通过一个案例来演示ByteArrayInputStream如何读取缓冲区的数据。 import java.io.*; public class Example{ public static void main(String[] args){ byte[] bytes=new byte[]{97,98,99,100}; ByteArrayInputStream bis=new ByteArrayInputStream(bytes); int b; while((b=bis.read())!=-1) { System.out.println((char)b); } } 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC之高级知识点]]></title>
    <url>%2F2018%2F09%2F25%2FJDBC%E4%B9%8B%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[事务管理事务的四大特性（ACID） 原子性:事务中的所有操作要么全部执行成功，要么执行全部失败。 一致性:事务执行后，数据库状态与其它业务规则保持一致。 隔离性:隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。 持久性:一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中。即使提交事务后数据库马上崩溃，在数据库重启后，也必须能保证通过某种机制恢复数据。 mysql中操作数据库 在控制台中输入语句:start transaction;即开始事务。 在控制台中输入语句:rollback;回滚事务，即在此事务中执行的操作全部无效，数据库回到start transaction;之前(但是前提是使用该语法前没有执行commit transaction;操作)。 在控制台中输入语句:commit transaction;即提交事务。 JDBC中操作事务事务的隔离级别事务的并发读问题 脏读:读取到另一份事务未提交数据，即读到了脏数据。 不可重复读：两次读取不一致。对统一记录的两次读取不一致，因为另一事务对该记录做了修改。 幻读：又叫虚读。对同一张表的两次查询不一致，因为另一事务进行了插入了一条记录的操作。 四大隔离级别(防止上述问题) SERIALIZABLE(串行化)：不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的。性能最差，可能导致死锁。 REPEATABLE READ(可重复读)(mysql默认级别)：防止脏读和不可重复读，不能处理幻读问题。性能比a的好。 READ COMMITTED(读已提交数据)(Oracle默认级别)：防止脏读，没有处理不可重复读，也没有处理幻读。性能比上述b好。 READ UNCOMMITTED(读未提交数据):可能出现任何事务并发问题。性能最好。但基本没人用。 查看mysql隔离级别 在控制台中输入语句:select @@tx_isolation;也可以通过下面命令来设置隔离级别:set transaction isolationlevel[4选1]; 在Jdbc中设置隔离级别con.setTransactionisolation[int lever]; 数据库连接池用户每次请求都需要向数据库获得链接，而数据库创建连接通常需要消耗相对较大的资源，创建时间也较长。假设网站一天10万访问量，数据库服务器就需要创建10万次连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。 数据库连接是一种关键的有限的昂贵的资源,这一点在多用户的网页应用程序中体现的尤为突出.。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正式针对这个问题提出来的。数据库连接池负责分配，管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中, 这些数据库连接的数量是由最小数据库连接数来设定的.无论这些数据库连接是否被使用,连接池都将一直保证至少拥有这么多的连接数量.连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数,当应用程序向连接池请求的连接数超过最大连接数量时,这些请求将被加入到等待队列中。 设置池参数设置初始化大小:connection.setInitialSize(); 设置最小空闲连接数:connection.setMinIdle(); 设置最大空闲连接数:connection.setMaxIdle(); 设置最小连接数:connection.setMinActive(); 设置最大连接数:connection.setMaxActive(); 设置增量:一次创建的最小单位。 设置最大的等待时间:connection.setMaxWait(); c3p0数据库连接池c3p0,全名叫ComboPooledDataSource; 需要导入的jar包连接池的实现:c3p0-0.9.5.2.jar和依赖库:mchange－commons.jar实例: public class Demo{ public static void main(String[] args) { //创建连接池对象 ComboPooledDataSource dataSource=new ComboPooledDataSource(); //进行四大参数的配置 dataSource.setDriverClass(“com.mysql.jdbc.Driver”); dataSource.setJdbcUrl(“jdbc:mysql://localhost:3306/mydb”); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;123&quot;); //池配置 dataSource.setAcquireIncrement(5); dataSource.setInitialPoolSize(20); dataSource.setMinPoolSize(2); dataSource.setMaxPoolSize(50); Connection con=dataSource.getConnection(); System.out.println(con); con.close(); } } c3p0配置文件的使用： 文件名称:必须叫c3p0-config.xml。文件的位置:必须在src下。 实例: public class Demo{ public static void main(String[] args) { //在创建连接池对象时，这个对象就会自动加载配置文件，不用我们来指定。 ComboPooledDataSource data=new comboPooledDataSource(); Connection con=data.getConnection(); System.out.println(con); } } Tomcat服务器配置数据库连接池JNDI:java命名和目录接口。作用:在服务器上配置资源，然后通过统一的方式来获取配置的资源。首先需要在Tomcat/conf/Catelina/localhost目录下新建文件名: 项目名.xml 获取资源的代码: Context initCtx=new InitialContext();//创建一个上下文。 Context envCtx=(Context) initCtx.lookup(“java:comp/env”);//这个路径是固定的不能改。 MyBean bean=(MyBean)envCtx.lookup(“bean/MyBeanFactory”);//通过该上下文进行二次查找才能找到资源 测试: dbtils结果集处理器介绍需要导入的jar包:common-dbutil.jar;c3p0.jar;mchange-commons.jar。关键要得到QueryRunner对象，然后调用其各种方法。 update()方法: int update(String sql,Object… params) 可执行增删改语句。重载方法int update(Connection con,String sql, Object… params)需要调用者提供Connection，这说明本方法不再管理Connection了。本重载方法支持事务。 query()方法: T query (String sql,ResultSetHandler rsh,Object… params)可执行查询操作。 重载方法:T query(Connection con,String sql,ResultSetHandler rsh,Object… params); 本重载方法支持事务。它会先得到ResultSet，然后调用rsh的handle()把rs转换成需要的类型。 ResultSetHandler接口 BeanHandler(单行)－－&gt;构造器需要一个class类型的参数，用来把一行结果转换成指定类型的javaBean对象。 BeanListHandler(多行)—&gt;构造器也是需要一个Class类型的参数，用来把一行结果集转换成一个javabean，哪么多行就是转换成List对象，一堆javabean。 MapHandler(单行)—&gt;把一行结果集转换成Map对象。 MapListHandler(多行)—&gt;把一行记录转换成一个Map，多行就是多个Map，即List。 ScalarHandler(单行单列)－&gt;同来用于select count(＊)from t_stu语句，结果集是单行单列的，它返回一个Object，就是count(*)的值，为long类型。 dbutil结果处理集原理代码: public class QR { private DataSource dataSource; public QR(DataSource dataSource) { this.dataSource=dataSource; } public QR(){ super(); } public int update(String sql,Object... params) { Connection con=null; PreparedStatement pstmt=null; try { con=dataSource.getConnection();//通过连接池得到连接对象 pstmt=con.prepareStatement(sql); initParams(pstmt,params);//给出参数 return pstmt.executeUpdate();//调用update执行增、删、该 }catch (Exception e) { throw new RuntimeException(e); }finally { try{ if (pstmt!=null) pstmt.close(); if (con!=null) con.close(); }catch (SQLException e){} } } //给参数赋值 public void initParams(PreparedStatement pstmt,Object... params) throws SQLException { for (int i = 0; i &lt; params.length; i++) { pstmt.setObject(i+1,params[i]); } } public T query(String sql,RsHandler&lt;T&gt; rh,Object... params) throws SQLException { Connection con=null; PreparedStatement pstmt=null; ResultSet rs=null; try { con=dataSource.getConnection();//通过连接池得到连接对象 pstmt=con.prepareStatement(sql); initParams(pstmt,params);//给出参数 rs=pstmt.executeQuery();//调用update执行增、删、该 return rh.handle(rs); }catch (Exception e) { throw new RuntimeException(e); }finally { if (rs!=null) rs.close(); if (pstmt!=null) pstmt.close(); if (con!=null) con.close(); } } interface RsHandler&lt;T&gt; { public T handle(ResultSet rs); } } 这样我们以后对数据库进行增、删、改操作时，只需写以下代码即可: 1.QueryRunner qr=new QueryRunner(JdbcUtils.getDataSource);//创建QueryRunner对象，并传入连接池对象 2.String sql=&quot;insert into user values(?,?,?,?);//给出sql语句模板 3.Object[] params={参数1，参数2，参数3，参数4};//传入参数 4.qr.update(sql,params);//调用qr方法。 通过这简单的四步就可以对数据库进行增删改了。 在jar包中，QueryRunner类的update(没有connection参数的)方法，在finally中将connection进行了关闭;在update(有connection参数的)方法中，在finally中没有对connection进行关闭(暂时这么记吧，不然要是进行关闭了的话，在传智播客写的小工具封装类TxQueryRunner中将connection传入JdbcUtils的releaseConnecion()方法中对connection进行关闭时会出现报错)。 在讲到事务时，我们会对QueryRunner进行再次封装。上述写出的QueryRunner的代码只是包中的QueryRunner源码方法的一部分(因为源码中还有很多的重载方法)，我们会通过另一个类TxQueryRunner(较QueryRunner多出的一个功能就是它支持事务)继承该类，在TxQueryrunner类中，对connection进行了判断:若connection为事务中的connection则在TxqueryRunner的update()方法中不对connection进行关闭，而是在commitTransaction()即提交事务时进行关闭;若connection为普通连接，则将connection进行关闭。那么以后我们在DAO中要获取的就不是QueryRunner对象，而是通过QueryRunner qr=new TxQueryRunner();获取TxQueryRunner对象了。 装饰者模式将对象增强的手段有: 继承 缺点:1.增强的内容是死的，不能动。2.被增强的对象也是死的。 装饰着模式 特点:1.增强的内容是不能修改的。2.被增强的对象可以是任意的。 动态代理AOP 下面通过一个简单的例子来对装饰者模式进行讲解 class 咖啡类 {}; class 加奶咖啡 extends 咖啡类 {}; class 加糖咖啡 extends 咖啡类 {}; class 加盐咖啡 extends 咖啡类 {}; 咖啡 a＝new 加糖咖啡(); 咖啡 b＝new 加盐咖啡(a);//对a进行装饰，就是给a加盐 咖啡 c＝new 加奶咖啡(b);//对b进行装饰，就是给b加奶 装饰者模式在Java API中的IO流中用到的很多。如BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter、ObjectInputStream、ObjectOutputStream这几个都是运用了装饰模式的装饰流。关于的IO流的详情见IO博文。 ThreadLocal早在JDK 1.2的版本中就提供Java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。 Thread API void set(Object value);设置当前线程的线程局部变量的值。 Object get();该方法返回当前线程所对应的线程局部变量。 void remove();将当前线程局部变量的值删除，目的是为了减少内存的占用。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。 ThreadLocal内部结构ThreadLocal内部用Map来保存数据。虽然在使用上述API时没有给出键，但其实它内部使用了当前线程作为键。内部结构见下面demo: class ThreadLocal { private Map&lt;Thread,T&gt; map=new HashMap&lt;Thread,T&gt;(); public void set(T value){ map.put(Thread.currentThread(),value); } public void remove(){ map.remove(Thread.currentThread()); } public T get(){ return map.get(Thread.currentThread()); } } 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>JDBC</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb之JDBC详解]]></title>
    <url>%2F2018%2F09%2F25%2FJavaWeb%E4%B9%8BJDBC%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概念JDBC，全称java database connectity,即Java数据库连接，意思是用Java语言操作数据库，可以为多种数据库提供统一的连接(MySql,Sql Server, Oracle)。原本我们都是通过在命令行或者在数据库图形化界面工具上面输入SQL语句操作数据库。而JDBC则是用Java语言向数据库发送SQL语句来操作数据库。 JDBC流程 获得Connection的对象 导jar包。mysql-connector-java jar 加载驱动类:Class.forName(“类名”); 配置url、username、password等参数 使用DriverManager类来的到Connection对象。 示例: public class Demo{ public void main(String[] args) throws ClassNotFoundException,SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载驱动类。 String url=&quot;jdbc:mysql://localhost:3306/数据库名&quot;; String username=&quot;数据库账号&quot;; String password=&quot;数据库密码&quot;; Connection con=DriverManager.getConnection(url,username,password); } } 代码分析: url的格式为–jdbc:厂商名称:子协议(由厂商自己来规定)。对于mysql而言，它的子协议结构的格式为://localhost:3306/数据库名。 出现SQLException的原因:1.url username password 是否正确。2.检查是否打开了sql服务器 出现ClassNotFoundException的原因:1.没导入驱动包。2.Class.forName()传入的驱动类错误。 JDBC之增删改查增，删，改示例: public class Demo{ public void main(String[] args) throws ClassNotFoundException,SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载驱动类。 String url=&quot;jdbc:mysql://localhost:3306/数据库名&quot;; String username=&quot;root&quot;; String password=&quot;123&quot;; Connection con=DriverManager.getConnection(url,username,password); Statement stmt=con.createStatement(); String sql＝&quot;insert into stu values(&apos;...&apos;,&apos;...&apos;,&apos;...&apos;,&apos;...&apos;)&quot;; stmt.executeUpdate(sql); } } 代码分析: 调用Connection的方法创建Statement对象，它是sql语句的发送器，功能就是向数据库发送sql语句 sql不需要打分号，打了就会出错，因为程序会自动帮我们加。 调用此方法向数据库发送sql语句。该语句返回的值为改变数据库的行数。 查询public class Demo{ public void main(String[] args) throws ClassNotFoundException,SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载驱动类。 String url=&quot;jdbc:mysql://localhost:3306/数据库名&quot;; String username=&quot;root&quot;; String password=&quot;123&quot;; Connection con=DriverManager.getConnection(url,username,password); Statement stmt=con.createStatement(); String sql=&quot;selece * from stu&quot;; ResultSet rs=stmt.execute(sql);//ResultSet提供了一系列的getXxx()方法 while(rs.next())//第一次调用next()方法是将光标移动到该表的第一行 { rs.getInt(1);//通过列编号来获取该列的值，如果第一列是id，此时得到id的值 rs.getString(&quot;name&quot;);//通过列名称来获取该列的值。 } } } 关闭资源数据库连接时重要的资源，不用时应该关闭。关闭资源时采用倒关的手法将对象进行处理:即先得到的对象后关，后得到的对象先关 PreparedStatement接口PrepaerdStatement是Statement的子接口示例: public class Demo{ public void main(String[] args) throws ClassNotFoundException,SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载驱动类。 String url=&quot;jdbc:mysql://localhost:3306/数据库名&quot;; String username=&quot;root&quot;; String password=&quot;123&quot;; Connection con=DriverManager.getConnection(url,username,password); String sql=&quot;insert into stu values(?,?)&quot;;//定义sql模板，即参数以问号的形式给出 PreparedStatement pst=con.prepaerStatement(sql); pst.setString(1,username);//数字1代表第一个问号 pst.setString(2.password);//数字2代表第二个问号 pst.executeUpdate();//向数据库发送sql语句 } } 原理： 检验sql语句的语法 编译：一个与函数相似的东西 执行：调用函数 Java中的时间类型和mysql中的时间类型转换数据库类型与Java中类型的对应关系 数据库中的DATE–&gt;java.sql.Date–&gt;java.util.Date; 数据库中的TIME–&gt;java.sql.Time–&gt;java.util.Date; 数据库中的TIMESTAMP–&gt;java.sql.Timestamp–&gt;java.util.Date; 需要注意的是: 领域对象(domain)中的所有属性不能出现java.sql包下的东西，即不能使用java.sql.Date、java.sql.Time、java.sql.TimeStamp。 ResultSet的getDate()返回的是java.sql.Date()。 PreparedStatment的setDate(int,Date),其中第二个参数是sql包下的java.sql.Date()。为了在java中使用sql包下的时间类型，这时就出现了时间类型的转换。 具体的转换将util包下的Date转换为sql包下的Date、Time、Timestamp 把util的的Date转换成毫秒值。 使用毫秒值创建sql的Date、Time、Timestamp java.util.Date date=new java.util.Date(); long l=date.getTime(); java.sql.Date sqlDate=new java.sql.Date(l); 将sql包下的Date、Time、Timestamp转换为util包下的Date 因为sql包下的Date、Time、和Timestamp继承自util包下的Date。所以可以直接用: JDBC之数据库存取大文件示例:存 String sql = “INSERT INTO tab_bin VALUES(?,?,?)”; PreparedStatement pstmt = con.prepareStatement(sql); pstmt.setInt(1,001); pstmt.setString(2,”hello.mp3”); // mp3 保存为 blob 类型的数据 // 通过 commons-io 工具类, 将 mp3 转换成 byte[] Byte[] bytes = IOUtils.toByteArray(new FileInputStream(&quot;/Users/姓名/Desktop/hello.mp3&quot;)); // 使用 bytes, 创建 Blob 对象 Blob blob = new SerialBlob(bytes); pstmt.setBlob(3,blob); // 发送 sql 语句 pstmt.executeUpdate(); 示例:取 String sql = “SELECT * FROM tab_bin”; PreparedStatement pstmt = con.prepareStatement(sql); ResultSet rs = pstmt.executeQuery(); // 将 rs 中名为 data 列的数据 if(rs.next()){ Blob blob = rs.getBlob(&quot;data&quot;); // 把 blob 转换成硬盘上的 mp3 文件 // 1. 通过 blob 得到输入流对象 // 2. 自己创建输出流对象 // 3. 把输入流的数据写入到输出流中 InputStream in = blob.getBinaryStream(); OutputStream out = new FileOutputStream(&quot;/Users/姓名/Document/world.mp3&quot;); // 使用io流工具类中的方法 IOUtils.copy(in,out); 批处理批处理只针对更新(增、删、改)当需要向数据库发送多条sql语句时, 为了提升执行效率, 可以考虑采用JDBC的批处理机制.JDBC的批处理机制主要涉及Statement或PreparedStatement对象的以下方法： addBatch(String sql) ：Statement类的方法, 多次调用该方法可以将多条sql语句添加到Statement对象的命令列表中. addBatch(): PreparedStatement类的方法, 多次调用该方法可以将多条预编译的sql语句添加到PreparedStatement对象的命令列表中.执行批处理时将一次性的把这些sql语句发送给数据库进行处理. executeBatch()：把Statement对象或PreparedStatement对象命令列表中的所有sql语句发送给数据库进行处理. clearBatch(): 清空当前sql命令列表. 采用Statement.addBatch(sql)方式实现批处理的优缺点： 优点：可以向数据库发送多条不同的ＳＱＬ语句。 缺点：SQL语句没有预编译。当向数据库发送多条语句相同，但仅参数不同的SQL语句时，需重复写上很多条SQL语句 采用PreparedStatement.addBatch()方式实现批处理的优缺点: 优点：发送的是预编译后的SQL语句，执行效率高。 缺点：只能应用在SQL语句相同，但参数不同的批处理中。因此此种形式的批处理经常用于在同一个表中批量插入数据，或批量更新表的数据。 注意:mysql默认批处理是关闭的，需要在url参数后面加上?rewriteBatchedStatement=true; 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>JDBC</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码检查规范CheckStyle和PMD的配置使用]]></title>
    <url>%2F2018%2F09%2F21%2F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E8%A7%84%E8%8C%83CheckStyle%E5%92%8CPMD%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[CheckStyle是SourceForge下的一个项目，提供了一个帮助JAVA开发人员遵守某些编码规范的工具。它能够自动化代码规范检查过程，从而使得开发人员从这项重要，但是枯燥的任务中解脱出来。PMD是一种开源分析Java代码错误的工具。与其他分析工具不同的是，PMD通过静态分析获知代码错误。也就是说，在不运行Java程序的情况下报告错误。PMD附带了许多可以直接使用的规则，利用这些规则可以找出Java源程序的许多问题。现在就来看看它们的安装配置和使用吧。 CheckStyle插件的安装与配置安装CheckStyle插件 CheckStyle插件的配置 当安装好插件，打开 IDEA的设置页面 settings -&gt; Other Settings 你会发现默认的 Checkstyle , 勾选就OK了,如上图。其实在还可以点击上面绿色加号添加自定义checkstyle文件，该文件放在项目的根目录。在里面可以设置你想要的格式。基本的配置就完毕了。现在 IDEA的控制面板会多一个 CheckStyle，你可以在这里方便的进行代码检查。可以点击面板的左上角下拉框 Rules 去动态切换不同的 checkstyle。 CheckStyle插件的使用完成安装与配置之后CheckStyle，便可以运行CheckStyle。根据CheckStyle扫描结果对应修改。 定制专属CheckStyle检查规则 CheckStyle不管是插件方式还是脚本方式，使用都是相当方便快捷的，而难点在于如何定制专属于我们项目的CheckStyle检查规则。 定制CheckStyle规则大致思路：通过对Google 提供的checkStyle检查规则修改完善，打造出属于自己的检查规则。谷歌配置文件规则 在配置文件中中主要由module 、property、message等节点构成： module节点 主要是指检查项，如MethodName （检查方法命名）module中有两个比较重要的节点，它们分别是Checker（checkStyle配置文件的根节点，必须存在）、TreeWalker（树遍历器），TreeWalker会自动去检查指定范围内的每一个java源文件，TreeWalker内部会定义很多module。 property 节点对应module 检查项中具体检查属性，如果使用默认值，property节点可以省略 message节点 checkStyle检查出来，是否打印出message消息，message节点可以省略 如何添加过滤能力？ 解决办法：在定制好的checkStyle.xml文件中，添加一个名为SuppressionFilter的moudle，在过滤规则文件suppressions.xml中添加相应的过滤规则。 PMD插件的安装和使用 自动安装：file –&gt; settings –&gt; plugins 搜索 pmd 用户可以选择在单个或者多个文件或文件夹上运行PMD：选中 文件或文件夹 –&gt; 右击 –&gt; Run PDM –&gt; 选择规则集 联系 Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于抽象类和接口]]></title>
    <url>%2F2018%2F09%2F20%2F%E5%85%B3%E4%BA%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[对于面向对象编程来说，抽象是它的一大特征之一。在Java中，可以通过两种形式来体现OOP的抽象：接口和抽象类。这两者有太多相似的地方，又有太多不同的地方。很多人在初学的时候会以为它们可以随意互换使用，但是实际则不然。下面我们一起来学习一下Java中的接口和抽象类： 什么是抽象方法和抽象类在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法和抽象类的声明格式分别为： 抽象方法: abstract void fun(); 抽象类:abstract class ClassName {abstract void fun();} 关于抽象类 抽象类是为了继承而存在的，它并不能被实例化 如果一个类继承于一个抽象类，那么它必须实现父类的抽象方法，除非它自己也是抽象类。 什么是接口在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对行为的抽象。 接口中可以含有变量，而方法会被隐式地指定为public abstract方法，它是一种极度抽象的类型，它比抽象类更加“抽象” 接口中的变量会被隐式地指定为public static final变量，但是一般情况下不在接口中定义变量。 ##抽象类和接口的区别 1.语法层面上的区别 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法； 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 2.设计层面上的区别 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 什么时候用抽象类，什么时候用接口 如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。 如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。 联系 Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码重构的方式理解MVC模式]]></title>
    <url>%2F2018%2F09%2F20%2F%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E7%9A%84%E6%96%B9%E5%BC%8F%E7%90%86%E8%A7%A3MVC%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[MVC模式是基于WEB系统模块化框架的大思想，繁衍出的一个把视图和处理做低耦合分离的一种模式。核心就是尽可能让一个后台系统，在几乎不做任何修改的情况下，同时支持多种视图。但是它的缺点是由于它没有明确的定义，所以完全理解MVC并不是很容易。使用MVC需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。 接下来我将以代码重构的方式帮助我们更好地理解MVC设计模式。 关于MVC设计模式MVC模式（Model-View-Controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）： Model——业务功能编写（例如算法实现）、数据库设计以及数据存取处理等操作实现 Controller——负责转发请求并对请求进行处理 View——负责界面显示 在JSP/Servlet开发的软件系统中，这三个部分的实现如下所示： Web浏览器发送HTTP请求到服务端，被Controller(Servlet)获取并进行处理（例如参数解析、请求转发） Controller(Servlet)调用核心业务逻辑——Model部分，获得结果 Controller(Servlet)将逻辑处理结果交给View（JSP），动态输出HTML内容 动态生成的HTML内容返回到浏览器显示 MVC模式在Web开发中的好处是非常明显，它规避了JSP与Servlet各自的短板，Servlet只负责业务逻辑而不会通过out.append()动态生成HTML代码；JSP中也不会充斥着大量的业务代码。这大大提高了代码的可读性和可维护性。本博文相关github代码如下点击进入github 具体体现 在进行代码重构之前的Servlet代码: @SuppressWarnings(&quot;serial&quot;) public class ListServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { try { //设置编码 req.setCharacterEncoding(&quot;UTF-8&quot;); //获取页面的值 String command = req.getParameter(&quot;command&quot;); String description = req.getParameter(&quot;description&quot;); //向页面传接到的值 req.setAttribute(&quot;command&quot;, command); req.setAttribute(&quot;description&quot;, description); Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis&quot;, &quot;root&quot;, &quot;123456&quot;); StringBuilder sql = new StringBuilder(&quot;select ID, COMMAND, DESCRIPTION, CONTENT from MESSAGE where 1 = 1&quot;) ; List&lt;String&gt; paramList = new ArrayList&lt;&gt;();//缓冲,添加动态传参 if (command != null &amp;&amp; !&quot;&quot;.equals(command.trim())) { sql.append( &quot; and COMMAND = ?&quot;); paramList.add(command); } if (description != null &amp;&amp; !&quot;&quot;.equals(description.trim())) { sql.append( &quot; and DESCRIPTION like &apos;%&apos; ? &apos;%&apos;&quot;); paramList.add(description); } PreparedStatement statement = conn.prepareStatement(sql.toString()); for (int i = 0; i &lt; paramList.size(); i++) { //sql语句从1开始的，所以i+1 statement.setString(i+1, paramList.get(i)); } ResultSet rs = statement.executeQuery(); List&lt;Message&gt; messageList = new ArrayList&lt;&gt;(); while(rs.next()) { Message message = new Message(); messageList.add(message); message.setId(rs.getString(&quot;ID&quot;)); message.setCommand(rs.getString(&quot;COMMAND&quot;)); message.setDescription(rs.getString(&quot;DESCRIPTION&quot;)); message.setContent(rs.getString(&quot;CONTENT&quot;)); } //查询消息列表并传给页面 req.setAttribute(&quot;messageList&quot;, messageList); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } req.getRequestDispatcher(&quot;/WEB-INF/jsp/back/list.jsp&quot;).forward(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } 上述servlet代码不仅负责了业务逻辑代码，如获取页面的值，向页面传接收到的值，还包括了获取数据库驱动，获取数据库连接和相关的数据库操作代码。这样使得servlet的代码过于冗长，代码的可读性，可维护性差 下面是代码重构之后的servlet @SuppressWarnings(&quot;serial&quot;) public class ListServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //设置编码 req.setCharacterEncoding(&quot;UTF-8&quot;); //获取页面的值 String command = req.getParameter(&quot;command&quot;); String description = req.getParameter(&quot;description&quot;); //向页面传接到的值 req.setAttribute(&quot;command&quot;, command); req.setAttribute(&quot;description&quot;, description); ListService listService = new ListService(); //查询消息列表并传给页面 req.setAttribute(&quot;messageList&quot;, listService.queryMessageList(command, description)); req.getRequestDispatcher(&quot;/WEB-INF/jsp/back/list.jsp&quot;).forward(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } 下面的代码是重构之后的dao代码: public class MessageDao { public List&lt;Message&gt; queryMessageList(String command, String description){ List&lt;Message&gt; messageList = new ArrayList&lt;&gt;(); try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis&quot;, &quot;root&quot;, &quot;123456&quot;); StringBuilder sql = new StringBuilder(&quot;select ID, COMMAND, DESCRIPTION, CONTENT from MESSAGE where 1 = 1&quot;) ; List&lt;String&gt; paramList = new ArrayList&lt;String&gt;();//缓冲,添加动态传参 if (command != null &amp;&amp; !&quot;&quot;.equals(command.trim())) { sql.append( &quot; and COMMAND = ?&quot;); paramList.add(command); } if (description != null &amp;&amp; !&quot;&quot;.equals(description.trim())) { sql.append( &quot; and DESCRIPTION like &apos;%&apos; ? &apos;%&apos;&quot;); paramList.add(description); } PreparedStatement statement = conn.prepareStatement(sql.toString()); for (int i = 0; i &lt; paramList.size(); i++) { statement.setString(i+1, paramList.get(i)); } ResultSet rs = statement.executeQuery(); while(rs.next()) { Message message = new Message(); //先放和后放是一样的，因为容器里面放的都是引用，不是真正的对象本身，所以接下来对这个对象操作依然有效 messageList.add(message); message.setId(rs.getString(&quot;ID&quot;)); message.setCommand(rs.getString(&quot;COMMAND&quot;)); message.setDescription(rs.getString(&quot;DESCRIPTION&quot;)); message.setContent(rs.getString(&quot;CONTENT&quot;)); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } return messageList; } } 下面是重构之后的数据库连接代码 public class DBHelper { private static final String driver = &quot;com.mysql.jdbc.Driver&quot;; //因为这些变量都是，全局的不需要修改的，固定的写法，所以设置为静态的私有的 private static final String url=&quot;jdbc:mysql://localhost:3306/shopping?useUnicode=true&amp;characterEncoding=UTF-8&quot;; private static final String username=&quot;root&quot;; private static final String password=&quot;123456&quot;; private static Connection conn=null; //静态代码块负责加载驱动 static { try { Class.forName(driver); } catch(Exception ex) { ex.printStackTrace(); } } public static Connection getConnection() throws Exception//static关键字表示类方法，直接通过类名调用 { if(conn==null) { conn = DriverManager.getConnection(url, username, password); return conn; } return conn; } public static void main(String[] args) { try { Connection conn = DBHelper.getConnection(); if(conn!=null) { System.out.println(&quot;数据库连接正常&quot;); } else { System.out.println(&quot;数据库连接异常&quot;); } } catch(Exception ex) { ex.printStackTrace(); } } } 通过代码重构可以清楚的发现，使用MVC设计模式的项目的代码可读性更高，可维护性更高。但是其实MVC设计模式也有它的不足: 增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。 视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。 联系如果需要联系作者，请在主页点击右下角的微信图标，或者通过以下方式: Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合工程的搭建]]></title>
    <url>%2F2018%2F09%2F17%2FSSM%E6%95%B4%E5%90%88%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[当我们系统的学完了Spring、Spring MVC以及Mybatis之后就可以进行这三者的整合工作了，也就是SSM框架的整合，其实就是将这三个框架的配置文件提取出来放在一个项目中，然后便可以进行开发，是不是觉得挺简单的。这篇文章我们将在前篇文章Mybatis与Spring整合的基础上将Spring MVC的配置引入进来完成SSM框架的整合。 整合的思路 在Mybatis与Spring3整合的基础上再进行Spring MVC框架的整合。 Spring要管理Spring MVC编写的Handler(controller)、Mybatis的SqlSessionFactory、mapper、数据源。其实整合思路就是下面这三步: 第一步:整合dao(即mapper)，完成Spring与Mybatis的整合 第二步:整合service，Spring管理service接口，service中可以调用Spring容器中的dao(mapper)。 第三步:整合controller，Spring管理controller接口，在controller调用service。 pom.xml的需要导入的依赖&lt;!--添加mybatis-generator-core.jar依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.30&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;${log4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- 映入JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传组件包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; pom.xml的需要导入的配置&lt;properties&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt; &lt;!-- log4j日志文件管理包版本 --&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;!-- 强制将xml文件打到war包中 s--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; spring-mybatis.xml,spring-mvc.xml和web.xml spring-mybatis.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;dao&quot; /&gt; &lt;context:component-scan base-package=&quot;pojo&quot; /&gt; &lt;context:component-scan base-package=&quot;mapping&quot; /&gt; &lt;context:component-scan base-package=&quot;service&quot; /&gt; &lt;context:component-scan base-package=&quot;serviceimpl&quot; /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;${initialSize}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;${maxActive}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;${maxIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;${minIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;${maxWait}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapping/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; spring-mvc.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package=&quot;controller&quot; /&gt; &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;mappingJacksonHttpMessageConverter&quot; /&gt; &lt;!-- JSON转换器 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 默认编码 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot; /&gt; &lt;!-- 文件大小最大值 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760000&quot; /&gt; &lt;!-- 内存中的最大值 --&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring和mybatis的配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 防止Spring内存溢出监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Spring MVC servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 此处可以可以配置成*.do，对应struts的后缀习惯 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 然后，在src下创建各个包:mapper、po、controller、service，在web包下创建页面包jsp。经过上述步骤，我们便完成了Spring、Spring MVC与Mybatis的整合，是不是很简单?没错就是这么简单。 联系如果需要联系作者，请在主页点击右下角的微信图标，或者通过以下方式: Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis和Spring整合]]></title>
    <url>%2F2018%2F09%2F17%2FMyBatis%E5%92%8CSpring%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[MyBatis是一种开源的半自动的持久化框架，它通过抽象jdbc模板代码提供简单的api交互简化持久层实现。通过读取mybatis.xml，Mapper.xml，Mapper映射了相应的JavaBean，通过SqlSessionFactory的实例化出来的SqlSession，执行对应方法，根据方法名回到Mapper.xml中找到和方法名相对应的id(注释方式的话找到接口类里面注释id对应的方法)，根据sql语句，还有传入的参数，还有Bean，这几者的联系形成的映射，进行CURD操作，省去JDBC那些模板方法代码。Spring也是开源框架，简化了Java开发，其主要功能是依赖注入和面向切面工程。 mybatis和spring整合的思路 使用spring管理SqlSessionFactory 使用spring管理mapper对象和dao 使用spring和mybatis整合开发mapper代理及原始dao接口。自动开启事务，自动管理sqlsession 让spring管理数据源(即数据库连接池) 开始整合工作pom.xml的需要导入的依赖和配置 需要导入的依赖 &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.30&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;${log4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- 映入JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; 整合配置文件spring-MyBatis.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;dao&quot; /&gt; &lt;context:component-scan base-package=&quot;pojo&quot; /&gt; &lt;context:component-scan base-package=&quot;mapping&quot; /&gt; &lt;context:component-scan base-package=&quot;service&quot; /&gt; &lt;context:component-scan base-package=&quot;serviceimpl&quot; /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;${initialSize}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;${maxActive}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;${maxIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;${minIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;${maxWait}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapping/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 至此，MyBatis便和Spring整合成功。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA创建MyBatis逆向工程]]></title>
    <url>%2F2018%2F09%2F17%2FIDEA%E5%88%9B%E5%BB%BAMyBatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[过去我们在开发时都需要通过数据库中的表然后自己在po包下手动建立相对应的pojo类，并要创建相应的mapper.xml写出对表的所有操作，而使用插件mybatis-generator-core生成mybatis逆向工程就不用我们自己再编写pojo类与相应的mapper类和相应的xml文件，它可以自动对单表生成sql，包括:mapper.xml、mapper.java、表名.java(po类)。这是非常方便快捷的。下面我将为你们介绍如何使用插件生成mybatis的逆向工程，只需三步而已。 逆向工程的部署话不多说，直接上图，点击运行即可生成相应的entity类，dao接口和mapper.xml。相关代码文件请移步我的github点击进入我的github pom.xml的需要导入的依赖和配置 需要导入的jar包和依赖 &lt;!-- -添加mybatis-generator-core插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;/dependency&gt; 此外还需要右击项目新建一个Direcrory,命名为lib,将数据库驱动包放进去 需要更改的配置 &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; 逆向工程的配置文件generatorConfig.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;!-- 数据库驱动--&gt; &lt;classPathEntry location=&quot;lib/mysql-connector-java-5.0.5-bin.jar&quot;/&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/ssmtest&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;!--设置为 true 可以获取 tables 信息, 解决生成文件缺少 xxxByPrimaryKey 的问题 --&gt; &lt;property name=&quot;useInformationSchema&quot; value=&quot;true&quot;/&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置--&gt; &lt;javaModelGenerator targetPackage=&quot;pojo&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage=&quot;mapping&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;dao&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName=&quot;user_t&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 关键的属性: javaModelGenerator,生成PO类的位置 sqlMapGenerator,mapper映射文件生成的位置 javaClientGenerator,mapper接口生成的位置 table,其tableName属性对应数据库中相应表 配置相应的运行命令点击Edit Configuration，点击+号，在Command line中输入mybatis-generator:generate -e然后点击应用，选择运行，等一会逆向工程便成功地建立！ ###需要注意的地方1.多次运行生成逆向工程然后进行SpringJUnit集成测试时，报错Result Maps collection already contains value for … 原因及解决办法:多次使用逆向工程生成mapper接口和xml文件时，是增加，而不是覆盖。所以需要将已经生成的文件删除，重新运行逆向工程。解决问题的根本方法是:在配置文件中 2.使用数据库驱动为8.0.11时生成的DAO接口只生成insert方法,这是特别的坑点，希望大家不要被坑了。 解决的办法:如果使用的mysql驱动是6.x,8.x的，那就无法生成，使用5.x版本的就可以生成。即本博文中的5.0.5. 3.有的人可能会问为什么mapper文件夹会跑到resources目录下。实际上，这个逆向工程生成文件的位置是可以任意的，只要把生成的文件复制到自己的项目下就可以了。我为了后续的开发，把xnl,文件同一放在resource下，但我又懒得改路径，所以直接剪切mapper文件夹到resources目录下了。 联系如果需要联系作者，请在主页点击右下角的微信图标，或者通过以下方式: Github@codinglembre Zhihu@codinglembre Blog@codinglembre -]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Markdown语法]]></title>
    <url>%2F2018%2F05%2F27%2F%E5%B8%B8%E7%94%A8Markdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[其实这周挺忙的，各种考试，实验，作业统统集中到一起（内心os:麻木到习以为常了QAQ），但是还是抽空搭建了自己的个人博客网站，第一篇博文也不知道该写什么好，就把昨天自学的Markdown语法写下来了。 关于Markdown，你需要了解的概念Markdown 是一种可以使用 普通文本编辑器编写的轻量级 标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的 语法很简单。常用的标记符号不超过十个。让我们开始学习MarkDown语法吧！ Markdown语法因为MarkDown并不是我的学习方向，我学Markdown只是为了更好的写博文。因此，对于实现的效果相同的语法，我只列出最容易记的那种。若需要系统的学习MarkDown语法，请百度官方文档或者打开点击打开链接链接。 1.段落，标题和区块代码①段落: 一个以上的空行则会划分出不同的段落,一般的段落不需要用空白或换行缩进。(标题和正文之间会自动添加阴影线以及段落) ②标题: 推荐使用ATX形式。即在行首插入1到六个#，对应到标题的1到六阶。 ③区块代码: 区块引用则使用 email 形式的 ‘&gt;’ 角括号。 2.强调 可以在需要强调的位置前后加 两个星号 来标记需要强调的区段。 3.列表(共有两种形式)①无序列表:使用星号， 加号，减号来进行标记,例如 +Candy. +Gum. 效果： Candy. Gum. ②有序列表:使用一般的数字接着一个英文句点,例如 Red Green 效果: Red Green 4.链接(不区分大小写，共有两种形式) ①行内形式: []里写 链接文字，()里写 链接地址, 此外还可以为链接指定title属性，title属性可加可不加 ②参考形式:文中的写法 [链接文字]接上[链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 5图片(类似于链接，分为两种形式) ①行内形式： ![图片Alt]接上(图片地址 “图片Title”) ②参考形式:在文档要插入图片的地方写 ![图片Alt]接上[标记],在文档的最后写上[标记]:图片地址 “Title” 6代码和代码段 ①段落文字中存在代码区段，可以用 反引号 在代码区段左右加一个 `来标记代码区段 ②代码区块已经被格式化,可以使用 tab或者空四个格 ③代码段可以使用 ‘’’代码段’’’ 来实现 需要注意的地方 在设置标题时，#后面务必加上个空格，否则会导致标题效果渲染失败 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>
