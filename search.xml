<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用查找算法]]></title>
    <url>%2F2018%2F10%2F12%2F%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[关于查找查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法，说是七种，其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法 查找算法分类： 1.静态查找和动态查找； 静态或者动态都是针对查找表而言的，如本篇要介绍的顺序查找、二分查找、分块查找。 动态表指查找表中有删除和插入操作的表,如本篇要介绍的树表查找(二叉树查找、平衡查找树之2-3查找树、平衡查找树之红黑树、B树和B+树查找)、哈希表查找。 无序查找和有序查找。 无序查找：被查找数列有序无序均可； 有序查找：被查找数列必须为有序数列。顺序查找顺序查找实现思路(O(n))顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。 复杂度分析：查找成功时的平均查找长度为:(假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;当查找不成功时，需要n+1次比较，时间复杂度为O(n);所以，顺序查找的时间复杂度为O(n)。Demo: /**顺序查找平均时间复杂度 O（n） * @param searchKey 要查找的值 * @param array 数组（从这个数组中查找） * @return 查找结果（数组的下标位置） */ public static int orderSearch(int searchKey,int[] array){ if(array==null||array.length&lt;1) return -1; for(int i=0;i&lt;array.length;i++){ if(array[i]==searchKey){ return i; } } return -1; } 其实说白了就是遍历数组 二分查找实现思路(log2n)也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。 复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)； 需要注意：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。Demo: /** * 二分查找又称折半查找，它是一种效率较高的查找方法。 [二分查找要求] ：1.必须采用顺序存储结构 2.必须按关键字大小有序排列。 * * @param array * 有序数组 * * @param searchKey * 查找元素 * * @return searchKey的数组下标，没找到返回-1 */ public static int binarySearch(int[] array, int searchKey) { int low = 0; int high = array.length - 1; while (low &lt;= high) { int middle = (low + high) / 2; if (searchKey == array[middle]) { return middle; } else if (searchKey &lt; array[middle]) { high = middle - 1; } else { low = middle + 1; } } return -1; } 重点是使用while if结构实现递归 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用排序算法]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[作为一个Java工程师，所以里面的算法都是用Java语言实现的，不过其实不管你用的是哪种语言，实现该算法的思路都是一样的，所以借鉴此篇文章的你即使用的不是Java，看完此片文章的实现思路及其实现代码后你也是可以用其他语言实现的～ 前言查找和排序算法是算法的入门知识，其经典思想可以用于很多算法当中，但万变不离其宗，只要熟悉了思想，灵活运用也不是难事。那么常用的排序算法有哪些呢？本篇文章要介绍的排序算法，按照排序的效率分有以下10种: 1.简单排序:冒泡排序、(直接)选择排序、(直接)插入排序。 2.高效排序:快速排序、堆排序、希尔排序。 3.基于分治递归思想的:归并排序。 4.线性排序:计数排序、桶排序、基数排序。 按照排序的方式又可分为: 1.插入排序:直接插入排序、希尔排序。 2.选择排序:直接选择排序、堆排序。 3.交换排序:冒泡排序、快速排序。 4.线性排序:计数排序、基数排序、桶排序;其中基数排序又叫桶排序; 5.递归排序:归并排序。 对于这些排序，我们需要掌握比较各自的优劣、各种算法的思想及其使用场景，还有要会分析算法的时间和空间复杂度，必要时要熟练写出代码。我们可以知道排序算法要么简单有效，要么是利用简单排序的特点加以改进，要么是以空间换取时间在特定情况下的高效排序。但是这些排序方法都不是固定不变的，需要结合具体的需求和场景来选择甚至组合使用，才能达到高效稳定的目的。所以有句话叫做:没有最好的排序，只有最适合的排序。 简单排序冒泡排序实现思想大体思想就是通过与相邻元素的比较和交换来把大的数交换到最后面(从小到大排序)。这个过程类似于水泡向上升一样，因此而得名。 对5,3,8,6,4这个无序序列进行冒泡排序。第一次冒泡:从前向后冒泡，5和3比较，5大所以将5和3交换，序列变成3，5，8，6，4;同理5和8比较，5比8小所以不交换;然后8和6比较，8大所以将8和6交换，序列变成3，5，6，8，4;然后8和4比较，进行8和4的交换，这样一次冒泡就完了，结果是将最大的数字8换到了最后面。对剩下的序列依次进行第二次冒泡、…、第n次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为O(n^2)。Demo: public class BubbleSort { public static void bubbleSort(int[] arr) {//将要排序的数字放入一个数组中 //判断需要排序的数组是否为空，为空则不进行排序 if(arr == null || arr.length == 0) return ; //i控制外循环即总共需要将多少个数字进行排序，j控制内循环即每次循环都会将最大的数排到右边 for(int i=0; i&lt;arr.length-1; i++) { for(int j=0; j&lt;arr.length-i-1; j++) { //如果前面的数字大于后面的数字就将前面的数字和后面的数字进行交换，直接最大的数字被排到最右侧 if(arr[j] &gt; arr[j+1]) { swap(arr, j+1, j); } } } } //交换两个数字的位置 public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } 选择排序实现思路选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最大的元素放到最右边。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序。第一次选择排序:首先要循环遍历该数组，选择整体中5以外的最小数来和5交换，遍历该数组时发现3是最小的数字，那么就会拿3和5交换，一次遍历和排序后就变成了3,5,8,6,4，实现了将最小的数字放在最前面。对剩下的序列依次进行第二次选择和交换、…、第n次选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。选择排序的时间复杂度为O(n^2)。Demo: public class SelectSort { public static void selectSort(int[] arr) { if(arr == null || arr.length == 0) return ; // int minIndex = 0; for(int i=0; i&lt;arr.length-1; i++) { //只需要比较n-1次 //将数组中的第一个数arr[i]即arr[minIndex]作为基准，遍历其后面所有的数字，只要出现比这个数小的，那么就记下这个数的下标并赋给minIndex，遍历完后若该minIndex不等于i，说明找到了最小的值，就将这个数字下标为minIndex的值与基准数字交换之。 minIndex = i; for(int j=i+1; j&lt;arr.length; j++) { //从i+1开始比较，因为minIndex默认为i了，i就没必要比了。这是在循环遍历最小数 if(arr[j] &lt; arr[minIndex]) { minIndex = j; } } if(minIndex != i) { //如果minIndex不为i，说明找到了更小的值，交换之。 swap(arr, i, minIndex); } } } public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } 重点通过设置下标 minIndex，而且如果找到了更小的minIndex，但是这个minIndex实际上和数组没什么关系，它只是我们自己设置的，因此，对数组而言还需要通过minIndex进行数组的值的交换 插入排序实现思路插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。这个原理其实和插入排序是一样的。举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置是正确的，想一下在拿到第一张牌的时候，没必要整理。然后第二张牌3要插到5前面，所以把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧。然后拿到第三张牌时8不用动，拿到第四张牌6时要插在8前面，此时8后移一位，拿到第五张牌4时，要插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。简单插入排序的时间复杂度也是O(n^2)。Demo： public class InsertSort { public static void insertSort(int[] arr) { if(arr == null || arr.length == 0) return ; //这里首先要假设第一个数位置是正确的(arr[0]是第一张牌)；因为要往后移动数字，必须要假设第一个。然后将第二个数字arr[1]比作打扑克时拿到的第二张牌 //i依旧控制需要将多少个数字进行排序(n个数字，n-1次排序，为啥？比如只有两个数字，你肯定只需要进行1次排序啊) for(int i=1; i&lt;arr.length; i++) { int j = i;//第一次循环时将第二个数字的下标赋给j int temp = arr[j]; //第一次循环时将第二个数字赋值给target(即保留待插入元素) //第一次循环时如果第二个数字小于第一个数字，就将第一个数字后移(后面的循环中即将前面的数字都后移一位) while(j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1]) { arr[j] = arr[j-1]; //然后将第二个数字插入到第一个位置 (后面的循环中即将待插入数字插入到前面空出的地方) arr[j - 1] = temp; j --;//将j － 1，继续调整 } } } } 关键是在内层循环开始之前先设置temp保存带插入的元素以及实现后移的那段代码 高效排序快速排序(不稳定,o(nlogn))快速排序一听名字就觉得很高端，在实际应用当中快速排序确实也是表现最好的排序算法。快速排序虽然高端，但其实其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是同时比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。基本思想是 1先从数列中取出一个数作为基准数 2分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边 3再对左右区间重复第二步，直到各区间只有一个数 概括来说为 挖坑填数+分治法下面是另一种思路:举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。第一次排序:用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。首先设置i,j两个指针分别指向两端(即i指向5，j指向4)，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。 上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。 快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。Demo： public class QuickSort { //一次划分 public static int partition(int[] arr, int left, int right) { int pivotKey = arr[left]; int pivotPointer = left; while(left &lt; right) { while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey) right --; while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey) left ++; swap(arr, left, right); //把大的交换到右边，把小的交换到左边。 } swap(arr, pivotPointer, left); //最后把pivot交换到中间 return left; } public static void quickSort(int[] arr, int left, int right) { if(left &gt;= right) return ; int pivotPos = partition(arr, left, right); //通过上面的partition方法，一次排序后就出现:中间右边的数都比中间的基准数要大、中间左边的数都比中间的基准数要小得规律。这样接下来分两次排序:将中间左边的数进行快速排序、将中间右边的数进行快速排序即可。 quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right); } public static void sort(int[] arr) { if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1); } //交换的是left、right下标对应的数组元素，而不是交换的left和right的值 public static void swap(int[] arr, int left, int right) { int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; } } 其实上面的代码还可以再优化，上面代码中基准数已经在pivotKey中保存了，所以不需要每次交换都设置一个temp变量，在交换左右指针的时候只需要先后覆盖就可以了。这样既能减少空间的使用还能降低赋值运算的次数。优化代码如下: public class QuickSort { /** * 划分 * @param arr * @param left * @param right * @return */ public static int partition(int[] arr, int left, int right) { int pivotKey = arr[left]; while(left &lt; right) { while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey) right --; arr[left] = arr[right]; //把小的移动到左边 while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey) left ++; arr[right] = arr[left]; //把大的移动到右边 } arr[left] = pivotKey; //最后把pivot赋值到中间 return left; } /** * 递归划分子序列 * @param arr * @param left * @param right */ public static void quickSort(int[] arr, int left, int right) { if(left &gt;= right) return ; int pivotPos = partition(arr, left, right); quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right); } public static void sort(int[] arr) { if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1); } } 总结快速排序的思想：冒泡+二分+递归分治，慢慢体会吧。个人总结：快速排序和前面三种简单排序不同，前面三种排序基本上只需要一个方法或者说一个”大步骤”即可以完成，而快速排序需要两大步骤才能完成，这很好地体现了面向过程编程的思想。 注意代码中的下标，通过下标完成大小数交换，注意这种思想是对图片的一种优化表达。当结束white循环（里面有两个子循环的）后，即可得到基准数左边的数小于基准数而基准数右边的数大于基准数（ swap(arr, left, right);）。而 swap(arr, pivotPointer, left);则是交换基准数的位置（即定向一个新的指针指向！！） 上面根据基准数划分之后，左区间的right指针即为partition()方法得到的新指针left-1，而右区间的left指针也是为partition()方法得到的新指针left+1。这就能理解左递归quickSort(arr, left, pivotPos-1);和右递归quickSort(arr, pivotPos+1, right); 通过理解上面的内容之后，本博文中的例子代码操作对应的结果如下1.while(while1 while2 ) 5(left) 3 8 6 4(right) 5 3 8(left) 6 4(right) 5 3 4(left) 6 8(right)=swap(arr, left, right) 3 4 5 6 8= swap(arr, pivotPointer, left) 堆排序实现思路(不稳定,O(nlogn))堆排序是借助堆（一种数据结构，即完全二叉树，每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。用公式表示就是大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2] ）来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。 基本思想:将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了 具体步骤: 将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆; 将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。 首先，实现堆排序需要解决两个问题： 如何由一个无序序列键成一个堆？ 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？ 第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。 第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子：49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下图,这是一个小顶堆:大顶堆Demo： public class HeapSort { /** * 堆筛选，除了start之外，start~end均满足大顶堆的定义。 * 调整之后start~end称为一个大顶堆。 * @param arr 待调整数组 * @param start 起始指针 * @param end 结束指针 */ public static void heapAdjust(int[] arr, int start, int end) { int temp = arr[start]; for(int i=2*start+1; i&lt;=end; i*=2) { //左右孩子的节点分别为2*i,2*i+1 //选择出左右孩子较大的下标 if(i &lt; end &amp;&amp; arr[i] &lt; arr[i+1]) { swap(arr, i, i+1); } if(temp &gt;= arr[i]) { break; //已经为大顶堆，=保持稳定性。 } arr[start] = arr[i]; //将子节点上移 start = i; //下一轮筛选 } arr[start] = temp; //插入正确的位置 } public static void heapSort(int[] arr) { if(arr == null || arr.length == 0) return ; //建立大顶堆,从第一个非叶子结点从下至上，从右至左调整结构 for(int i=arr.length/2; i&gt;=0; i--) { heapAdjust(arr, i, arr.length-1); } for(int i=arr.length-1; i&gt;=0; i--) { swap(arr, 0, i);将堆顶元素与末尾元素进行交换 heapAdjust(arr, 0, i-1);//重新对堆进行调整 } } public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } 本算法重点在于理解建立初始大顶堆堆的过程:从下往上，从右到左（对于内部的顶堆来说是从左往右）以及交换堆顶元素，然后输出第一个数，并调整建立新堆的过程具体过程: 构造初始堆是对所有的非叶节点都进行调整。:从最后一个非叶子结点开始每次调整都是从父节点、左孩子节点、右孩子节点三者中选择最大者跟父节点进行交换(交换之后可能造成被交换的孩子节点不满足堆的性质，因此每次交换之后要重新对被交换的孩子节点进行调整)。这就是heapAdjust中for循环存在的意义 调整堆:堆顶元素交换到序列尾部 （swap(arr, 0, i)）那么此时位于堆顶的元素不满堆的性质，则需调整继续调整。 希尔排序实现思路希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。 希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到O(n^1.3)。Demo： public class ShellSort { //排序 public static void shellSort(int[] arr) { if(arr == null || arr.length == 0) return ; int d = arr.length / 2; while(d &gt;= 1) { shellInsert(arr, d); //调用下面的插入方法 d /= 2; } } /** * 希尔排序的一趟插入 * @param arr 待排数组 * @param d 增量 */ public static void shellInsert(int[] arr, int d) { for(int i=d; i&lt;arr.length; i++) { int j = i - d; int temp = arr[i]; //记录要插入的数据 while (j&gt;=0 &amp;&amp; arr[j]&gt;temp) { //从后向前，找到比其小的数的位置 arr[j+d] = arr[j]; //向后挪动 arr[j] = temp; j -= d; } } } } 基本步骤: 设置增量，实现分组并对每个分组进行组内排序 分组排序完后，当增量等于1时，实际上隐式地完成了整个数组的排序 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记之单表查询与多表查询]]></title>
    <url>%2F2018%2F10%2F09%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[解决中文乱码问题1.查看MySQL数据库编码:在命令行中输入SHOW VARIABLES LIKE ‘CHAR%’; 回车可看到如下内容:2.编码解释: character_set_client: mysql使用该编码来解读客户端发送过来的数据，例如该编码为utf，那么如果客户端发送过来的数据不是utf，就会出现乱码。 character_set_results：mysql会把数据转换成该编码后，再发送给客户端，例如该编码为utf，那么如果客户端不使用utf来解读，那么就会出现乱码，其它编码只要支持中文即可 除了这两个编码格式外我们还需要考虑一个工具(用于编写sql语句的工具)的编码格式，即控制台(用命令行写sql语句)或者用于写sql语句的可视化工具，为什么要用”或”呢，因为二者就是一体，修改一个即一起修改了两个的编码格式。下面1.3节我在分析乱码原因后会告诉你如何保持client、results以及控制台与可视化工具这四者编码格式的一致，以解决中文乱码问题。3.控制台乱码问题windows系统中: 插入或修改时出现乱码：因为控制台默认使用gbk，而character_set_client不是gbk的原因。 查询出的数据为乱码，因为character_set_results不是gbk而控制台默认使用gbk。 解决方法:通过在命令行中输入代码set character_set_client=gbk;和set character_set_results=gbk;来设置编码。 通过将client和results的编码格式改成gbk后使得它们二者和控制台的编码格式一致，这样便可以实现中文乱码问题解决了编码的问题。 注意：通过上述方式我们将client、results、控制台这三者编码方式设置一致，设置编码只对当前连接有效，当退出mysql后再次登陆mysql时又回到utf了。解决方法:找到my.ini配置文件，在配置文件中设置set default_character=gbk即可。 备份数据库与恢复数据库1.备份数据库备份就是将数据库导出为sql脚本。在命令行中输入:mysqldump -u用户名 -p密码 数据库名&gt;导出文件路径 注意:1.末尾不要打分号。2.执行此语句前应该先退出mysql客户端。3.导出的内容不包括创建数据库的语句只包含数据库里面的内容。 2.恢复数据库就是将导出的sql脚本插入到数据库中。有如下两种实现方式: 第一种方式:1.登录mysql:mysql -u用户名 -p密码。2.创建数据库:create database 数据库名。3.输入命令:mysql -uroot -p密码 数据库名&lt;备份的数据路径并回车 第二种方式:1.删除数据库:drop database 数据库名。2.重新创建数据库:create database 数据库名。3.切换到数据库:use 数据库名。4.输入命令:source sql脚本路径并回车。 约束约束是添加在列上用来约束列的。1.主键约束(primary key)特点:1.非空。2.唯一。3.可被引用。当表的某一列被指定为主键后，该列的值就不能为空，也不能有重复值出现。 创建表时指定主键的两种方式: 1.create table emp( empno int primary key, ename varchar(50) ); 2.create table emp( empno int, ename varchar(50), primary key(empno) ); 修改表时指定主键的方式: alter table emp add primary key(empno); 修改表时删除主键的方式: alter table emp drop primary key; 2.主键自增长(auto_increment) create table student( id int primary key auto_increment, name varchar(50) );注意:auto_increment必须添加在int类型后，指定主键自增长后，插入数据时便可以给该主键设置null值。限制:主键自增长在群集环境下不好使，所以大部分情况下我们使用UUID来作主键。3.非空约束(not null)因为某些列不能设置为null值，所以可以对列添加非空约束。 create table student( id int primary key auto_increment, name varchar(50) not null );4.唯一约束(unique)数据库中某些列不能设置重复的值，所以可以对列添加唯一约束。 create table student( id int primary key auto_increment, name varchar(50) not null unique );5.概念模型 在java中表现为对象模型：在java中是domain。例如：User、Student。 在数据库中表现为关系模型：在数据库中表现为表。 当我们要完成一个软件系统时，需要把系统中的实体抽取出来，形成概念模型。例如部门、员工都是系统中的实体。概念模型中的实体最终会成为java中的类、数据库中的表。实体之间还存在着关系，关系有三种: 1对多:例如员工和部门的关系 1对1:例如老公和老婆的关系 多对1:例如老师与学生的关系 对象模型：可以双向关联，而且引用的是对象，而不是一个主键。关系模型：只能多方引用一方，而且引用的是主键，而不是一整行记录。 6.外键约束 1.外键必须是另一表(或自己表)的主键的值(即外键要引用主键的值)。即外键可以是副表的主键，但是必须是主表的主键 2.外键可以为空。即在主表中添加数据后，此时在副表中可以添加sno、cno为空的数据。 3.外键可重复。(前提是这个外键不是副表的主键) 4.一张表可以有多个外键。 create table dept( deptno int primary key auto_increment, name varchar(50) ); create table emp( empno int primary key auto_increment, name varchar(50), dno int, constraint fk_emp_dept foreign key(dno) references dept (deptno) ); 最后一行就是给emp表添加外键约束，添加外键约束后，在emp表中对dno列进行赋值时就应该考虑外键约束的三个条件了。(上图创建的两张表演示的也是数据库中1对多的关系。)7.数据库中1对1的关系 create table husband ( hid int primary key auto_increment, hname varchar(50) ); insert into husband values(null,’刘备’); insert into husband values(null,’张飞’); insert into husband values(null,’关羽’); create table wife( wid int primary key auto_increment, wname varchar(50), constraint fk_wife_husband foreign key (wid) references husband(hid) ); 特点:外键引用自身表(副表)的主键。 8.数据库中多对多的关系在表中建立多对多关系需要使用中间表(关联表)，即需要三张表，在中间表中使用两个外键，分别引用其它两个表的主键。 create table student( sid int primary key auto_increment, sname varchar(50) ); create table teacher ( tid int primary key auto_increment, name varchar(50) ); create table stu_tea( sid int, tid int, constraint fk_student foreign key(sid) references student(sid), constraint fk_teacher foreign key(tid) references teacher(tid) ); insert into student values(null,’刘德华’); insert into student values(null,’梁朝伟); insert into student values(null,’黄日华’); insert into student values(null,’苗侨伟’); insert into student values(null,’汤镇业’); insert into teacher values(null,’崔老师’); insert into teacher values(null,’刘老师’); insert into teacher values(null,’石老师’); insert into stu_tea values(1,1); insert into stu_tea values(2,1); insert into stu_tea values(3,1); insert into stu_tea values(4,1); insert into stu_tea values(5,1); insert into stu_tea values(1,2); insert into stu_tea values(2,2); insert into stu_tea values(3,2); insert into stu_tea values(3,3); insert into stu_tea values(4,3); insert into stu_tea values(5,3); select * from stu_tea; 多表查询1.分类 合并结果集(了解) 连接查询 子查询 2.合并结果集要求两个结果集(注意这里强调的是结果集，而不是两张表)的列数、列类型完全相同。关键字union:去除重复行;关键字union all:不去除重复行。 create table ab( a int, b,varchar(50) ); insert into ab values(1,’1’); insert into ab values(2,’2’); insert into ab values(3,’3’); create table cd( c int, d varchar(50) ); insert into cd values (3,’3’); insert into cd values (5,’5’); insert into cd values (5,’5’); 合并操作为: select * from ab union (all) select * from cd; 3.连接查询 内连接 外连接 外连接又包括左外连接、右外连接、全外连接(mysql不支持这个) 3.1内连接 方言语法:select from 表1 别名1，表2 别名2 where 别名1.xx＝别名2.xx;例如:select from emp,dept where emp.deptno=dept.deptno;去除无用行后的笛卡尔积，where后的条件是主外键。 标准语法:select from 表1 别名1 inner join 表2 别名2，on 别名1.xx＝别名2.xx;例如::select from emp inner join dept on emp.deptno=dept.deptno; 就是把方言版的逗号改为inner join ，把where改为on了。 自然连接语法:select * from 表1 别名1 natural join 表2 别名2;自然连接特有的特点就是它能够自己找到两个表中相同的列 即自己填全where条件。 总结:内连接的特点:内连接查询出的所有记录都是满足条件的记录，不满足条件的记录不显示出来。 3.2外连接特点:外连接有一主一次。 左外连接左表为主，那么左表中所有的记录无论满足不满足条件，都打印出来。不满足条件的值用null填补。语法为:select * from emp left outer join dept on emp.deptno=dept.deptno; 右外连接右表为主，那么右表中所有的记录无论满足不满足条件，都打印出来。不满足条件的值用null填补。语法为::select * from amp right outer join dept on emp.deptno=dept.deptno; 全外连接：左右表都为主，左表和右表中的记录都要打印出来，不满足条件的值用null填补。使用union将左外连接和右外连接的结果集合并起来就是全外连接。 4.子查询子查询通俗来讲，就是查询中有查询。Demo: /*查询本公司工资最高的员工的详细信息*/ select * from amp where sal=max(sal); 此种写法错误，因为where条件中不能有聚合函数。所以想到要用子查询。思路:首先查出最高工资:select max(sal) from amp;然后查询该工资的员工:select from amp where sal=刚刚的查询结果。所以合并起来为：select from amp where sal=(select max(sal) from amp); 4.1子查询能出现的位置 where后作为条件(上述例子) from后作为二次查询(下面例子) select e.empno,e.ename from (select * from amp where deptno=30) as e where 条件; 4.2子查询的结果集 单行单列:select * from 表1 where 列1 [=、&gt;、&lt;、&gt;=、&lt;=、!=] （select 列 from 表2 where 条件); 多行单列::select * from 表1 where 列1 [=、&gt;、&lt;、&gt;=、&lt;=、!=] ［any、all、in］（select 列 from 表2 where 条件; 单行多列:select * from 表1 where （列1，列2） in (select 列1，列2 from 表2 where 条件); 多行多列:该结果集用在from后作为二次查询。select * from 表1,(select …) 别名 where 条件; 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习之Java中的集合框架与泛型]]></title>
    <url>%2F2018%2F10%2F08%2FJava%E5%AD%A6%E4%B9%A0%E4%B9%8BJava%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[集合类的概念和作用Java中的集合类:是一种工具类，就像容器，储存任意数量具有共同属性的对象。它在Java中有以下作用: 在类的内部，对数据进行组织 简单而快速搜索大数量的条目 有的集合接口提供了一系列排列有序的元素，并且可以在序列中间快速的插入或者删除有关元素。 有的集合接口提供了映射关系，可以通过关键字key去快速查找到对应的唯一对象，而这个关键字可以是任意类型。 注意:对象存入集合中都变成Object类型，取出时需要类型转换 与数组的对比 数组的长度固定，集合长度可变 数组只能通过下标访问元素，类型固定，而有的集合可以通过任意类型查找所映射的具体对象。 Java集合框架体系结构 Collection与Map是两个根接口。 Collection接口：内部存储的是一个个独立的对象。包含： List接口：序列，存储元素排列有序且可重复。实现类:ArrayList，数组序列。实现类：LinkedList，链表，保存的是一个个独立的对象。 Queue接口：队列，存储元素排列有序且可重复。实现类：LinkedList，链表。 Set接口：集，存储元素无序且不可重复。实现类：HashSet，哈希集，保留的是对象的引用。 Map接口:提供了一种映射关系，里面放的是Entry类型的对象实例。其中的元素是以键值对（key-value）的形式存储的，能够实现根据key快速查找value HashMap实现类 List常用API的使用1.添加单个元素: 第一种 add 方法：是向 List 中插入一条元素 例如：cosTo.add( s1 ); —-插入的元素。 第二种 add 方法：是向 List 指定位置插入一条元素 例如：cosTo.add( 2 , s2 ); —-位置 ，插入的元素。 第二种方法插入的位置不可越界，虽然可以指定位置，但不可超出现有的长度。List 长度起始位置是从0开始。 2.添加list元素 addAll(List list) 就是将一个List里面的元素一股脑的全都加进去。一般定义一个数组，调用方法Arrays.asList(Object[] obs);可以将一个数组转换为一个List，然后可以将这个元素传进addAll()里面，当然还有addAll（index,List list）方法 3.遍历list中的元素 普通for循环 public void testGet(){ int size=coursesToSelect.size(); for(int i=0;i&lt;size;i++){ Course cr=(Course) coursesToSelect.get(i); System.out.println(&quot;取出的课程：&quot;+cr.getId()+&quot;:&quot;+cr.getName()); } } 迭代器，Iterator是一个接口,依赖于集合存在的 Iterator it=courseToSelect.iterator(); while(it.hasNext()){ Course cr=(Course) it.next(); System.out.println(&quot;课程:&quot; + cr.id + &quot;:&quot; + cr.name); } for each(增强for循环)，数组和继承了Iterable接口的类所生成的对象都可以用for/each循环 for(Object obj:coursesToSelect){//遍历集合中的每一个元素，作为每一个Object变量 Course cr=(Course) obj; System.out.println(&quot;课程:&quot; + cr.id + &quot;:&quot; + cr.name); } 4.修改List的元素 public void testModify(){ coursesToSelect.set(4,new Course(&quot;7&quot;,&quot;毛概&quot;)); } 5.删除list中的元素List中有remove(index),remove(对象值)和removeAll(Arrays.asList(对象数组名))方法来删除容器中元素的值(用法和add类似)。 第二种方法删除的位置不可越界，虽然可以指定位置，但不可超出现有的长度。List 长度起始位置是从0开始。 Set常用API的使用和List类似。 注意:Set集合是无序的，所以每次遍历的结果都是不一样的，并且它没有get()方法，只能用foreach和iteratorSet中，添加某个对象昂，无论添加多少次，最终只会保留一个该对象的引用，并且，保留的是第一次添加的那一个。 Map常用API的使用Map增删改查： 增：map的put(key,value)方法添加。 查：1.利用keyset()方法获得Map中key的集合，再遍历这个Set的集合，利用Map的get(key)方法得到key对应的value值。利用EntrySet方法获取May中Entry对象集：然后用foreach遍历集，再用Entry集的getkey()和getvalue()方法得到每一个key值和value值。 删：remove(object key) 改：put(原有的key,新的value) 通过entrySet可以返回Map中的所有键值对 Set&lt;Entry&lt;String,Student&gt;&gt;entrySet = students.entrySet(); 注意:Map支持泛型，Map&lt;K,V&gt;跟Collection中添加的元素的方式不同，Map使用put()添加一个映射。Map接口提供了分别返回key值集合、value值集合以及Entry（键值对）集合的方法Key是不可以重复的，Value是可以重复的。Key-value都可以为null，不过只能有一个key是null。当这个key为null说明它不指向任何对象 集合与泛型泛型&lt;&gt;;规定List定义的容器只能存储某种类型的元素。不用泛型的话是什么类型的元素都可以插入，因为插入集合是忽略其类型，把它看成为Object类型，取出时需要强行转换对应的类型。 如果使用了泛型但是还是添加奇怪的对象比如一个字符串进去，则在编译时便会报错。list不能直接添加基本类型（int,float等）的对象，如果要添加，需要使用其包装类list可以添加子类型的对象 集合框架高级1.关于List的contains()方法的具体实现主动遍历List中的每一个元素，并使用Objet类的equals方法，和传进来的引用依次做比较，一旦发现传进来的对象和某个元素指向的是同一块内存那么就返回true。但是这里有一个问题，就是比较的是引用，那么如果想要比较对象的”值”呢？，那么需要重写eauals()方法。 public void equals (Object obj) { if(this == obj) // 指向同一个内存快 必然是相同的 return true; //为什么contains(course2) 返回的是false 原因就在在这里 只是比较了一下 引用的值是否相同 没有进一步的比较 内存块中的值 下就是对这里记性了改写 if (obj == null) // 如果obj为空 就直接没有戏了 return false; if(! (obj instanceof Course)) //如果两者的不属于同一类型则 也直接没戏了 return false; //经过以上的这么多的比较 终于可以判断二者的值是不是相同了 //首相要把objet型的obj转成 Course Course course = (Course) obj； if( this.name == null ) ｛ if(course.name == null ) return true; else return false; } else { if(this.name.equals(course.name)) return true; else return false; ) //如果还有别的属性接着写 } 2.关于Set的contain方法的具体实现Set.contains(E e)的时候，先调用从Object继承而来的hashCode方法，然后在调用equals()方法，连个方法都返回真的时候，才认定Set包含某个元素。 总结:list 与 set 中contain()方法调用机制： list 中的contain()方法是拿到list中的每个对象来调用Object类中的equals()方法 Set 中的contain()方法是拿到list中的每个元素来先调用hashcode()方法来返回哈希码值，当哈希码的值相等时，再调用equals()方法，当比较的元素此时也相同时，才会返回true。因此调用Set中的contain()方法时，需要对hashcode()方法及equals()方法进行重写。 3.关于List中的indexOf()方法与lastIndexOf()方法的实现机制indexOf()方法与lastIndexOf()方法实现原理： 1、遍历调用每个元素的equals()方法，如果返回true则将次元素的索引返回； 2、如果有多个相同元素，则只返回第一个元素的索引； 3、lastIndexOf()方法则从最后一个元素开始遍历；4.Map中通过containsKey()方法和containsValue()方法来判断键和值是否存在 Map 中对对象进行了 Key 标记，通过 get（Key）可以取得对应的对象 Map 的containsValue（）方法的参数是 Object 对象，因为Map 的 Value 值是对象元素 Map 的containsKey（）方法取得 Map 映射的 Key 值 List中的contains()方法借Map中的containsValue()方法调用equals()方法来进行比较。所以要重写Hashcode和equals方法 5.工具类Arrays类和Collection类工具类Arrays类用于操作数组，工具类Collection类用于操作集合 对Integer类型的集合排序 对String类型的集合排序 collection.sort（）方法对元素进行排序，列表中的元素都必需实现 Comparable 接口，否则不能使用 sort（）方法排序 ，实现该接口表示：这个类的实例可以比较大小，可以进行自然排序注意，这个是先拍数字，再大写字母，再小写字母 拓展: Java集合框架的成员:compareable(默认带有泛型的) 是默认比较规则， 实现comparator接口，且必须实现compareTo()方法 comparaTo()方法返回正数表示大，负数表示小，0表示相等。comparator是临时比较规则,比如，学生类实现了默认比较接口compareable，默认年龄比较，突然想按照身高拍，那么要实现comparator接口，且必须实现compare()方法 compara()方法返回正数表示大，负数表示小，0表示相等 总结:让没有默认比较规则的类进行比较的方法 一、让该类实现Comparable接口： 1、在该类中加上implements Comparable&lt;类名&gt;。 2、实现.compareTo(类名 对象名)方法，若this较大则返回正值，若相等则返回0，若this较小则返回负值。（各种类都包含.compareTo()方法） 3、调用Collections.sort（对象名）进行排序。 二、让该类实Comparator接口： 1、新建一个类加上implements Comparator&lt;类名&gt; 2、实现.compare(类名 对象名1，类名，对象名2)方法，若this较大则返回正值，若相等则返回0，若this较小则返回负值。 3、调用Collections.sort（对象名，实现Comparator&lt;类名&gt;接口的对象名）方法。（因此要重建一个类来实现Comparator接口！！） 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习之阅读Java编程思想]]></title>
    <url>%2F2018%2F10%2F04%2FJava%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%98%85%E8%AF%BBJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[对象导论 程序可以通过添加新类型的对象使得自身使用于某个特定的问题。 可以通过构建包含现有对象的方式来创建新的对象。以此在程序中构建复杂的体系，同时将其复杂性隐藏在对象简单性的背后 某一特定类型的所有对象可以接受同样的消息，这种可替代性是OOP中最强有力的概念 每一个对象都能和其他对象区分开来，具体说来，在内存中有一个唯一地址。 程序通过定义类来适应问题，而不再使用现有的表示机器中存储单元的数据类型。 将对象看做服务提供者，这个对象又需要哪些服务提供者？这是一种将问题分节为对象集合的一种合理方式，还有助于提高对象的内聚性。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习之JSP]]></title>
    <url>%2F2018%2F10%2F04%2FJavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8BJSP%2F</url>
    <content type="text"><![CDATA[JSP，即Java Server Pages，和Servlet一样，都是SUN公司定义的一种用于开发动态WEB资源的技术的标准，在服务器端执行的动态网页。JSP虽然像是在写HTML，但是JSP允许在页面中嵌套Java代码，或者利用某个标签表示Java代码（EL与jstl）。这就使得我们在写JSP时能够获取请求对象Request和响应对象Response等这样的web开发常用对象，实现与浏览器的交互。 JSP页面元素简介及page指令page指令:通常位于jsp页面的顶端，同一个页面可以有多个page指令。 JSP页面的生命周期 每个客户端对应一个线程，这种多线程的处理方式，大大地降低了系统的资源需求，提高了系统的并发性，减少了响应时间。但是使用多线程编程就要注意线程带来的同步问题。(临界资源的共享和保护等等) JSP内置域对象1.out对象:JspWriter的实例，是向客户端输出内容的常用的对象。先了解一下什么是缓冲区:内存一块用于保存临时数据的区域2.request和response对象先了解一下Get和Post的区别: get：以明文的方式通过URL提交数据，数据在URL中可以看到。提交的数据最多不超过2KB。安全性低但效率比post方式高、适合提交数据量不大，安全性不高的数据。比如：搜索、查询等功能。 post：将用户提交的信息封装在HTML、HEADER内。适合提交数据量大，安全性高的用户信息。比如：注册、修改、上传等功能。注意URL传递中文参数乱码的问题无法通过req.setCharacterEncoding解决，需要到Tomcat配置文件中设置修改tomcat中的server.xml 在端口号后，增加URIEncoding=”utf-8”;response对象虽然重要，但是实际上JSP很少用他。*特别注意:PrintWriter向客户端输出字符串对象， 而且先于jspWriter，使用out.flush()来避免 PrintWriter response.getWriter()*特别注意:对象是否保存！！ 3.session:是客户端与服务器端建立的一个会话并保存在服务器中，和用户意义对应，session对象保存在服务器端的同时服务器还会给客户端发送一个带有JSESSIONID的Cookie。它实际是一个特定的时间概念 注意在之前讲过的session中的生命周期中，原有会话还在服务器端，只是再也没有客户端会携带它然后交于服务端进行校验4.application（相当于Java中的全局变量，是ServletContext类的实例，服务器的关闭启动决定他的周期）5.page对象（指向当前JSP页面本身，相当于this,，是Object类的实例）6.pageContext和Config对象 pageContext 用于获取其他对象，功能的集大成者pageContext常用API如下:Config对象及常用API如下:7.exception对象 但是需要在page指令中写属性errorpage=“出错跳转到的页面” 2.在跳转到的错误处理页面page指令中输入属性isErrorPage=“true”** JavaBeans解决了代码重复编写，减少代码冗余，功能区分明确，提高了代码的维护性设计原则: 公有类 属性私有 无参的构造方法 setter/getter方法 JSP动作元素其实就是一个标签，可以有属性和可选内容: userBean创建JavaBeans语法 &lt;body&gt; &lt;jsp:useBean id=&quot;myUsers&quot; class=&quot;com.po.Users&quot; scope=&quot;page&quot;/&gt; 用户名:&lt;%= myUsers.getUsername()%&gt;&lt;br&gt; 密码：&lt;%= myUsers.getPassword()%&gt;&lt;br&gt; &lt;/body&gt; setProperty用法 1.根据表单自动匹配所有属性 &lt;jsp:setProperty name=&quot;myUsers&quot; property=&quot;*&quot;/&gt; 2.根据表单自动匹配部分属性 &lt;jsp:setProperty name=&quot;myUsers&quot; property=&quot;username&quot;/&gt; 3.跟表单无关，手工赋值给属性 &lt;jsp:setProperty name=&quot;myUsers&quot; property=&quot;username&quot; value=&quot;admin&quot;/&gt; 4.通过URL传参数来给属性赋值(需要在表单的action后面添加参数) &lt;jsp:setProperty name=”myUsers” property=”password” param=”myPass”/&gt; getProperty用法(代替了传统表达式和内置对象来获取用户名和密码) &lt;jsp:getProperty name=&quot;myUsers&quot; property=&quot;username&quot;/&gt; JSP四个作用域对象范围 page仅在当前页面有效，哪怕用全局对象pageContext在另一个页面也获取不到值 http协议的无状态性同一个浏览器多次发送请求给服务器，服务器并不会知道这是同一个浏览器，即无法保存用户状态。由于这个特性，提供了两大保存用户转状态的机制： session cookie: Web服务器保存在客户端的一系列文本信息。但是容易泄露用户信息 购物车 判断注册用户是否已经登录网站 注意设置完cookie后，比如遍历cookie时，当存在对应的用户cookie时，用户勾选了不记住登录状态，那么就要cookie失效，即cookie.setMaxAge(0)（马上删除这个cookie）,最后别忘记response.addCookie(cookie),否则不起作用是否保存过这个用户的cookie（如果用户勾选了不保存cookie，那么已经删除，这里就不会遍历到关于用户名和密码的cookie）解决Cookie无法保存中文字符串的问题 String username= URLEncode.encode(request.getParameter(&quot;username&quot;),&quot;utf-8&quot;) 解决Cookie无法读取中文字符串的问题 username= URLEncode.decode(c.getValue(),&quot;utf-8&quot;) session和cookie对比 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb之HTML+CSS笔记]]></title>
    <url>%2F2018%2F10%2F03%2FJavaWeb%E4%B9%8BHTML%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HTML是网页内容的载体。HTML是静态页面，浏览器就可以解析。而JSP是动态页面，需要服务器去解析。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等. CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。由于前端并不是我的主要学习方向，但是在学习到JavaWeb时会用到，但是如果不懂，那也是比较麻烦的，所以这里只做简单的学习。 html文件基本结构&lt;html&gt; &lt;head&gt;...&lt;/head&gt; &lt;body&gt;...&lt;/body&gt; &lt;/html&gt; html文件由根标签,头部标签,网页内容标签组成。 一般的标签以及语法 标题标签：&lt;h1&gt;标题&lt;/h1&gt; 段落标签：&lt;p&gt;段落&lt;/p&gt; 图片标签：&lt;img src=”1.jpg”&gt; &lt;body&gt;标签，网页上显示的内容放在这里 加入强调语气，使用&lt;strong&gt;和&lt;em&gt;标签 使用&lt;span&gt;标签为文字设置单独样式，需要与&lt;style&gt;标签配合使用 &lt;q&gt;标签，短文本引用 &lt;blockquote&gt;标签，长文本引用 为你的网页中添加一些空格:语法&amp;nbsp+; &lt;hr&gt;标签，添加水平横线 想加入一行代码吗？使用&lt;code&gt;标签 使用&lt;pre&gt;标签为你的网页加入大段代码 ul-li是没有前后顺序的信息列表。 使用ol，在网页中展示有前后顺序的信息列表 标签与标签之间是可以嵌套的，但先后顺序必须保持一致，如：&lt;div&gt;里嵌套&lt;p&gt;，那么&lt;/p&gt;必须放在&lt;/div&gt;的前面。HTML标签不区分大小写，&lt;h1&gt;和&lt;H1&gt;是一样的，但建议小写，因为大部分程序员都以小写为准。 重要标签以及属性 在网页制作过程过中，可以把一些独立的逻辑部分划分出来，放在一个div标签中，这个标签的作用就相当于一个容器 表格的四个标签：table、tbody、tr、th、td。table表格在没有添加css样式之前，在浏览器中显示是没有表格线的，th标签中的文本默认为粗体并且居中显示 用css样式，为表格加入边框 &lt;style type=”text/css”&gt; table tr td,th{border:1px solid #000;} &lt;/style&gt; caption标签，为表格添加标题和摘要,摘要summary标签的内容是不会在浏览器中显示出来的。它的作用是增加表格的可读性(语义化） &lt;table summary=”本表格记录2012年到2013年库存记录，记录包括U盘和耳机库存量”&gt; &amp;lt;caption&gt;2012年到2013年库存记录&lt;/caption&gt; &amp;lt;tr&gt; &amp;lt;th&gt;产品名称 &lt;/th&gt; &amp;lt;th&gt;品牌 &lt;/th&gt; &amp;lt;th&gt;库存量（个） &lt;/th&gt; &lt;th&gt;入库时间 &amp;lt;/tr&gt; &lt;/table&gt; 使用a标签可实现超链接，里面title属性的作用，鼠标滑过链接文字时会显示这个属性的文本内容，target=”_blank”设置超链接在新的浏览器窗口中打开。 表单标签以及属性，与用户交互所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在 标签之间（否则用户输入的信息可提交不到服务器上哦！），特别重要1.文本输入框、密码输入框语法: &lt;form&gt; &lt;input type=&quot;text/password&quot; name=&quot;名称&quot; value=&quot;文本&quot; /&gt; &lt;/form&gt; name：为文本框命名，以备后台程序ASP 、PHP引用。value：为文本输入框设置默认值。(一般起到提示作用)2.文本域，支持多行文本输入 &lt;textarea rows=&quot;行数&quot; cols=&quot;列数&quot;&gt;文本&lt;/textarea&gt; 3.使用单选框、复选框，让用户选择 &lt;input type=&quot;radio/checkbox&quot; value=&quot;值&quot; name=&quot;名称&quot; checked=&quot;checked&quot;/&gt; 4.使用下拉列表框，节省空间 &lt;select&gt; &lt;option value=&quot;看书&quot;&gt;看书&lt;/option&gt; &lt;option value=&quot;旅游&quot;selected=&quot;selected&quot;&gt;旅游&lt;/option&gt; &lt;option value=&quot;运动&quot;&gt;运动&lt;/option&gt; &lt;option value=&quot;购物&quot;&gt;购物&lt;/option&gt; &lt;/select&gt; selected=”selected”：设置selected=”selected”属性，则该选项就被默认选中5.使用下拉列表框进行多选，设置multiple=”multiple”属性，就可以实现多选功能 &lt;select multiple=&quot;multiple&quot;&gt; &lt;option value=&quot;看书&quot;&gt;看书&lt;/option&gt; &lt;option value=&quot;旅游&quot;&gt;旅游&lt;/option&gt; &lt;option value=&quot;运动&quot;&gt;运动&lt;/option&gt; &lt;option value=&quot;购物&quot;&gt;购物&lt;/option&gt; &lt;/select&gt; 6.使用提交按钮，提交数据 &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; 7.使用重置按钮，重置表单信息为初始状态 &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; 8.form表单中的label标签，标签的 for 属性中的值应当与相关控件的 id 属性值一定要相同。 &lt;form&gt; &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;male&quot; /&gt; &lt;/form&gt; CSS样式CSS可以让不同网页位置的文字有着统一的字体、字号或者颜色等。css 样式由选择符和声明组成，而声明又由属性和值组成，如下图所示： 最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号。 1.内联式css样式，直接写在现有的HTML标签中 &lt;p style=&quot;color:red&quot;&gt;这里文字是红色。&lt;/p&gt; &lt;p style=&quot;color:red;font-size:12px&quot;&gt;这里文字是红色。&lt;/p&gt; 2.嵌入式css样式，写在当前的文件中 &lt;style type=&quot;text/css&quot;&gt; span{ color:red; } &lt;/style&gt; 3.外部式css样式，写在单独的一个文件中 &lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; 1.css样式文件名称以有意义的英文字母命名，如 main.css。 2.rel=”stylesheet” type=”text/css” 是固定写法不可修改。 3.link标签位置一般写在head标签之内。 优先级:相同权值下，就近原则 CSS选择器选择器{ 样式; } 包括标签选择器，类选择器，ID选择器，子选择器，包含选择器，通用选择器类选择器和ID选择器的区别: .stress{ color:red; } .bigsize{ font-size:25px; } #stressid{ color:red; } #bigsizeid{ font-size:25px; } CSS继承，层叠和特殊性1.继承CSS的某些样式是具有继承性的，注意只是有些，比如 p{color:red;} &lt;p&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; 2.特殊性，即CSS样式矛盾有的时候我们为同一个元素设置了不同的CSS样式代码，那么元素会启用哪一个CSS样式呢?这跟权值有关 标签的权值为1，类选择符的权值为10，ID选择符的权值最高为10,继承也有权值但很低，有的文献提出它只有0.1 3.层叠，即CSS样式覆盖,规则为后面的样式会覆盖前面的样式。 语义化符合内容的结构化（内容语义化），选择合适的标签（代码语义化）4.设置最高权值,使用!important来解决。: p{color:red!important;} p{color:green;} &lt;p class=&quot;first&quot;&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; CSS排版之文字与段落####文字排版1.字体。不要设置不常用的字体，因为如果用户本地电脑上如果没有安装你设置的字体，就会显示浏览器默认的字体 body{font-family:&quot;宋体&quot;;} 2.字号、颜色。 body{font-size:12px;color:#666} 3.粗体 p span{font-weight:bold;} 4.斜体 p a{font-style:italic;} 5.下划线 p a{text-decoration:underline;} 6.删除线 .oldPrice{text-decoration:line-through;} 段落1.缩进，中文文字中的段前习惯空两个文字的空白，这个特殊的样式可以用下面代码来实现： p{text-indent:2em;} 2.行间距（行高） p{line-height:1.5em;} 3.中文字间距、字母间距(就是文字间距) h1{ letter-spacing:50px; } ... &lt;h1&gt;了不起的盖茨比&lt;/h1&gt; 4.对齐， 想为块状元素中的文本、图片设置居中样式？注意要设置宽度和高度 h1{ width:100px; height: 50px; text-align:center; } &lt;h1&gt;了不起的盖茨比&lt;/h1&gt; CSS盒模型常用的块状元素有： &lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 常用的内联元素有： &lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 常用的内联块状元素有： &lt;img&gt;、&lt;input&gt; 1.元素分类–块级元素如何将内联元素a转换为块状元素？ a{display:block;} 块状元素也可以通过代码display:inline将元素设置为内联元素。 div{ display:inline; } &lt;div&gt;我要变成内联元素&lt;/div&gt; 内联元素特点： 和其他元素都在一行上； 元素的高度、宽度及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 Deom: inline-block 元素特点： 和其他元素都在一行上； 元素的高度、宽度、行高以及顶和底边距都可设置。 CSS盒模型和布局模型1.边框 div{ border:2px solid red; } 2.单独设置上下左右边框 li{ border-bottom:1px dotted #ccc; } 3.盒模型–宽度和高度一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。 4.盒模型–填充(padding)显示在左上角不是padding的效果，而是html代码默认的就是从显示器的左上角开始显示，而整个HTML文档只有一个div元素，当然就显示在左上角了5.盒模型–边界 CSS布局模型 流动模型（Flow） 浮动模型 (Float) 层模型（Layer） 1.流动模型块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。 ，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示2.浮动模型块状元素这么霸道都是独占一行，如果现在我们想让两个块状元素并排显示3.层模型每个图层能够精确定位操作，但在网页设计领域，由于网页大小的活动性，层布局没能受到热捧1.层模型–绝对定位绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位2.层模型–相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动3.层模型–固定定位fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习之快速入门]]></title>
    <url>%2F2018%2F10%2F03%2FSpringMVC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Spring MVC框架Spring MVC介绍SpringMVC和Struts2都属于表现层的框架，它是Spring框架的一个模块，提供web层解决方案，我们可以从Spring的整体结构中看得出来: MVC在b/s系统的应用mvc是一个设计模式，在b/s系统(即浏览器和服务器端，在客户机端不用装专门的软件，只要一个浏览器即可)的应用如图:解释如下: 1.用户发起request请求至控制器(Controller),控制接收用户请求的数据，委托给模型进行处理。 2.控制器通过模型(Model)处理数据并得到处理结果，模型通常是指业务逻辑(jsp、dao、service)。 3.模型处理结果返回给控制器。 4.控制器将模型数据在视图(View)中展示，web中模型无法将数据直接在视图上显示，需要通过控制器完成。如果在C/S应用中模型是可以将数据在视图中展示的。 5.控制器将视图response响应给用户，通过视图展示给用户要的数据或处理结果。 Spring mvc架构1.架构图2.架构流程 1.用户发送请求至前端控制器DispatcherServlet 2.DispatcherServlet收到请求调用HandlerMapping处理器映射器。 3.处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 4.DispatcherServlet通过HandlerAdapter处理器适配器调用处理器 5.执行处理器(Controller，也叫后端控制器)。 6.Controller执行完成返回ModelAndView 7.HandlerAdapter将controller执行结果ModelAndView返回 8.DispatcherServlet将ModelAndView传给ViewReslover视图解析器 9.ViewReslover解析后返回具体View 10.DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。 11.DispatcherServlet响应用户 3.架构中涉及的组件说明 1.DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。由框架实现 2.HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。由框架实现 3.Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。 4.HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。 5.ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 入门程序需求实现商品列表的查询并在页面中显示。这里由于Spring mvc不涉及对数据库的操作，所以我们在程序中的数据就用静态数据生成。 第一步:前端控制器的配置在WEB-INF/web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载springmvc配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--配置文件的地址 如果不配置contextConfigLocation，默认查找的配置文件名称是classpath下的:servlet名称+&quot;-servlet.xml&quot; 即springmvc-servlet.xml--&gt; &lt;param-value&gt;springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!--可以配置/：此工程所有的请求全部由springmvc解析，此种方式可以实现RESTful方式，需要特殊处理对静态文件的解析不能由springmvc解析 可以配置*.do或者*.action,所有请求的url扩展名为.do或.action由springmvc解析，此中方法常用 不可以配置/*,如果配置/*,返回jsp也由springmvc解析，这是不对的--&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 第二步:Spring MVC配置文件在web目录下创建Spring MVC的配置文件springmvc.xml，以后需要在里面配置Spring MVC架构三大组件(处理器映射器、适配器、视图解析器)，里面根标签的内容同Spring的配置文件: &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt; &lt;/beans&gt; 第三步:配置处理器映射器因为对于用户发起的request请求，前端控制器首先会请求HandlerMapping处理器映射器来查找Handler，所以我们首先配置它，在springmvc.xml中加入如下内容: &lt;!--配置处理器映射器 springmvc框架根据HandlerMapping接口判断是否是处理器映射器--&gt; &lt;!--根据bean的name进行查找Handler,将action的url配置在bean的name中--&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; BeanNameUrlHandlerMapping:表示将定义的Bean名字作为请求的url，需要将编写的controller在spring容器中进行配置，且指定bean的name为请求的url，且必须以.action结尾。 第四步:配置处理器适配器处理器映射器将查找到的Handler返回给DispatcherServlet后，DispatcherServlet会调用适配器执行Handler，通过适配器去扩展对不同Handler的执行。所以我们再配置它,在springmvc.xml中添加如下内容: &lt;!--配置处理器适配器 springmvc框架根据HandlerAdapter接口判断是否是处理器适配器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; SimpleControllerHandlerAdapter:即简单控制器处理适配器，所有实现了org.springframework.web.servlet.mvc.Controller 接口的Bean作为Springmvc的后端控制器。 第五步:后端控制器的编写DispatcherServlet通过处理器适配器找到后端控制器Handler，所以我们需要进行Handler的编写,在src包下新建ItemController.java，内容如下: package controller; public class ItemController1 implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //使用静态的数据将商品信息显示在jsp页面 List&lt;Items&gt; itemsList = new ArrayList&lt;&gt;(); Items items_1 = new Items(); items_1.setName(&quot;联想笔记本&quot;); items_1.setPrice(6000f); items_1.setCreatetime(new Date()); items_1.setDetail(&quot;ThinkPad T430 联想笔记本电脑！&quot;); Items items_2 = new Items(); items_2.setName(&quot;苹果手机&quot;); items_2.setPrice(5000f); items_2.setDetail(&quot;iphone6苹果手机！&quot;); itemsList.add(items_1); itemsList.add(items_2); ModelAndView modelAndView=new ModelAndView(); modelAndView.addObject(&quot;itemsList&quot;,itemsList); modelAndView.setViewName(&quot;/WEB-INF/jsp/itemsList.jsp&quot;);//指定用户访问的jsp页面地址 return modelAndView; } } 数据我们采用静态数据的输入，当然我们还需要创建Items.java这个pojo对象，就是上一篇文章中我们用到的.java文件。 第六步:后端控制器的配置&lt;!--配置Handler 由于使用了BeanNameUrlHandlerMapping处理映射器，所以name要配置为url--&gt; &lt;bean name=&quot;/itemList.action&quot; class=&quot;controller.ItemController1&quot;&gt;&lt;/bean&gt; name=”/itemsList.action”:前边配置的处理器映射器为BeanNameUrlHandlerMapping，如果请求的URL为“上下文/itemsList.action”将会成功映射到ItemController1控制器。 配置视图解析器Handler执行完成后给处理器适配器返回一个ModelAndView对象，它是Spring MVC的一个对象，用于对Model和View进行封装。然后处理器适配器又将这个对象返回给DispatcherServlet,DispatcherServlet调用视图解析器进行视图解析，所以这里我们要配置视图解析器，在springmvc.xml中添加如下内容: 然后部署服务器，在浏览器中输入http://localhost:8080/SpringMvc/itemList.action后便可以看到如下页面: 扩展:对于前端控制器DispatcherServlet,我有必要多说几句，在spring-webmvc.jar包中有一个DispatcherServlet.properties文件，内容如下:里面包含一些默认的组件例如处理器映射器、处理器适配器等，当程序启动时，DispatcherServlet会自动加载DispatcherServlet.properties配置文件，从而默认加载各个组件，所以如果我们在springmvc.xml中配置了处理器映射器和处理器适配器，那程序就以springmvc.xml中的配置信息为主。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习之快速入门]]></title>
    <url>%2F2018%2F10%2F03%2FSpring%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[当客户端向服务器发出请求时，服务器把得到的请求发送给控制器Servlet，而在Servlet中需要创建Service对象来调用业务层相关功能(故说控制器层Servlet依赖于业务层Service),而在Service中又需要创建数据库层DAO对象来对数据库进行操作(故说业务层Service依赖于数据库层DAO)。 思考:针对上述过程，我们需要考虑这样几个问题。1.Servlet、Service以及Dao对象的创建时间、创建数量。2.Servlet、Service以及Dao之间的依赖关系。如何处理这些问题呢？Spring就是用来处理对象的创建、以及对象之间依赖关系的一个开发框架。它打破了我们传统开发的观念，我们不再需要像以前那样在具体的类中创建具体的对象，而是将对象的创建交给它去完成。它是我们所要学习的框架中最重要的框架，请务必好好学习。 Spring框架中的专业术语组件／框架设计- 侵入式设计:对现有类的结构有影响，即需要实现或继承某些特定类。 如Struts框架。 - **非侵入式设计:引入了框架，对现有的类结构没有影响。如Spring框架**／Hibernate框架。 控制反转Inversion On Control，简称IOC。对象的创建交给外部容器自动完成，这个就叫做控制反转。(有控制反转就有控制正转，控制正转:对象的创建由我们自己创建) 依赖注入dependency injection,简称DI，用于处理对象间的依赖关系。 二者区别:控制反转(IOC):解决对象创建的问题，(对象的创建交给别人)。依赖注入(DI):在创建完对象后，对象关系的处理就是依赖注入，(通过set方法依赖注入。) 面向切面编程AOP面向切面编程。切面，简单来说可以理解为一个类，由很多重复代码形成的类。切面举例:事务、日志、权限。 关于AOP的详细讲解我推荐你们看这篇博客:Spring AOP实现原理与应用 Spring框架概述Spring框架，可以解决对象创建以及对象之间依赖关系的一种框架。且可以和其它框架一起使用，例如spring与struts、spring和hibernate。(起到整合／粘合作用的一个框架)。spring提供了一站式解决方案:1）SpringCore:是Spring的核心功能：IOC容器，解决对象创建及依赖关系。2）SpringWeb:Spring对web模块的支持。 可以与struts整合，让struts的action创建交给spring。Spring mvc模式，用springmvc整合了就不用struts了。 3）Spring DAO:是Spring对Jdbc操作的支持。(Jdbc Template模块工具类) 4)Spring ORM:是Spring对ORM的支持。 既可以与hibernate整合(使用原始的session)也可以使用Spring对Hibernate操作的封装(对上面的session又进行了一层封装) 5）Spring AOP:关于AOP的详细讲解我推荐你们看这篇博客:Spring AOP实现原理与应用 6）SpringEE:Spring对javaEE其它模块的支持 Spring开发步骤1)导入jar包:写在前面的话:当你运行程序出现org.springframework.beans.factory.BeanDefinitionStoreException的报错信息时，不要想了，出现这种报错的信息原因绝对是因为jdk版本和你导入的spring jar包不兼容的问题。由于spring3.x与jdk1.7兼容，而spring4.x与jdk1.8兼容，所以这里提供两种解决方案:1.将jdk版本调为1.7，我用的开发工具为IDEA，它默认下的JDK使用1.8版本，所以我需要在三个地方将jdk的版本改过来(前提是你已经下载了jdk1.7版本)，修改IDEA配置中Project的jdk版本、Modules的jdk版本、SDKs的版本，如果你用到leTomcat还需要修改Tomcat配置的jdk版本。这样jdk1.7与spring3.x才兼容。2.将spring3.x.jar换成spring4.x.jar包。这种方式比较繁琐，建议大家使用第一种方式。spring4.x与jdk1.8才兼容。2)配置核心文件applicationContext.xml(文件名称随意): &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;/beans&gt; 3)使用:首先我们创建一个pojo对象User.java:然后创建测试类使用这个User对象，以前我们要使用User对象时直接像这样User user=new User();new一个对象即可:而当我们使用Spring后就应该这样使用User对象，首先在applicationContext.xml中添加标签，一个标签代表一个pojo对象:其中各个属性的说明见注释。然后我们通过如下步骤获取该pojo对象:运行测试类:说明成功获取到User对象。上述是通过工厂类获取的IOC容器创建的User对象，下面我们看看使用Spring框架获取pojo对象的第二种方式直接得到IOC容器的对象:运行程序，成功打印出user信息，说明我们通过IOC容器成功获取到user对象。 &lt;bean&gt;创建的细节对上述代码进行改进，对于IOC容器对象，我们只需创建一次即可，所以将创建IOC对象的代码改为成员变量。代码中我们通过IOC对象创建了两个User对象，运行测试类得到打印结果:发现答应的这两个User对象id都一样，说明我们获取到的是同一个对象，也说明通过标签设置的pojo对象是单例的。为什么呢？其实标签默认有一个scope=”singleton”的属性，代表该&lt;bean标签对象的pojo对象是单例的。我们可以将该属性值改为scope=”prototype”，如下:然后再运行测试类,输出如下内容:说明此时获取的两个User不再是同一个对象。 那么由IOC容器管理的pojo对象应该在何时创建呢？我们来看看，首先在User.java中添加一个无参构造器: 然后修改测试类:运行测试类:从控制台中输出内容我们可以得知:当程序运行时，IOC容器首先创建，然后当我们需要得到IOC容器中的pojo对象时我们通过语句ac.getBean(“user”);得到，此时就会在IOC中创建由它管理的pojo对象。当我们删除ac.getBean(“user”);语句时，再次运行程序，得到如下内容:这说明什么呢?说明IOC容器中没有创建pojo对象(因为一旦创建就会有”—User对象创建—“的语句输出)。综上情况，即只有当我们用到pojo对象时，IOC容器才会在自己内部创建它。此种情况为标签的属性为scope=”prototype”的结果，那么我们再来看看当属性为scope=”singleton”时的输出结果为:打印台的内容说明该User对象在程序启动时就创建在IOC容器中了，不信我们把通过IOC容器得到User对象的代码注释掉再看输出结果: 发现此时即使我们不通过ac.getBean(“user”);语句得到User对象，它也在程序启动时就创建了。 总结:在标签中设置bean对象为单例时，该对象在系统启动时就会创建；设置为多例时，该对象在我们需要使用时才创建。 标签中的其它属性说明 1.lazy-init:延迟初始化bean对象，默认值为false，即不延迟创建bean对象，在程序启动时就在IOC中创建bean对象；若其值为true则延迟创建bean对象，即在我们需要对象时才在IOC容器中创建该对象。此属性只对单例bean对象有效。 2.init-method:可以给该属性传递一个在pojo对象中创建的方法例如A方法的方法名A作为init-method的属性值，表示当该pojo对象在IOC容器中被创建后就立刻执行这个A方法。 3.destoy-method:同上，给该属性传递一个在pojo对象中创建的方法例如B方法的方法名B作为destoy-method的属性值，表示当IOC容器被销毁时(该pojo对象也会在IOC中销毁)会立刻调用这个B方法。当然我们通过ApplicationContext ac=new ClassPathXmlApplicationContext(“applicationContext.xml”);创建的IOC对象ac是没有destoy()方法的，我们需要这个创建IOC对象ClassPathXmlApplicationContext ac=new ClassPathXmlApplicationContext(“applicationContext.xml”);这样创建出来的IOC对象才有destoy()方法。 Spring IOC容器Spring IOC容器，是Spring的核心内容，用于创建对象和处理对象间的依赖关系。 对象的创建利用IOC容器创建对象的方式有如下几种:1.调用无参数构造器。2.调用带参数构造器。3.工厂创建对象。包括工厂类的静态方法创建对象和工厂类的非静态方法创建对象4.反射。(IOC的原理就是通过反射来创建对象)1.调用无参数构造器,在配置文件中加入如下内容:2.调用带参数构造器 标签中还有一个ref的属性，属性值代表引用配置文件(即IOC容器)中的相应对象。 故还可以采用这种方法调用带参数构造器创建对象:3.用工厂创建对象首先创建一个工厂类:调用工厂的实例方法创建对象:调用工厂静态方法创建对象: 处理对象的依赖关系在IOC容器的配置文件中我们有如下给对象注入属性的方法:1.通过构造方法。2.通过set方法给属性注入值。3.p名称空间。4.自动装配。5.注解。 1.通过构造方法首先我们来看看如何通过构造方法来给对象的属性赋值,在配置文件中添加如下标签即可通过构造器给该User对象的属性赋值: 2.通过set方法给属性注入值。通过set方法给属性赋值,前提是在User对象中给它的属性添加了set方法:接下来我们看个案例，以前我们开发时根据MVC模式都会像下面这样建立相应的Service.java、Servlet.java和dao.java:都需要我们自己在.java文件中添加A a=new A();来创建其所需要的依赖对象，而现在我们就将对象的创建交给IOC了，选择set给属性赋值的方式来给它们注入其所需依赖对象，修改它们的代码:然后我们需要在application.xml中进行配置:ref的属性值代表给该对象注入它所依赖的对象，即我们上述讲到的依赖注入(dependency injection),通过上述步骤我们便完成了将对象的创建交给IOC的操作。 上述三个对象的创建我们需要写三个标签才能完成，接下来我将介绍第二种方法通过内部bean的操作一次性完成它们的创建以及它们之间的依赖关系，修改配置文件中的内容:通过上述内部标签的方式我们便可实现和set注入依赖相同的效果。我们来看看它们两者的相同和区别: 相同:都可以创建Service对象，并处理了之间的依赖关系。 区别:set注入创建的Service对象可以给另一个Servlet对象调用，而内部bean将Service对象写在Servlet内部导致该Service对象只能被该Servlet使用，所以内部bean标签的使用场景在只需要一个Servlet对象的项目中。3.通过p名称空间给对象的属性注入值此中方法只有在Spring3.0版本及以上版本才能用。首先在配置文件的根标签中加入属性:xmlns:p=”http://www.springframework.org/schema/p&quot;。然后我们便可以在配置文件中这样给对象的属性赋值:当我们在配置文件中输入p:时，会出现两个属性1.p:userDao 和p:userDao-ref,这里有必要说明一下二者区别: p:userDao:代表直接给UserService对象的userDao属性赋值 p:userDao-ref:代表引用的userDao对象 例如使用p名称空间给传统的对象属性赋值时我们这样写: &lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot; p:id=&quot;xxx&quot;/&gt; &lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot; p:name=&quot;xxx&quot;/&gt; 4.通过自动装配当我们在配置文件中用标签指明相应对象的同时就将这个对象放入到了IOC容器中(其中标签中的id属性唯一指示一个对象)，当我们给该bean标签添加了autowrite=”byName”的属性后，对于该标签对应的对象注入的属性，会去IOC容器中自动查找与属性同名的对象。例如如下代码:通过上述三个标签我们就将userDao、userService、userServlet三个对象添加到了IOC容器中。我们在UserService对象的bean标签中加上了autowrite=”byName”的属性，这样我们查看UserService.java的代码，它有一个UserDao对象名为userDao的属性，此时就会自动去IOC容器中寻找与userDao同名的对象(即在bean标签中寻找id为userDao的对象)，然后进行注入，此时我们若将的id=”userDao”属性值改为userDao1或者其它名字，则运行系统会出现空指针异常，道理上述已分析。UserServlet注入userService的属性道理同此。 我们也可以将该属性定义到全局标签中，设置default-autowrite=”byName”的属性,这样就不用每个bean标签中都写上autowrite=”byName”属性了。 上述是根据名称自动装配，其实autowrite的属性值还可以为byType即根据类型自动装配。对于，当添加了autowrity=”byType”的属性后，此时寻找它依赖的属性userDao的过程如下:查看UserService.java代码，它需要注入的属性类型为UserDao类型，所以就会自动去IOC容器中查找UserDao类型的对象并自动为UserService对象注入该属性，此时各bean标签的id属性值便可以随便写了如果根据类型自动装配，则要保证保证该类型的对象只有一个，否则会报错。该属性同样可以在全局beans标签中进行配置。 利用自动装配的优缺点:简化了配置，但不利用系统维护。所以一般不推荐此中用法，下面我们再来介绍第5中非常简单的配置。 5.通过注解注解方式可以简化Spring的IOC容器的配置。使用步骤: 1.先引入context名称空间 2.开启注解扫描 3.使用注解:通过注解的方式，把对象加入到IOC容器中 首先在IOC配置文件中引入context名称空间,即在全局标签中添加xmlns:context=”http://www.springframework.org/schema/context&quot;属性然后在配置文件中添加如下标签：base-package:表示该扫描器只扫描此包下所有类。 最后我们便可以使用注解了，在pojo对象的.java文件中分别加入如下注解:@Componet注解:代表将该对象放入到IOC容器中，括号里面的名字代表该对象在IOC容器中的唯一标识名字，名字任意取。该注解写在代码第一行。 @Resource注解:用于将该对象依赖的属性从IOC容器中找到并注入，括号里面的name属性值必须跟@Compenent注解里填入的名字相同。 通过注解方法便可去掉各.java文件中为属性创建设置的set方法。 继续对上述注解方式进行配置优化，去掉括号中的内容: 在测试类中运行依然可以正常运行。 说明:利用@Compenent注解的方式是通用的将对象加入到IOC容器中的方式，而有时候我们需要区别各层对象添加的方式，所以这里我们将Dao层对象添加到IOC容器的注解方式改为:@Repository表示持久层的组件;修改Service层对象添加到IOC容器的注解方式:@Service表示业务逻辑层的组件;修改Servlet层对象添加到IOC容器的注解方式为:@Controller表示控制层的组件。 另外需要说明的是使用注解的方式将对象添加到IOC容器中和在xml文件中添加配置的方式是可以共存的。但通过@Resource不带括号的注解，必须要保证该类型只有一个变量，所以一般情况下我们还是优先使用@Resource(name=””)注解。 到此，Spring框架的学习我们已完成。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习之查询缓存]]></title>
    <url>%2F2018%2F10%2F02%2FMyBatis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[正如大多数持久层框架一样，MyBatis同样也提供了对查询数据的缓存支持。今后我们要学习的SpringMVC框架属于系统控制层，它也有它的缓存区域，对响应的jsp页面进行缓存；Spring属于系统业务层，它的缓存区域对业务数据进行缓存。而它们三者的缓存区域都存在于用户要访问数据库的中间，当用户向数据库中发送查询请求时，系统会先在它们三者的缓存区域看是否有满足用户要求的查询数据，若有则直接从缓存区域返回信息；若没有则从数据库中进行查询。 缓存的意义将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。 MyBatis持久层缓存MyBatis提供了一级缓存和二级缓存，概念图如下:图中所示，MyBatis一级缓存是一个SqlSession级别，SqlSession只能访问自己的一级缓存的数据，二级缓存是跨SqlSession，是mapper级别的缓存，对于mapper级别的缓存不同的Sqlsession是可以共享的。 MyBatis一级缓存原理对于图的解释:第一次发出一个查询sql，sql查询结果写入sqlsession的一级缓存中，缓存使用的数据结构是一个map&lt;key,value&gt;。 key：hashcode+sql+sql输入参数+输出参数（sql的唯一标识） value：用户信息 同一个sqlsession再次发出相同的sql，就从缓存中取,而不走数据库。如果两次中间出现commit操作（修改、添加、删除），本sqlsession中的一级缓存区域全部清空，下次再去缓存中查询不到所以要从数据库查询，从数据库查询到再写入缓存。即对于查询操作，每次查询都先从缓存中查询，如果缓存中查询到数据则将缓存数据直接返回，如果缓存中查询不到就从数据库查询。 一级缓存配置mybatis默认支持一级缓存不需要配置。 注意:mybatis和spring整合后进行mapper代理开发，不支持一级缓存，mybatis和spring整合，spring按照mapper的模板去生成mapper代理对象，模板中在最后统一关闭sqlsession。 一级缓存的测试运行，在控制台看到输出:发现打印两次结果只有第一次向数据库中发送了查询请求，第二次是直接从缓存中返回的数据。接下来我们在中间加入更新数据的操作:然后在控制台中看到打印过程:可以发现向数据库发送了三次请求。 MyBatis二级缓存二级缓存原理二级缓存的范围是mapper级别（mapper同一个命名空间），mapper以命名空间为单位创建缓存数据结构，结构是map&lt;key、value&gt;。 过程:每次查询先看是否开启二级缓存，如果开启从二级缓存的数据结构中取缓存数据，如果从二级缓存没有取到，再从一级缓存中找，如果一级缓存也没有，从数据库查询 二级缓存的配置不像一级缓存那样mybatis自动开启一级缓存，mybatis是默认关闭二级缓存的，所以我们需要需要进行两个操作才能开启二级缓存:1.在核心配置文件SqlMapperConfig.xml中加入 &lt;!--开启二级缓存--&gt; &lt;setting name = &quot;cacheEnabled&quot; value = &quot;true&quot;&gt; 属性值cacheEnabled表示对在此配置文件下的所有cache 进行全局性开/关设置，它的可选值为true｜false,默认值为true. 2.在你的Mapper映射文件中添加一行: ，表示此mapper开启二级缓存。3.查询结果映射的pojo序列化：mybatis二级缓存需要将查询结果映射的pojo实现 java.io.serializable接口，如果不实现则抛出异常：org.apache.ibatis.cache.CacheException: Error serializing object. Cause: java.io.NotSerializableException: cn.itcast.mybatis.po.User 二级缓存可以将内存的数据写到磁盘，存在对象的序列化和反序列化，所以要实现java.io.serializable接口。 如果结果映射的pojo中还包括了pojo，都要实现java.io.serializable接口。 二级缓存的禁用于变化频率较高的sql，需要禁用二级缓存：在statement中设置useCache=false可以禁用当前select语句的二级缓存，即每次查询都会发出sql去查询，默认情况是true，即该sql使用二级缓存。 &lt;select id=&quot;findOrderListResultMap&quot; resultMap=&quot;ordersUserMap&quot; useCache=&quot;false&quot;&gt; 刷新缓存将二级缓存进行刷新操作有两种方式: - **如果sqlsession操作commit操作，对二级缓存进行刷新（全局清空）。** - 设置statement的flushCache是否刷新缓存，默认值是true。 测试代码分别将中间更新用户信息的代码注释:发现两次打印用户信息的操作只向数据库中发送一次查询请求;去掉注释:三次操作向数据库中发送三次请求。 二级缓存的应用场景对查询频率高，变化频率低的数据建议使用二级缓存。 对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。 实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。 二级缓存的局限性mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。 MyBatis和ehcache缓存框架整合分布缓存将缓存数据进行分布式管理 MyBatis和ehcache整合思路通过MyBatis和ehcache框架进行整合，就可以把缓存数据的管理托管给ehcache。 首先我们看看MyBatis自己的二级缓存，它在自己内部提供了一个cache接口，我们只要实现了cache接口就可以把缓存数据灵活的管理起来。 要将MyBatis和ehcache整合，我们首先需要下载ehcache的jar包: ehcache-core.jar mybatis-ehcache.jar 然后需要添加一个ehcache的配置文件ehcache.xml:然后在mapper.xml中添加ehcache的配置: 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习之使用resultMap实现高级映射]]></title>
    <url>%2F2018%2F10%2F02%2FMyBatis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BD%BF%E7%94%A8result%E5%AE%9E%E7%8E%B0%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[对于数据库中对表的增删改查操作，我们知道增删改都涉及的是单表，而只有查询操作既可以设计到单表操作又可以涉及到多表操作，所以对于输入映射parameterType而言是没有所谓的高级映射的，也就是说高级映射只针对于输出映射(因为高级映射设计到多张表)。 前五篇文章我们都只实现了单表中的字段与pojo的映射，而本篇文章我们将来讲解如何实现多表与pojo之间的高级映射,分别有一对一映射、一对多映射和多对多映射。首先我们来看看如何使用resultType完成一对一映射。 多表间的一对一查询需求查询订单信息关联查询用户信息。这里我们知道一个用户可以有多张订单，而一张订单只能属于一个用户，所以用户与订单间的关系是一对多而订单与用户间的关系是一对一。所以这里我们将订单表作为主查询表来关联用户表，从而实现一对一映射。 创建表和数据create table orders( id int primary key auto_increment, user_id int , number int, createtime datetime, note varchar(50)); 用户表在第一篇文章中我们已经创建。 建立oders表和user表对应的pojo对象Orders.java和User.java。 public class Orders { private Integer id; private Integer userId; private String number; private Date createtime; private String note; ｝ 并建立相关的get和set方法，User.java我们之前已建立。 sql查询语句对于查询语句，我们需要知道:1.先确定主查询表:订单表。2.再确定关联查询表:用户信息表。通过orders关联查询用户使用user_id一个外键，只能关联查询出一条用户记录，我们使用内连接。查询语句为: SELECT orders.*,user.username,user.sex FROM orders,user WHERE orders.user_id = user.id 使用resultType实现一对一映射通过查询语句，查询到的结果同时包括user表和orders表两张表的列，那么我们将结果映射到哪个pojo对象中呢？若映射到User.java，那查询结果中对应的orders表的字段一定会遗失；若映射到Orders.java，那查询结果中对应的user表的字段同样也会遗失。所以这里需要我们针对查询的结果重新创建一个映射的pojo对象OrderCustom.java:这里我们让OrderCustom.java继承自Order.java，这样我们就只需在OrderCustom.java中添加user表中的字段即可。因为MyBatis主要的重点在sql语句，所以我们完成配置和pojo对象的建立后主要的点就放在了sql语句上，所以接下来要定义写sql语句的mapper.xml和对数据库进行操作的mapper.java接口了OrdersMapperCustom.xml文件内容如下:因为我们只关心输出映射，所以在xml中写sql查询语句时没有写parameterType属性，而resultType的属性值我之所以没有写全OrderCustom类的全限定性名，是因为我们在SqlMapperConfig.xml中进行了别名的配置。相应的OrdersMapperCustom.java接口内容如下:然后在测试类中测试:便可完成这两张表的关联与我们自定义的pojo对象的映射。接下来我们看看如何使用resultMap完成。 使用resultMap实现一对一映射思路:将关联查询的信息映射到pojo中，如下:只需在Orders类中创建一个User属性，将关联查询的信息映射到User属性中。这样我们便可以将查询的结果映射到Orders.java类中，而不用自己再自定义一个pojo了。 修改OrdersMapperCustom.xml中的内容(添加并使用resultMap标签),注意association标签的用法然后在OrdersMapperCutom.java中添加方法:最后测试:发现查询结果已全部映射到Orders.java类中。 比较resultType和resultMap完成一对一映射 resultType：要自定义pojo 保证sql查询列和pojo的属性对应，这种方法相对较简单，所以应用广泛。 resultMap：使用association完成一对一映射需要配置一个resultMap标签，过程有点复杂，如果要实现延迟加载(后面会讲)就只能用resultMap实现 ，如果为了方便对关联信息进行解析，也可以用association将关联信息映射到pojo中方便解析。 多表间的一对多查询需求查询所有订单信息及订单下的订单明细信息。分析:一个订单可以可以有多个订单明细，而一个订单明细只属于一个订单，所以订单与订单明细间的关系为一对多。 创建表和数据create table orderdetail( id int primary key auto_increment, orders_id int, items_id int, items_num int);//创建订单明细 创建和订单明细表对应的pojo对象: public class Orderdetail { private Integer id; private Integer ordersId; private Integer itemsId; private Integer itemsNum; } 并创建相关的set和get方法。 sql查询语句1.先确定主查询表:订单表。2.再确定关联查询表:用户表加订单明细表。通过orderdetail关联查询订单使用orders_id一个外键，只能关联查询出一条订单记录，我们使用内连接。查询语句为: SELECT orders.*,user.username,user.sex ,orderdetail.id orderdetail_id,orderdetail.items_num,orderdetail.items_id FROM orders,user,orderdetail WHERE orders.user_id = user.id AND orders.id=orderdetail.orders_id 使用resultMap进行一对多映射思路:resultMap 提供collection完成关联信息映射到集合对象中。在orders类中创建集合属性：然后修改OrdersMapperCustom.xml中的信息:并在其中添加resultMap的定义:最后进行测试: 延迟加载(只能用resultMap)使用延迟加载的意义在进行数据查询时，为了提高数据库查询性能，尽量使用单表查询，因为单表查询比多表关联查询速度要快。如果查询单表就可以满足需求，一开始先查询单表，当需要关联信息时，再关联查询，当需要关联信息再查询这个叫延迟加载。mybatis中resultMap提供延迟加载功能，通过resultMap配置延迟加载,但需要在MyBatis的配置文件中进行相关配置，如下然后在SqlMapperConfig.xml中添加如下配置信息: 一对一延迟加载的实现实现思路需求:查询订单及用户的信息，一对一查询。 刚开始我们只查询订单信息。而当需要用户信息时调用Orders类中的getUser()方法执行延迟加载 ，向数据库发出sql。代码实现如下:在OrderMapperCustom.xml文件中添加如下信息:并定义resultMap标签:最后是测试代码: 一对多延迟加载的实现一对多延迟加载的方法同一对一延迟加载，在collection标签中配置select内容。 resultType、resultMap、延迟加载使用场景总结延迟加载:延迟加载实现的方法多种多样，在只查询单表就可以满足需求，为了提高数据库查询性能使用延迟加载，再查询关联信息。 mybatis提供延迟加载的功能用于service层。 resultType:作用：将查询结果按照sql列名pojo属性名一致性映射到pojo中。 场合：常见一些明细记录的展示，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。 resultMap:使用association和collection完成一对一和一对多高级映射。 association:作用:将关联查询信息映射到一个pojo类中。 场合:为了方便获取关联信息可以使用association将关联订单映射为pojo，比如:查询订单及关联用户信息。 collection:作用:将关联查询信息映射到一个list集合中。 场合:为了方便获取关联信息可以使用collection将关联信息映射到list集合中，比如:查询用户权限范围模块和功能，可使用collection将模块和功能列表映射到list中 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis之动态sql的编写]]></title>
    <url>%2F2018%2F10%2F02%2FMyBatis%E4%B9%8B%E5%8A%A8%E6%80%81sql%E7%9A%84%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[我们需要知道的是，使用mybatis重点是对sql的灵活解析和处理。在原先的UserMappser.xml中，我们这样查询表中满足条件的记录 : &lt;select id=&quot;findUserList&quot; parameterType=&quot;userQueryVo&quot; resultType=&quot;user&quot;&gt; select id,username,birthday from user where username like &apos;${value}&apos; &lt;/select&gt; 上述语句在表中查询满足username条件的记录，这样写查询语句有一个弊端，就是该语句只能通过username查询数据库。当我们在多条件中查询时，如果不需要username条件而是需要其它多个查询条件时，那UserMapper.xml文件中的这个查询条件就没用了。 需求:将自定义查询条件查询用户列表和查询用户列表总记录数改为动态sql。需要使用if标签和where标签。 if和where标签使用if标签和where标签在UserMapper.xml中添加如下内容:修改自定义查询条件查询用户列表代码:修改自定义查询条件查询用户列表总记录数代码:发现和在上述两个查询语句中重复的代码出现了两次，那这里我们是否可以把相同的sql片段拿出来单独写在一个sql片段中然后再在不同的查询语句中应用呢？答案是肯定的,看下面的sql片段。 sql片段的抽取通过sql片段可以将通用的sql语句抽取出来，单独定义，在其它的statement中可以引用sql片段。其中通用的sql语句，一般用在:where条件、查询列。 定义sql片段在UserMapper.xml中添加标签代表sql片段: 使用sql片段使用标签对上面定义的sql片段加以引用: 测试类代码不变，这样我们便完成了对sql片段的引用。 有时候我们希望查询语句是这样select id,username,birthday from user where username like ‘%codingXiaxw%’ and id in (1,2)，那我们又应该在sql片段中如何添加代码呢？这时候需要用到标签。 foreach标签在statement通过foreach遍历parameterType中的集合类型。首先我们需要在UserQueryVo中定义Listids属性:并添加相应的get和set方法。 然后我们在UserMapper.xml中使用foreach修改where语句,使用foreache遍历list:测试代码 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java封装继承多态和OOP设计原则]]></title>
    <url>%2F2018%2F10%2F02%2FJava%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[封装封装的定义 首先是抽象，把事物抽象成一个类，其次才是封装，将事物拥有的属性和动作隐藏起来，只保留特定的方法与外界联系 为什么要封装 实现了对属性和实现细节的封装，用户不用去关心内部的实现；使用者只能通过规定的方法访问数据，可以方便的加入存取控制语句，限制了不合理的操作；当内部逻辑发生变化时，外部访问不用修改。 继承Java的类可以分为三类： - 普通类：使用class定义，没有抽象方法 - 抽象类：使用abstract class定义，可以有也可以没有抽象方法 - 接口：使用inerface定义，只能有抽象方法 继承到底做了什么(扩展和覆盖)- **子类继承除构造函数的一切东西。(私有属性能被继承的,但是子类无法访问父类的私有属性或方法,用反射的话，私有属性和方法都是可以访问的)** - **子类可以添加自己的方法和属性，即对父类进行扩展** - **子类可以重新定义父类的方法，即多态里面的覆盖，后面会详述** 关于构造函数： - **构造函数不能被继承，子类可以通过super()显式调用父类的构造函数** - **创建子类时，编译器会自动调用父类的 无参构造函数** - **如果父类没有定义无参构造函数，子类必须在构造函数的第一行代码使用super()显示调用** 为什么要有继承代码重用是一点，最重要的还是所谓想上转型，即父类的引用变量可以指向子类对象，这是Java面向对象最重要特性多态的基础。 多态- **多态可以分为两种类型：编译时多态（方法的重载）和运行时多态（继承时方法的重写），编译时多态很好理解，后述内容针对运行时多态** - 运行时多态依赖于继承、重写和向上转型 首先需要知道方法的唯一性标识即什么是相同/不同的方法： - 其中只有**方法名和参数**是唯一性标识，意即只要方法名和参数相同那他们就是相同的方法 - **所谓参数相同，是指参数的个数，类型，顺序一致，其中任何一项不同都是不同的方法** 何谓重载： - **重载是指一个类里面（包括父类的方法）存在方法名相同，但是参数不一样的方法，参数不一样可以是不同的参数个数、类型或顺序** - 如果仅仅是修饰符、返回值、throw的异常 不同，那这是2个相同的方法，编译都通不过，更不要说重载了 何谓覆盖Override： - 覆盖描述存在继承关系时子类的一种行为 - **子类中存在和父类相同的方法即为覆盖，何谓相同方法请牢记前面的描述，方法名和参数相同，包括参数个数、类型、顺序** 覆盖/重写的规则：（两同两小一大原则） -子类不能覆盖父类private的方法，private对子类不可见，如果子类定义了一个和父类private方法相同的方法，实为新增方法 - 重写方法的修饰符一定要大于被重写方法的修饰符(public &gt; protected &gt; default &gt; private) - 重写抛出的异常需与父类相同或是父类异常的子类，或者重写方法干脆不写throws重写方法的返回值必须与被重写方法一致，否则编译报错 - 静态方法不能被重写为非静态方法，否则编译出错 总结java中变量不能重写，可以按如下口诀记忆： - **变量多态看左边，** - **方法多态看右边，** - 静态多态看左边。 多态的好处:降低代码的耦合度 面向对象设计原则面向对象设计原则是我们用于评价一个设计模式的使用效果的重要标准之一。 - 单一职责原则 定义：**一个类只负责一个领域的相应职责 ** - 开闭原则 定义：软件实体应对扩展开放，而对修改关闭 - 里氏替换原则 定义：所有引用基类的对象能够透明的使用其子类的对象 - 依赖倒转原则 定义：抽象不应该依赖于细节，细节依赖于抽象 - 接口隔离原则 定义：**使用多个专门的接口，而不是使用单一总接口** - 合成复用原则 定义：尽量使用对象组合，而不是继承来达到复合目的 - 迪米特法则 定义：一个软件实体应当尽可能少的与其它实体发生相互作用 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习之输入与输出映射]]></title>
    <url>%2F2018%2F10%2F02%2FMyBatis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[在MyBatis中，我们通过parameterType完成输入映射(指将值映射到sql语句的占位符中，值的类型与dao层响应方法的参数类型一致)，通过resultType完成输出映射(从数据库中输出，通过dao层的方法查询到的数据输出到pojo对象中)。 注意输入与输出都是相对于数据库的。接下来我们先谈谈输入映射。 输入映射parameterType通过parameterType传入简单类型或对象，我们之前讲过了，接下来我们要讲的是parameterType传递pojo包装对象。可以定义pojo包装类型扩展mapper接口输入参数的内容。 看下我们的需求:定义查询条件查询用户信息，需要向statement输入查询条件，查询条件可以有user信息、商品信息等等。首先我们在domain包下创建UserCustom类并继承User：UserCustom类用于对User属性进行扩展(例如User中只有用户信息，而我们可以在UserCustom中加入商品信息)，然后再创建User的包装类UserQueryVo.java:UserMapper.xml中添加如下配置信息:UserMapper.java中添加方法:然后便可以进行测试: 可能出现的异常:如果在parameterType中指定了错误的属性名时会出现如下异常: org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;userCusto&apos; in &apos;class cn.itcast.mybatis.po.UserQueryVo&apos;### Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;userCusto&apos; in &apos;class cn.itcast.mybatis.po.UserQueryVo&apos; 输出映射(resultType和resultMap)输出映射有resultType和resultMap,他们都是指定输出结果的类型(pojo、简单类型、hashmap…)，并将sql查询结果映射为java对象 。 resultType借用上述parameter传递包装pojo对象的知识(不用parameter传递包装pojo对象的知识也行)，我们来谈谈用resultType输出简单类型。UserMapper.xml文件中添加如下配置:然后在UserMapper.java中添加如下方法:测试:使用resultType时我们应该注意:sql查询的列名要和resultType指定pojo的属性名相同，指定相同属性方可映射成功，如果sql查询的列名要和resultType指定pojo的属性名全部不相同(或是部分不相同)，则映射到pojo对象中的对应属性为null。例如有时候我们不需要查询select * from user where id = ?而是select username,address _address where id = ? 此时我们给查询的address列名给了一个别名_address，这样我们通过查询表中address的数据然后在将它映射到User对象时，该对象的address属性就为null，即没将从表中查询到的address数据映射到user对象的address属性中 resultMap使用resultMap需要在UserMapper.xml中进行配置:然后在UserMapper.xml中使用它:UserMapper.java文件中:测试类代码: 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis之优化MyBatis配置文件中的配置]]></title>
    <url>%2F2018%2F10%2F02%2FMyBatis%E4%B9%8B%E4%BC%98%E5%8C%96MyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[MyBatis配置文件属性了解MyBatis配置文件很重要，首先我们来看看MyBatis配置文件中的内容和顺序: &lt;properties&gt;(属性) &lt;setting&gt;(全局配置参数) &lt;typeAliases&gt;(类型别名) &lt;typeHandlers&gt;(类型处理器) &lt;objectFactory&gt;(对象工厂) &lt;plugins&gt;(插件) &lt;environments&gt;(环境集合属性对象) &lt;environment&gt;(环境子属性对象) &lt;transactionManager&gt;(事务管理) dataSource&gt;(数据源) &lt;mappers&gt;(映射器) 属性定义可以把一些通用的属性值配置在属性文件中，加载到mybatis运行环境内。例如创建db.properties文件，然后在SqlMapperConfig.xml中进行配置。db.properties文件内容如下:然后在SqlMapperConfig.xml中进行配置:然后在标签中用${}符号做如下修改:注意:Mybatis将按照下面的顺序来加载属性 - 1.在properties标签之间定义的属性首先被读取。 - 2.然后会读取properties标签内部resource或url的属性，它会覆盖已读取的同名属性。 - 3.最后读取parameterType(即insert标签或是update标签或是…)传递的属性，它会覆盖已读取的同名属性。 所以我们建议使用properties标签时，不要在properties标签之间定义属性，只引用在.properties文件中定义的属性，并且.properties文件中定义的key值要有一些特殊的规则。例如我上述定义key值时前面都加了jdbc.的前缀 &lt;settings&gt;全局参数配置mybatis运行时可以调整一些全局参数(相当于软件的运行参数)。根据使用需求进行参数配置。但是要注意:小心配置，配置参数会影响mybatis的执行。 ibatis的全局配置参数中包括很多的性能参数(最大线程数、最大等待时间…)，通过调整这些性能参数使ibatis达到高性能的运行，而mybatis没有这些性能参数，由mybatis自动调节。 &lt;typeAliases&gt;属性可以将parameterType、resultType中指定的类型通过别名引用。MyBatis提供了很多的别名如下:这里我们采用自定义的别名，在SqlMapperConfig.xml中进行如下配置:里面包括定义单个别名和批量别名定义(即一次性定义一个包下所有.java文件的别名)。 定义别名后这样我们在parameterType和resultType中使用时就不用再繁琐的指定类的全限定类名了，像下面这样使用即可 &lt;typeHandlers&gt;属性类型处理器将java类型和jdbc类型进行映射，mybatis提供了很多类型处理器，一般情况下够用了。 &lt;mapper&gt;映射器属性之前我们在配置文件中使用的标签内容为:&lt;mapper resource=“mapper/UserMapper.xml”/&gt;，接下来我要讲的是另一种在配置文件中映射mapper动态代理的方法。在配置文件中这样配置这样的要求需要保证UserMapper.xml文件和UserMapper.java在同一个包下且.xml文件和.java文件名要同名。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis之Mapper动态代理开发]]></title>
    <url>%2F2018%2F10%2F02%2FMyBatis%E4%B9%8BMapper%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[SqlSession的使用范围1.SqlSessionFactoryBuilderSqlSessionFactoryBuilder是以工具类的方式来使用:需要创建sqlSessionFactory时就new一个 SqlSessionFactoryBuilder 2.sqlSessionFactory正常开发时，以单例方式管理sqlSessionFactory，整个系统运行过程中sqlSessionFactory只有一个实例，将来和Spring整合后由Spring以单例方式管理sqlSessionFactory 3.SqlSessionSqlSession是一个面向用户(程序员)的接口，程序员调用 SqlSession接口的方法进行操作数据库。那么我们会思考:SqlSession能否以单例方式使用？？？由于 SqlSession是线程不安全的，所以 SqlSession最佳应用范围在方法体内。也就是说在方法体内定义局部变量 SqlSession的对象来使用。 MyBatis开发DAO的方式:我们先来看看MyBatis原始开发dao的开发方式，发现原始开发的问题，然后再来看看MyBatis使用mapper动态代理开发dao的方式(也是MyBatis目前使用的开发dao的方式)。 原始dao的开发方式程序员需要编写dao接口和dao实现类然后就能在测试类中使用。测试类代码如下: 1.dao的实现类中存在重复代码，整个mybatis操作的过程代码模板重复(都是先创建sqlSession、调用sqlSession的方法、关闭sqlSession)。 2.dao的实现类中存在硬编码，调用sqlSession方法时将statement的id硬编码。 mapper动态代理的方式程序员只需要写dao接口，dao接口实现对象由mybatis自动生成代理对象。因为本身dao在三层架构中就是一个通用的接口。1.mapper开发规范：要想让mybatis自动创建dao接口实现类的代理对象，必须要遵循一些规则: - **mapper.xml中 namespace指定为mapper接口的全限定名。此步骤的目的:将mapper.xml和mapper.java关联。** - mapper.xml中**statement的id就是mapper.java中的方法名。即对应相同** - mapper.xml中**statement的parameterType和mapper.java中方法输入参数一致。即参数一致** - **mapper.xml中statement的resultType和mapper.java中方法的返回值类型一致。即返回值一致** 2.mapper.xml(映射文件)3.mapper.java接口 public interface UserMapper{}; 4.将mapper.xml在SqlMapConfing.xml中进行注册 &lt;mappers&gt; &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; 5.mapper接口返回单个对象和集合对象在UserMapper.java中添加如下两个方法: User findUserById(int id) throws Exception ; List&lt;User&gt; findUserByName (String username) throws Exception; 对于UserMapper.xml，不管你查询的记录是单条还是多条，在statement(即UserMapper.xml)中的resultType都定义一致，都是单条记录映射的pojo类型 而对于UserMapper.java接口方法中的返回值，如果返回的是单个对象，返回值类型是pojo，生成的代理对象内部会自动通过selectOne获取记录，如果返回值类型是多条对象，生成的代理对象内部会自动通过selectList获取记录。 UserMapper userMapper = sqlsession.getMapper(UserMapper.class) 注意:mapper动态代理开发的问题- 返回值的问题:如果方法(即UserMapper.java接口中的方法)调用的statement中返回是多条记录，而mapper.java方法的返回值为pojo，此时代理对象通过selectOne调用，但由于返回的是多条记录所以会报错:Expected one result (for null ) to be returned by selectOne() but found 4; - 输入参数的问题:使用mapper代理的方式开发，mapper接口方法的输入参数只有一个，可扩展性是否很差?答:可扩展性没有问题，因为dao层就是通用的，可以通过扩展pojo(定义pojo包装类型，后面第四篇文章–MyBatis输入输出映射会讲扩展pojo的知识)来将不同的参数(可以是pojo也可以是简单类型)传入进去 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习之快速入门]]></title>
    <url>%2F2018%2F10%2F02%2FMyBatis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[在学习框架之前，我们先弄明白为什么要学框架。首先个人认为简化开发并不是采用框架唯一的目的，更重要的是规范，不用框架时写出来的代码千奇百怪，各种凌乱，有框架的约束更容易制定规范，而简化的任务是基于框架再做一些有针对性的封装时该做的事。 而因为框架内部执行的复杂带来的性能损耗是要配合其他手段来优化的，比如连接池、缓存之类的，而这些手段是很容易通过框架间的整合融入进来的，如果你只用纯jdbc， 就比较困难，自己要做很多事情，还很难做好。框架整合封装完毕后，再来测试性能问题，单纯的执行一条SQL语句来判断效率是没有必要的，没什么实际价值，更多的应该是去看在并发的情况下、不同的业务场景、针对业务有效的优化后，再来看整个工程所有功能模块的平均效率，你才会做出合理的判断。项目代码 MyBatis框架的引入我们来看看传统的编程方式中使用jdbc的问题: 数据库连接频繁的创建和关闭，缺点:浪费数据库的资源，影响操作效率。解决方法:使用数据库连接池如c3p0. sql语句是硬编码(不利用系统维护)，如果需求变更需要修改sql，这时候就需要修改java代码，然后需要重新编译，系统不易维护。解决方法:将sql语句统一配置在文件中。这样以后修改sql时就不需要修改java代码了。 我们通过preparedStatement对象向占位符设置参数，存在硬编码(参数位置、参数)问题，系统不易维护。解决方法:将sql中的占位符及对应的参数类型配置在配置文件中，能够自动输入的映射。 遍历查询结果集存在硬编码(列名)。解决方法:自动进行sql查询结果向java对象的映射(输出映射) MyBatis的优点MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。MyBatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。 MyBatis架构如下图: MyBatis快速入门 编写SqlMapConfig.xml 编写mapper.xml(每个字段定义一个statement) 编程通过配置文件创建SqlSessionFactory 通过SqlSessionFactory获取SqlSession对象。 通过SqlSession操作数据库。(如果执行添加、更新、删除需要调用SqlSession.commit()) SqlSesion使用完成要关闭。 准备开发环境1.创建测试项目，普通java项目或是web项目都可2.导入jar包:mybatis-3.1.1.jar(低于这个版本的jar包需要导入很多依赖包)和mysql-connection-java3.创建数据库和相应的表,SQL脚本如下: create database mybatis; use mybatis; create table user( id int primary key auto_increment, username varchar(50), birthday date, sex varchar(20), address varchar(50) ); insert into user values(null,&apos;yzh&apos;,&apos;1996-09-14&apos;,&apos;male&apos;,null); insert into user values(null,&apos;pcl&apos;,&apos;1997-08-26&apos;,&apos;female&apos;,null); 到此，环境配置就告一段落。 使用MyBatis查询表中数据(通过id查询)1.添加Mybatis的配置文件SqlMapConfig.xml(名字可以随便起) &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!--和spring整合后，environments配置将废除--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!--使用JDBC事务管理--&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;&quot; value=&quot;&quot;/&gt; &lt;/transactionManager&gt; &lt;!--数据库连接池--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 2.定义表所需要的实体类User.java3.定义操作user表的sql映射文件User.xml这里我们没将文件命名为userMapper.xml，后面我们会改。文件内容如下: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;Message&quot;&gt; &lt;!--根据id查询用户信息--&gt; &lt;!--id为唯一标识 #{}表示一个占位符，如果#{}传入的是简单类型的参数，那么他里面的名称随意， paramterType:输入参数的类型，通过占位符#{}接受paramterType传入的参数值 resultType：输出结果参数--&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;entity.User&quot;&gt; SELECT * from user WHERE id = #{id} &lt;/select&gt; &lt;/mapper&gt; 在User.xml中写SQL语句，在参数处使用占位符#{}，应该注意的是大括号{}中传入的数据应该与User.java中的属性对应，文件中各个属性的解释见图中注释处。 4.在SqlMapConfig文件中注册User.xml文件在SqlMapConfig.xml中添加一个字段，并在里面传入User.xml文件路径。 5.接下来我们便可以借助上面MyBatis架构图来编写测试类了 public class FirstMyBatis { private SqlSessionFactory sqlSqlSessFactory; //创建工厂 @Before public void init() throws IOException { //配置文件 String resource = &quot;Configuration.xml&quot;; //加载配置文件到输入流中 //InputStream inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource); InputStream inputStream = Resources.getResourceAsStream(resource); //创建会话工厂 sqlSqlSessFactory = new SqlSessionFactoryBuilder().build(inputStream); } //根据id查找用户 @Test public void testFindUserById(){ //通过sqlSqlSessFactory创建sqlSession SqlSession sqlSession = sqlSqlSessFactory.openSession(); User user = null; //通过sqlSession操作数据库 //第一个参数为statement的位置，等于namespace+statement的id //第二个参数，传给占位符大的参数 user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1); System.out.println(user); } } 使用MyBatis根据用户名模糊查询用户信息(通过name)1.需要在mapper.xml中添加以下字段: &lt;select id=&quot;findUserByNamr&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;entity.User&quot;&gt; SELECT * from user WHERE username like &apos;%${value}%&apos; &lt;/select&gt; 此时，我们在传入参数的地方不再使用占位符#{}而是使用${}，二者区别如下: #{}:1.表示一个占位符，向占位符输入参数，mybatis自动进行java类型和jdbc类型的转换。2.程序员不需要考虑参数的类型，比如：传入字符串，mybatis最终拼接好的sql就是参数两边加单引号。3.#{}接收pojo(Plain Old Java Object Java数据对象)数据，可以使用OGNL(就是el表达式)解析出pojo的属性值。 ${}:1.表示sql的拼接，通过${}接收参数，将参数的内容不加任何修饰拼接在sql中。2.${}也可以接收pojo数据，可以使用OGNL解析出pojo的属性值。3.缺点:不能防止sql注入 什么是sql注入，怎样防止？，如果是直接拼接的方式那么就非常容易被注入。比如：select from tablename where user=’admin’ and pwd =’123’ 假设说这个是一个登录的sql语句，admin是用户文本框输入的，pwd是密码框输入的。如果密码文本框如果输入：’ or ‘1’=’1 那么拼接起sql就是select from tablename where user=’admin’ and pwd =’’ or ‘1’=’1’ 那么就会跳过sql的条件就直接进入登录，但是如果是使用绑定变量的就不一样 Demo： //测试根据name查询用户（得到多条记录） @Test public void testFindUserByName(){ //通过sqlSqlSessFactory创建sqlSession SqlSession sqlSession = sqlSqlSessFactory.openSession(); List&lt;User&gt; list = null; list = sqlSession.selectList(&quot;test.findUserByName&quot;,&quot;y&quot;); sqlSession.close(); System.out.println(list.get(0).getUsername()); } 注意，此时我们通过name查询出来的语句为多条，故此时我们应该选择调用sqlSession对象的selectList()方法返回多条记录，输出我们查询到的第一条记录即可。若使用selectOne()方法，当返回的记录为多条时就会发生异常。 这样我们便完成了查询时将sql结果输出映射到Java对象中。那如何将Java对象输入映射到sql语句中，接下来我们就来讲通过MyBatis实现增、删、改数据库。 使用MyBatis向表中插入一条记录&lt;insert id=&quot;insertUser&quot; parameterType=&quot;entity.User&quot;&gt; INSERT INTO user VALUES (#{id},#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt; 测试类: @Test public void testInsertUser(){ SqlSession sqlSession = sqlSqlSessFactory.openSession(); User user = new User(); user.setUsername(&quot;codingLembre&quot;); user.setAddress(&quot;GuangDong&quot;); user.setBirthday(new Date()); user.setSex(&quot;1&quot;); sqlSession.insert(&quot;test.insertUser&quot;,user); sqlSession.commit(); sqlSession.close(); } 此时查看数据库，发现数据已经被插入 注意插入和查询不一样需要sqlSession.commit();否则没有效果 Demo: 拓展:主键返回在测试类中，我们没有给User对象的id属性设置值，所以我们在测试类中尝试输出User对象的id时会输出id=0，但是该对象通过输入映射在数据库中是有对应的id值的(因为我们为该字段设置了自增长属性)。那么我们想输出该对象在记录中的id时，又该怎么做呢？只需在User.xml文件中的标签中添加标签即可,属性解释见图: &lt;!--主键返回,order属性比那时该字段在insert语句之后才执行,还要借助函数--&gt; &lt;insert id=&quot;insertUserByKey&quot; parameterType=&quot;entity.User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO user VALUES (#{id},#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt; 此时我们在测试类中便可输出该User对象插入在表中的记录id值了。 如果未设置主键返回，那么sout(id)得到的都是0； 这里我们由于在建表时设置了id字段为自增长，采用自增长的形式生成主键，所以我们在传入User对象的id属性时可以将该属性设置为null。那么当我们使用uuid生成主键时又该怎么做呢？ &lt;insert id=&quot;insertUserByUUID&quot; parameterType=&quot;entity.User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;int&quot;&gt; SELECT uuid() &lt;/selectKey&gt; INSERT INTO user VALUES (#{id},#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt; 属性值”before”的意思表示在执行插入操作时，会先调用uuid()函数生成uuid得到主键，然后将主键设置到User对象中，再将User对象插入到数据库。所以此时我们在测试类中也可以不对User的id属性进行设置值。但是无法演示功能，因为user表已经设置为自动增长。 使用MyBatis实现删除表中数据因为和上述的操作差不多，注意commit即可，不再演示。 使用MyBatis实现更新表中数据因为和上述的操作差不多，注意commit即可，不再演示。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记之MySQL语法]]></title>
    <url>%2F2018%2F09%2F30%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BMySQL%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[SQL语句分类 DDL(Data Definition Language):数据定义语言，用来定义数据库对象：库、表、列等。功能：创建、删除、修改库和表结构。 DML(Data Manipulation Language):数据操作语言，用来定义数据库记录:增、删、改表记录。 DCL(Data Control Language):数据控制语言，用来定义访问权限和安全级别 DQL(Data Query Language):数据查询语言，用来查询记录。也是本章学习的重点。 SQL数据中的属性类型 TINYINT:1字节，小整数值。 SMALLINT:2字节，大整数值。 MEDIUMINT:3字节，大整数值。 INT或INTEGER:4字节，整型,大整数值。 FLOAT:单精度浮点数值。 DOUBLE(5,2):双精度浮点型数值，参数表示该浮点型数值最多有5位，其中必须有2位小数。 DECIMAL(M,D):小数值,参数表示该数值最多有M位，其中必须有D位小数。 CHAR:字符型，固定长度字符串类型:char(255)。你存入一个a字符，虽然a只占一个字符，但是它会自动给你加254个空格凑成255个长度。即数据的长度不足指定长度，它会补足到指定长度。 VARCHAR:可变长度字符串类型：varchar(65535),你存入的数据多长它就是多长。它会抽出几个字节来记录数据的长度。 TEXT(CLOB):mysql独有的数据类型，字符串类型。 BLOB:字节类型。 YEAR:年份值，格式为:YYYY DATA:日期类型，格式为:yyyy-MM-dd。 TIME:时间类型，格式为:hh:mm:ss。 TIMESTAMP:时间戳类型，格式为上面二者的综合。 DATETIME:混合日期和时间值，格式为:YYYYMMDD HHMMSS. SQL语句详解DDL(数据定义语言)语法该语言用来对数据库和表结构进行操作。 对数据库的操作: 查看所有数据库:SHOW DATABASES; 使用数据库:USE 数据库名; 创建数据库并指定编码:CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARACTER SET UTF8]; 删除数据库:DROP DATABASE 数据库名; 修改数据库的编码:ALTER DATABASE 数据库名 CHARACTER SET UTF-8; 对表结构的操作 创建表: CREATE TABLE (IF NOT EXISTS) 表名( 列名 列类型， ...， 列名 列类型 )； 查看当前数据库中所有表:SHOW TABLES; 查看表结构:DESC 表名; 删除表:DROP 表名; 修改表:修改表有5个操作，但前缀都是一样的:ALTER TABLE 表名… 修改表之添加列:ALTER TABLE 表名 add (列名 列类型，...，列名 列类型); 修改表之修改列类型:ALTER TABLE 表名 MODIFY 列名 列的新类型; 修改表之列名称列类型一起修改:ALTER TABLE 表名 CHANGE 原列名 新列名 列名类型; 修改表之删除列:ALTER TABLE 表名 DROP 列名; 修改表之修改表名:ALTER TABLE 表名 RENAME TO 新表名 DML(数据操作语言)语法(增，删，改)该语言用来对表记录操作(增、删、改)。 插入数据(一次插入就是插入一行)insert into 表名 (列名1，列名2，列名3) values (列值1，列值2，列值3) 说明:1.在数据库中所有的字符串类型，必须使用单引号。2.(列名1，列名2，列名3)可省略，表示按照表中的顺序插入。但不建议采取这种写法，因为降低了程序的可读性。3.在命令行插入记录不要写中文，否则会出现乱码 修改记录(不会修改一行)修改某列的全部值:update 表名 set 列名1=列值1(，列名2=列值2); 修改(某行或者多行记录的)列的指定值:update 表名 set 列名1=列值1 where 列名2=列值2 or 列名3=列值3; 运算符:=、!=、&lt;&gt;、&lt;、&gt;、&gt;=、&lt;=、between…and、in(…)、is null、not、or、and。 其中in(…)的用法表示集合。例如:update 表名 set 列名1=列值1 where 列名2=列值2 or 列名2=列值22用in(…)写成update 表名 set 列名1=列值1 where 列名2 in(列值2，列值3),具体效果如下图所示 执行命令并刷新数据库后: 删除数据(删除整行)delete from 表名 (where 条件);不加where条件时会删除表中所有的记录，所以为了防止这种失误操作，很多数据库往往都会有备份。 DCL(数据控制语言)语法该语言用来定义访问权限，理解即可，以后不会多用。需要记住的是，一个项目创建一个用户，一个项目对应的数据库只有一个。这个用户只能对这个数据库有权限，其它数据库该用户就操作不了。 创建用户用户只能在指定ip地址上登录mysql:create user 用户名@IP地址 identified by ‘密码’； 用户可以在任意ip地址上登录:create user 用户名@‘％’ identified by ‘密码’； 给用户授权语法:grant 权限1，…，权限n on 数据库.* to 用户名@IP地址；其中权限1、2、n可以直接用all关键字代替。权限例如:create,alter,drop,insert,update,delete,select。 撤销授权语法:revoke 权限1，…，权限n on 数据库. from 用户名@ ip地址；撤销指定用户在指定数据库上的指定权限。撤销例如:revoke create,delete on mydb1. form user@localhost;表示的意思是撤消user用户在数据库mydb1伤的create、alter权限。 查看权限查看指定用户的权限:show grants for 用户名@ip地址； 删除用户drop user 用户名@ip地址； DQL(数据查询语言)语法(查)重点，该语言用来查询记录，不会修改数据库和表结构。 基本查询(后缀都是统一为from 表名) 1.字段(列)控制 1.查询所有列:select * from 表名;其中＊表示查询所有列，而不是所有行的意思。 2.查询指定列:select 列1，列2，列n from 表名； 3.完全重复的记录只显示一次::select distinct $ from 表名；缺省值为all。 4.列运算 a.数量类型的列可以做加、减、乘、除:SELECT sal5 from 表名；说明:1.**遇到null加任何值都等于null的情况，需要用到ifnull()函数。2.将字符串做加减乘除运算，会把字符串当作0。 b.字符串累类型可以做连续运算(需要用到concat()函数):select concat(列名1，列名2) from 表名;其中列名的类型要为字符串。在mysql中不能使用+等运算符进行字符串的连接 c. 给列名起别名:select 列名1 (as) 别名1,列名2 (as) 别名2 from 表名；*** 2.条件控制 1.条件查询。在后面添加where指定条件:select * from 表名 where 列名＝指定值; 2.模糊查询：当你想查询所有姓张的记录。用到关键字like。eg:select from 表名 where 列名 like ‘张_’;(**_代表匹配任意一个字符，％代表匹配0～n个任意字符)。*** 3.聚合函数 1.count:select count(列名) from 表名；,纪录有效行数。 2.max:select max(列名) from 表名；,列中最大值。 3.min:select min(列名) from 表名；,列中最小值。 4.sum:select sum(列名) from 表名；,求列的总值，null 和字符串默认为0。 5.avg:select avg(列名) from 表名;,一列的平均值。 4排序(所谓升序和降序都是从上往下排列) 1.升序:select form 表名 order by 列名 (ASC ); ()里面的内容为缺省值； 2.降序:select from 表名 order by 列名 DESC; 3.使用多列作为排序条件: 当第一列排序条件相同时，根据第二列排序条件排序(当第二列依旧相同时可视情况根据第三例条件排序)。eg:select * from 表名 order by 列名1 ASC, 列名2 DESC;意思是当列名1的值相同时按照列名2的值降序排。 5.分组查询分组查询的信息都是组的信息，不能查到个人的信息，其中查询组的信息是通过聚合函数得到的。 语法：select 分组列名，聚合函数1,聚合函数2 from 表名 group by 该分组列名；其中分组列名需要的条件是该列名中有重复的信息。 查询的结果只能为：作为分组条件的列和聚合函数；查处的信息都是组的信息。 分组查询前，还可以通过关键字where先把满足条件的人分出来，再分组。语法为:select 分组列，聚合函数 from 表名 where 条件 group by 分组列； 分组查询后，也可以通过关键字having把组信息中满足条件的组再细分出来。语法为：select 分组列，聚合函数 from 表名 where 条件 group by 分组列 having 聚合函数或列名(条件)； 分组查询的应用有查看每个部门的平均工资等等,而使用order by无法做到多条统计信息同时显示 6.LIMIT子句(mysql中独有的语法)LIMIT用来限定查询结果的起始行，以及总行数。 例如：select * from 表名 limit 4，3；表示起始行为第5行，一共查询3行记录。 总结学过的关键字：select,from,where,group by,having ,order by。当一条查询语句中都包含所有这些关键字时它们的优先级是select&gt;from&gt;where&gt;group by&gt;having&gt;order by 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String，StringBuilder和StringBuffer的区别]]></title>
    <url>%2F2018%2F09%2F30%2FJava%E4%B8%ADString%EF%BC%8CStringBuilder%E5%92%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[现在很多互联网公司面试java的面试官都喜欢问这样一个问题，那么就来谈谈java中String、StringBuilder和StringBuffer的区别。 区别: String字符串常量 StringBuffer字符串变量(线程安全） StringBuilder字符串变量（非线程安全） String所谓常量，即该对象的值已经被赋予了，不能再更改。若非要更改，则只能再重新创建另一个对象，在这个新创建的对象上再进行赋值。因此，每次在对String类型的对象进行改变的时候其实都等同于生成了一个新的String对象，然后将指针指向新的String对象，所以经常改变内容的字符串最好不要用String，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM的GC就会开始工作，那速度是一定会相当慢的。 StringBuffer所谓变量，即是可以随时变化的量。如果对StringBuffer对象进行改变，每次结果都会对StringBuffer对象进行操作，而不是生成新的对象。所以一般字符串要经常变化的话我推荐使用StringBuffer。 StringBuilderStringBuilder和StringBuffer类功能基本相似，方法也差不多，主要区别在于StringBuffer类的方法是多线程安全的，而StringBuilder不是线程安全的，相比而言StringBuilder类会略微快一点。 运行速度 Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。 而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。 但是，有时候我们会这样对字符串进行赋值: String str=&quot;abc&quot;+&quot;de&quot;; StringBuilder stringBuilder=new StringBuilder().append(&quot;abc&quot;).append(&quot;de&quot;); System.out.println(str); System.out.println(stringBuilder.toString()); 这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多 线程安全如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。 使用须知 String：适用于少量的字符串操作的情况 StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况 StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况 注意现在很多互联网公司面试java的面试官都喜欢问这样一个问题 请你谈谈StringBuffer和StringBuilder的区别。 大多数人肯定会直接说前者是线程安全的而后者是非线程安全的。其实这个时候才是面试官真正想问的，他会顺着你的回答又问你，那请你谈谈什么是线程…balabalabala。哈哈，要想顺利通过面试，所以对知识的了解还是全面点吧～！ 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习之监听器]]></title>
    <url>%2F2018%2F09%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[监听器(Listener)其实就是一个实现特定接口的普通java程序，监听器是一个专门用于对其他对象身上(三大域对象)发生的事件或状态改变进行监听和相应处理的对象，它可以监听客户端请求和服务端的操作，当被监视的对象发生情况时，立即采取相应的行动。这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法立即被执行。 上述概念设计到3个名词概念: 事件源:即谁产生的事件 事件对象:即产生了什么事件 监听器:监听事件源的动作 由于事件源可以产生多个动作(即产生多个事件)，而监听器中的每一个方法监听一个动作，故每个监听器中都有很多方法。 JavaWeb中的监听器的概念JavaWeb中的监听器是Servlet规范中定义的一种特殊类，它用于监听web应用程序中的ServletContext、HttpSession和 ServletRequest这三大域对象的创建、销毁事件以及监听这些域对象中的属性发生修改的事件。 其中，Java中的ServletContext对象对应JSP的application对象（上下文对象，由容器创建和初始化），HTTPSession对象对应JSP的session对象（保存上下文对象的机制，放在服务器端，通过sessionID区分的，服务器关闭和结束时销毁），ServletRequest对象（容器创建时创建的对象，来进行封装请求对象，同时还会创建ServletResponse对象）对应JSP中的request对象。 总而言之，就是监听这三个对象的创建销毁和属性的变化 JavaWeb中监听器的分类在Servlet规范中定义了多种类型的监听器(一共8个监听器)，它们用于监听的事件源分别为ServletContext，HttpSession和ServletRequest这三个域对象。Servlet规范针对这三个对象上的操作，又把多种类型的监听器划分为三种类型： 域对象的生命周期监听:监听域对象自身的创建和销毁。这个监听器需要实现相应的监听器接口:ServletContextListener(定时器和全局属性对象)、HttpSessionListener(统计在线人数和记录访问日志)、ServletRequestListener(读取参数和记录访问历史)。关于的ServletContext的Demo:在配置文件web.xml配置: &lt;param-name&gt;initParam&lt;/param-name&gt; &lt;param-value&gt;codingLembre&lt;/param-value&gt; 然后可以在实现ServletContextListener接口的类中可以获取到相应的配置: public void contextInitialized(ServletContextEvent sce) { sce.getServletContext().getInitParameter(&quot;initParam&quot;); 结合之前的过滤器的学习，由此我们也可以知道配置文件中的配置和对应的映射的接口实现类中的参数的一些微妙的关系，在此之前我一直不懂 域对象的属性监听:监听域对象中属性的增加和删除。这个监听器需要实现的监听器接口为:ServletContextAttributeListener、HttpSessionAttributeListener、ServletRequestAttributeListener 感知监听(监听绑定到HTTPSession域中的某个对象的状态的事件监听器):监听绑定到HttpSession域中的某个JavaBean对象的状态的监听器。这个监听器需要实现的监听器接口:HttpSessionBindingListener、HttpSessionActiveationListener 第一类:域对象的生命周期监听事件源为:三大域事件对象为:创建与销毁监听器为:实现了ServletContextListener、HttpSessionListener、ServletRequestListener这三个接口的监听器 ServletContext的生命周期监听public class AListener implements ServletContextListener{ public void contextInitialized(ServletContextEvent sce) { //在项目启动时调用 } public void contextDestroyed(ServletContextEvent sce) { //在项目关闭时调用 } } 需要在web.xml文件中进行配置: HttpSession的生命周期监听public class AListener implements HttpSessionListener{ public void sessionCreated(HttpSessionEvent sce) { //在会话产生时调用 } public void sessionDestroyed(HttpSessionEvent sce) { //在会话关闭时调用 } } 需要在web.xml文件中进行配置: ServletRequest的生命周期public class AListener implements ServletRequestListener{ public void requestInitialized(ServletRequestEvent sce) { //在请求产生时调用 } public void requestDestroyed(ServletRequestEvent sce) { //在请求关闭时调用 } } 需要在web.xml文件中进行配置: 对各个监听器接口的方法中出现的类介绍ServletContextEvent类:类中有一个方法getServletContext(),该方法返回ServletContext对象。HttpSessionEvent类:类中有一个方法getSession()，该方法返回一个HttpSession对象。ServletRequestEvent类:类中有两个方法，getServletContext()用于返回一个ServletContext对象，getServletRequest()用于返回一个ServletRequest对象。 第二类:域对象的属性监听事件源:三大域事件对象:属性的增加与删除监听器:实现了ServletContextAttributeListener、HttpSessionAttributeListener、ServletRequestAttributeListener接口的监听器 ServletContext的属性监听public class AListener implements ServletContextAttributeListener{ public void attributeAdded(ServletcontextAttribute scab){ //给ServletContext对象添加属性时调用 } public void attributeRemoved(ServletContextAttributeEvent scab){ //给ServletContext对象删除属性时调用 } public void attributeReplaced(ServletContextAttributeEvent scab){ //给ServletContext对象替换属性值时调用 } } 同样需要在web.xml文件中对AListener进行配置。 HttpSession的属性监听public class AListener implements HttpSessionAttributeListener{ public void attributeAdded(HttpSessionAttribute scab){ //给HttpSession对象添加属性时调用 } public void attributeRemoved(HttpSessionAttributeEvent scab){ //给HttpSession对象删除属性时调用 } public void attributeReplaced(HttpSessionAttributeEvent scab){ //给HttpSession对象替换属性值时调用 } } 同样需要在web.xml中对AListener进行配置。 ServletRequest的属性监听public class AListener implements ServletRequestAttributeListener{ public void attributeAdded(ServletRequestAttribute scab){ //给ServletRequest对象添加属性时调用 } public void attributeRemoved(ServletRequestAttributeEvent scab){ //给ServletRequest对象删除属性时调用 } public void attributeReplaced(ServletRequestAttributeEvent scab){ //给ServletRequest对象替换属性值时调用 } } 对各个监听器接口的方法中出现的类介绍ServletContextAttributeEvent类:该类对象有三个方法，getSevletContext()用于返回一个ServletContext，getName()用于返回属性名，getValue()用于返回属性值。 HttpSessionBindingEvent类:该类对象有两个方法，getName()用于获取属性名，getValue()用于获取属性值。 ServletRequestAttributeEvent类:该类对象有两个方法，getName()用于获取属性名，getValue()用于获取属性值。 感知监听器在此之前先了解一下Session对象的几种状态机制 绑定:Session对象持久化到存储设备中 解除绑定:Session对象从存储设备中回复 钝化机制:session过多，session在服务器内存中的开销将十分巨大，直接影响Web服务器的性能。此时，服务器自动将不常用的session将被序列化到系统文件或数据库中，使用时再由服务器自动反序列化到服务器内存中。这个机制由SessionManager管理，它的管理机制: 保存在Session域中的对象可以有多种状态：绑定(session.setAttribute(“bean”,Object))到Session中,随Session对象持久化到一个存储设备中；从Session域中解除(session.removeAttribute(“bean”))绑定,随Session对象从一个存储设备中恢复。 Servlet 规范中定义了两个特殊的监听器接口”HttpSessionBindingListener和HttpSessionActivationListener”来帮助JavaBean 对象了解自己在Session域中的这些状态，实现这两个接口的类不需要 web.xml 文件中进行注册。 HttpSessionBindingListener接口实现了HttpSessionBindingListener接口的JavaBean对象可以感知自己被绑定到Session中和 Session中删除的事件。 当对象被绑定到HttpSession对象中时，web服务器调用该对象的void valueBound(HttpSessionBindingEvent event)方法。 当对象从HttpSession对象中解除绑定时，web服务器调用该对象的void valueUnbound(HttpSessionBindingEvent event)方法。 public class JavaBeanDemo1 implements HttpSessionBindingListener { private String name; @Override public void valueBound(HttpSessionBindingEvent event) { System.out.println(name+&quot;被加到session中了&quot;); } @Override public void valueUnbound(HttpSessionBindingEvent event) { System.out.println(name+&quot;被session踢出来了&quot;); } public String getName() { return name; } public void setName(String name) { this.name = name; } public JavaBeanDemo1(String name) { this.name = name; } } 上述的JavaBeanDemo1这个javabean实现了HttpSessionBindingListener接口，那么这个JavaBean对象可以感知自己被绑定到Session中和从Session中删除的这两个操作。 HttpSessionActivationListener接口实现了HttpSessionActivationListener接口的JavaBean对象可以感知自己被活化(反序列化)和钝化(序列化)的事件。 当绑定到HttpSession对象中的javabean对象将要随HttpSession对象被钝化(序列化)之前，web服务器调用该javabean对象的void sessionWillPassivate(HttpSessionEvent event) 方法。这样javabean对象就可以知道自己将要和HttpSession对象一起被序列化(钝化)到硬盘中。 当绑定到HttpSession对象中的javabean对象将要随HttpSession对象被活化(反序列化)之后，web服务器调用该javabean对象的void sessionDidActive(HttpSessionEvent event)方法。这样javabean对象就可以知道自己将要和 HttpSession对象一起被反序列化(活化)回到内存中。(javabean随着HttpSession对象一起被活化的前提是该javabean对象除了实现该接口外还应该实现Serialize接口)。 public class JavaBeanDemo2 implements HttpSessionActivationListener, Serializable { private static final long serialVersionUID = 7589841135210272124L; private String name; @Override public void sessionWillPassivate(HttpSessionEvent se) { System.out.println(name+&quot;和session一起被序列化(钝化)到硬盘了，session的id是：&quot;+se.getSession().getId()); } @Override public void sessionDidActivate(HttpSessionEvent se) { System.out.println(name+&quot;和session一起从硬盘反序列化(活化)回到内存了，session的id是：&quot;+se.getSession().getId()); } public String getName() { return name; } public void setName(String name) { this.name = name; } public JavaBeanDemo2(String name) { this.name = name; } } ***如果某个类(ja888vabean对象)实现了HttpSessionActiveationListener接口后，当对象随着session被钝化和活化时，下面两个方法就会被调用 public void sessionWillPassivate(HttpSessionEvent se):当对象感知被活化时调用本方法。 public void sessionDidActivate(HttpSessionEvent se):当对象感知被钝化时调用本方法。 Servlet3.0新特性，注解监听器使用@WebListener，该注解用于将类声明为监听器，但是没有定义顺序的标识 这是使用注解和两个监听器实现的实时统计在线人数及IP信息github源代码 注意监听器的启动加载顺序和在web.xml中的注册顺序有关，当同时存在监听器，过滤器和Servlet时，加载顺序为: 监听域对象属性变化的实际应用待更新 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习之AJAX]]></title>
    <url>%2F2018%2F09%2F29%2FJavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8BAJAX%2F</url>
    <content type="text"><![CDATA[客户端向服务器发送请求，若服务器每次响应过来的结果都要重新加载整个界面的话这样会给服务器带来很大的压力。Ajax 不是某种编程语言，是一种在无需重新加载整个网页的情况下能够更新部分网页的技术。 AJAX概念 1.asynchronous javascript and xml，翻译过来就是异步的javascript和xml。 2.XMLhttpRequest对象来实现这一功能，也需要javascript来操作DOM实现局部的信息更新。 3.服务器给客户端的响应一般是整个页面，一个html完整页面但在ajax中因为是局部刷新，那么服务器就不用再响应整个页面而只是响应局部。 Ajax三步骤： 1、运用HTML和CSS实现页面，表达信息； 2、运用XMLHttpRequest和web服务器进行数据的异步交换； 3、运用JavaScript操作DOM，实现动态局部刷新； XHR对象是一个javascript对象，它可以在用户没有感觉的情况下，就像背后运行的一根小线程一般，悄悄的和服务器进行数据交互AJAX就是通过它做到无刷新效果的XHR对象的作用是和服务器进行交互，所以既会发消息给服务器，也能接受服务器返回的响应。当服务器响应回来的时候，调用怎么处理呢？通过 xmlhttp.onreadystatechange=checkResult 就可以指定用checkResult 函数进行处理 服务器向客户端返回的数据类型一般客户端向服务器发送请求，服务器返回的数据类型有三种: text类型:返回的数据是纯文本。 xml类型:返回的数据是xml格式，它是提供js和java交互的数据格式 json类型:它也是提供js和java交互的数据格式，在ajax中最受欢迎。 理解同步交互和异步交互 同步交互: 发一个请求，就要等待服务器的响应结束，然后才能发送第二个请求 刷新的是整个页面 异步交互: 发一个请求，无需等待服务器的响应，然后就可以发第二个请求。 可以使用js来接受服务器的响应，然后使用js来局部刷新界面。 附上uml图解释这两者的区别: ajax的优缺点 优点: 异步交互，增强了用户的体验。 性能:因为服务器无需再响应整个页面，只需要响应部分内容，所以服务器的压力减轻了 缺点: ajax不能应用在所有场景 ajax无端的增多了对服务器的访问次数，给服务器带来了压力(比较上述优点，在减少了服务器压力的同时又给服务器带来了压力，不知你理不理解哈哈) 得到XMLHttpRequest大多数浏览器都只是得到该对象的方法为:var xmlHttp=new XMLHttpRequest();IE6.0得到的方法为:var xmlHttp = new ActiveXObject(“Msxml2.XMLHTTP”);IE5.0以及更早版本的IE:var xmlHttp=new ActiveXObject(“Microsoft.XMLHTTP”);在&lt;script&gt;中编写创建XMLHttpRequest对象的函数: function createXMLHttpRequest(){ try{ return new XMLHttpRequest(); }catch(e){ try{ return new ActiveXObject(“Msxml2.XMLHTTP”); }catch(e){ try{ return new ActiveXObject(“Microsoft.XMLHTTP”); }catch(e){ alert(“哥们，你用的是什么浏览器啊”); throw e; } } }} 或者不用这么麻烦，直接: XMLHttpRequest发送请求XMLHttpRequest发送请求： open(method,url,async) method：规定HTTP发送请求的方式是get还是post,不区分大小写，一般来说用大写 url：请求地址(相对地址或绝对地址) async:同步/异步(false/true)，默认是异步也就是true，可以不用填写 - request.send(“name=xxxx&amp;set=xxx”); 这是在设置访问的页面8 send(string):发送到服务器（该参数可以填或者不填—–get方法不填或填null，post:一般要填） ，这是在执行访问 例如： request.open(“POST”,”create.php”,true); request.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded “)//设置HTTP头信息–一定要写在open()和send()之间 XMLHttpRequest取得响应监听readyState,响应成功可以做一些事情，比如获取服务器响应的内容在页面上做一些呈现例如: &lt;span&gt;输入账号 :&lt;/span&gt; &lt;input id=&quot;name&quot; name=&quot;name&quot; onkeyup=&quot;check()&quot; type=&quot;text&quot;&gt; &lt;span id=&quot;checkResult&quot;&gt;&lt;/span&gt; &lt;script&gt; var xmlhttp; function check(){ var name = document.getElementById(&quot;name&quot;).value; var url = &quot;http://how2j.cn/study/checkName.jsp?name=&quot;+name; xmlhttp =new XMLHttpRequest(); xmlhttp.onreadystatechange=checkResult; //响应函数 xmlhttp.open(&quot;GET&quot;,url,true); //设置访问的页面 xmlhttp.send(null); //执行访问 } function checkResult(){ if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) document.getElementById(&apos;checkResult&apos;).innerHTML=xmlhttp.responseText; } &lt;/script&gt; 或者另一种写法: xmlhttp.onreadystatechange=function(){ if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200){ //做一些事情（即响应） document.getElementById(&apos;checkResult&apos;).innerHTML=xmlhttp.responseText; } 第四步给xmlHttp对象注册onreadystatechange监听器，这个方法用于接收从服务器发送过来的响应数据。 在该方法中需要做以下步骤: 获取xmlHttp对象的状态，xmlHttp对象一共有5个状态: 0状态:表示xmlHttp对象刚创建，还没有调用open()方法。 1状态：请求开始，调用了open方法，但还没有调用send方法 调用完了send方法 服务器已经开始响应，但不表示响应结束了 服务器响应结束(通常我们只关心这个状态) 该状态通过调用xmlHttp.readyState得到。 得到服务器响应的状态码:通过调用xmlHttp.status得到，例如200，404，500。 得到服务器响应的内容，由于服务器返回的类型不同，所以得到的内容类型也不同，以下3种类型采用3种方法得到: var content=xmlHttp.responseText;//服务器返回的文本为text。 var content=xmlHttp.responseXML;//服务器响应的文本为xml内容。xmlHttp会自动对xml文本进行解析，得到的content为document对象。 var content=eval(“(“+xmlHttp.responsetext+”)”);//服务器返回的文本为json数据。完成第四步我们需要写的完整代码为: //xmlHttp的5种状态都会调用本方法xmlHttp.onreadystatechange=function(){if(xmlHttp.readState==4&amp;&amp;xmlHttp.status==200){//双重判断:判断是否为4状态，而且还要判断是否为200 //获取服务器的响应内容 var content=xmlHttp.responseText;//或var content= xmlHttp.responseXML;}} 案例:省市联动说明，该案例就是在网页上显示两个下拉列表，一个列表用于显示中国所有的省份，一个列表用于显示相应省份下的城市，当然这些数据是存在数据库中的，为了方便展示，我只在数据库中列举了两个省份和部分城市。servlet包下的CityServlet.java与ProvinceServlet.java，用于向客户端发送响应数据代码如下:dao包下的ProvinceDao.java代码如下:用于与数据库连接: 最终要的界面代码关于ajax的操作,代码如下:数据库中的表有两张，一张是省份表province,一张是城市表city,如下:结果如下:当选择了相应的省份时，ajax会立即向服务器发送请求，然后服务器返回该省份下所有的城市，ajax将这些城市动态的显示在”请选择城市”列表中。达到部分刷新界面的效果。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习之过滤器]]></title>
    <url>%2F2018%2F09%2F29%2FJavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[过滤器可以动态的拦截请求和响应，以变换或使用包含在请求或响应中的信息。过滤器是可用于Servlet编程的Java类，可以实现以下目的: 在客户端的请求访问后端资源之前，拦截这些请求。 在服务器的响应发送回客户端之前，处理这些响应。 当 Web 容器启动 Web 应用程序时，它会为你在部署描述符中声明的每一个过滤器创建一个实例。Filter的执行顺序与在web.xml配置文件中的配置顺序一致，一般把Filter配置在所有的Servlet之前 过滤器的工作原理 由此可知，过滤时跳转页面如果使用重定向的方式，那么会造成过滤死循环。所以要用重定向。因为一次请求就加载一次过滤器，而转发是服务器内部转发，是一次请求。 过滤器的生命周期 如何编写过滤器1.创建一个类，必须实现Filter接口2.在web.xml中进行配置，一般把Filter配置在所有的Servlet配置之前方法介绍: void init():Filter的初始化，Filter在服务器启动时就创建，创建之后马上执行这个方法。用来初始化一些参数 void doFilter(req,resp,chain):当向服务器请求的Servlet或jsp页面在过滤器的过滤范围内时,就会执行这个方法。若方法体中没有chain.doFilter()操作，则表示,当向服务器请求该过滤器过滤范围内的资源(如Servlet/JSP页面/html页面等)时，这些资源中的所有方法都不会执行(被过滤掉了);若方法体中有chain.doFilter()操作，表示不对过滤器过滤范围内的资源进行过滤。(即你请求的资源下的方法会执行) void destroy():在服务器关闭时对Filter进行销毁，在Filter销毁之前会执行这个方法，用来对非内存资源进行释放。 对方法中涉及到的类介绍: FilterConfig:与ServletConfig相似，该类有如下四个方法: getInitParameter():获取初始化参数。 getInitParameterNames():获取所有初始化参数的名称 getFilterName():获取过滤器的配置名称。 getServletContext():获取application。 FilterChain类:该类中有一个方法: doFilter():是不是会觉得该方法与Filter接口中的doFilter()方法是一样的呢？没错，二者虽然外观看起来一样，但功能却是千差万别的。该方法被FilterChain对象调用，表示对Filter过滤器过滤范围下的资源进行放行。 多过滤器的执行顺序Web应用程序可以根据特定的目的定义若干个不同的过滤器，那么就需要在web.xml中对多个过滤器进行多个配置。而在web.xml中使用来控制多个过滤器的执行顺序，即哪个过滤器的配置在web.xml中的顺序排在前面那这个过滤器就先执行。 过滤器的四种拦截方式 拦截直接请求方式:REQUEST 拦截请求转发方式:FORWARD 拦截请求包含方式:INCLUDE 拦截错误转发方式:ERROR 实现不同的拦截方式需要在中进行不同的配置: REQUEST FORWORD INCLUDE ERROR 若在web.xml配置文件中没有写出上面四个拦截配置时默认该过滤器只拦截请求 过滤器的应用场景1.执行目标资源之前做”预处理”工作，例如设置编码，这种通常都会放行，只是在目标资源执行之前做一些准备工作。(例如：几乎是所有的Servlet中都需要写request.setCharacteEncoding(),可以把它放入到一个Filter中。）这种过滤器没有拦截功能。2.通过条件判断是否放行，例如校验当前用户是否已经登录，或者用户IP是否已经被禁用。(有拦截操作) (粗粒度权限控制，会员有会员的权利、游客有游客的权利)。3.在目标资源执行后，做一些后续的特殊处理工作。例如把目标资源输出的数据进行处理。 案例1:分IP统计网站的访问次数功能分析:1.统计工作需要在所有资源之前都执行，那么就可以放到Filter中了。2.我们这个过滤器不打算做拦截操作，因为我们只是用来做统计的。3.用什么东西来装载统计的数据。Map，整个网站只需要一个Map即可4.Map什么时候创建(使用ServletContextListener，在服务器启动时完成创建，并保存到SevletContext中)，Map保存到哪里:Map需要在Filter中用来保存数据;Map需要在页面使用，打印Map中的数据。 AListener.java:AFilter.java:show.jsp: 案例2:解决全站字符乱码问题对于通过jsp页面请求转发到servlet时，若请求方式为POST且请求参数包含中文参数时，我们需要在servlet的doPost()方法中设置POST请求编码问题:request.setCharacterEncoding(“utf-8”);、设置响应编码问题:response.setContentType(“text/html;charset=utf-8”);,这样便可以解决post请求即响应编码问题； 而对于GET请求，若传递的请求参数包含中文参数时设置请求编码就比较麻烦，需要在servlet的doGet()方法中设置响应编码:response.setContentType(“text/html;charset=utf-8”);以及请求编码:首先获得传递给servlet的请求参数:String username=request.getParameter(“username”)假设传递的请求参数为username,然后再输入代码username=new String(username.getBytes(“ISO8859-1”),”utf-8”);，这样通过jsp页面转发到servlet的参数便解决了编码问题。即可以通过response.getWrite().prinltn(username)正常显示在网页上。 试想:以后的开发中往往会用到很多的servlet，那我们岂不是要在每一个servlet的doPost()和doGet方法中都写上上述的解决编码代码？这时候我们就可以通过过滤器来解决了 首先附上页面: &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;&lt;c:url value=&quot;/AServlet?username=张三&quot;/&gt; &quot;&gt;点击这里&lt;/a&gt; &lt;form action=&quot;&lt;c:url value=&quot;/AServlet&quot;/&gt; &quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;李四&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 通过”点击这里”的链接我们便完成了通过jsp页面向servlet发送GET请求参数，通过”提交”按钮我们便完成了通过jsp页面向servlet发送POST请求参数。创建一个servlet,我们在servlet中完成响应参数编码的问题 public class AServlet extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html;charset=utf-8&quot;); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html;charset=utf-8&quot;); } } 接下来在过滤器中完成请求参数编码的问题，创建一个过滤器Filter，在web.xml中注册: &lt;filter&gt; &lt;filter-name&gt;Filter&lt;/filter-name&gt; &lt;filter-class&gt;filter.Filter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; Filter中编码为: public class Filter implements javax.servlet.Filter { public void destroy() { } public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { } public void init(FilterConfig config) throws ServletException { } } 对于POST请求参数的编码设置我们直接在doFilter()方法体中添加request.setCharacterEncoding(“utf-8”);代码即可(此时运行程序，POST请求参数编码的问题成功解决)，对于GET请求参数的编码，有些同学会觉得直接在doFilter()方法体中添加 String username=request.getParameter(“username”);username=new String(username.getBytes(“ISO-8859-1”),”utf-8”); 这样的参数是不太靠谱的，因为这里我们知道要传递的请求参数为username所以这里可以明了的指出，以后我们不知道请求参数为什么或者请求参数有很多时那就需要更多的上诉代码，所以这里我们采用装饰者模式对request进行装饰，这就是装饰者模式(即将本来的request换成我们自己写的request)，创建一个EncodingRequest.java继承HttpServletRequestWrapper,代码如下: public class EncodingRequest extends HttpServletRequestWrapper { private HttpServletRequest req; public EncodingRequest(HttpServletRequest request) { super(request); this.req=request; } @Override public String getParameter(String name) { String value=req.getParameter(name); //处理编码问题 try { value=new String(value.getBytes(&quot;ISO-8859-1&quot;),&quot;utf-8&quot;); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return value; } } 在构造方法中，我们传入系统的request,然后将这个request赋值给我们自己编写的req,然后在重写的getParameter()方法中通过我们自己写的req获取请求参数并解决编码问题，然后返回解决完编码后的参数value(此时这个中文参数已解决编码),然后在Filer中对我们自己编写的request(即Encodingquest对象)放行即可。现在doFilter()方法的方法体为: public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { //处理post请求编码问题 request.setCharacterEncoding(&quot;utf-8&quot;); HttpServletRequest req= (HttpServletRequest) request; /** * 处理get请求的编码问题 */ // String username=request.getParameter(&quot;username&quot;); // username=new String(username.getBytes(&quot;ISO-8859-1&quot;),&quot;utf-8&quot;); /** * 调包request * 1.写一个request的装饰类 * 2.在放行时，使用我们自己的request */ EncodingRequest er = new EncodingRequest(req); chain.doFilter(er, response); } 在学习框架之前我们都这样通过Filter解决编码问题，而当我们学习了Spring MVC框架后我们处理POST请求参数的编码问题时直接在web.xml中添加如下配置而不用再写一个过滤器: &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 解决GET请求方式的编码问题时有两种解决方法:1.修改tomcat配置文件添加编码与工程编码一致，如下: 2.对参数进行重新编码: String userName new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;) 第二种方法需要对每个参数都进行重新编码，比较麻烦。回归我们的过滤器讲解，通过如上包装request的方式便可以通过过滤器解决全站编码问题。 案例3登录和编码转换整合案例首先看代码:LoginServlet.java public class LoginServlet extends HttpServlet { public LoginServlet() { super(); } public void destroy() { super.destroy(); // Just puts &quot;destroy&quot; string in log // Put your code here } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(username); if(&quot;admin&quot;.equals(username) &amp;&amp; &quot;admin&quot;.equals(password)){ //检验通过 HttpSession session = request.getSession(); session.setAttribute(&quot;username&quot;, username); response.sendRedirect(request.getContextPath()+&quot;/sucess.jsp&quot;); }else{ //校验失败 response.sendRedirect(request.getContextPath()+&quot;/fail.jsp&quot;); } } public void init() throws ServletException { // Put your code here }} LoginFilter.java public class LoginFilter implements Filter { private FilterConfig config; @Override public void destroy() { } @Override public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) arg0; HttpServletResponse response = (HttpServletResponse) arg1; HttpSession session = request.getSession(); String noLoginPaths = config.getInitParameter(&quot;noLoginPaths&quot;); String charset = config.getInitParameter(&quot;charset&quot;); if(charset==null){ charset = &quot;UTF-8&quot;;//如果没有指定charset的话，将charset设置为UTF-8 } request.setCharacterEncoding(charset); if(noLoginPaths!=null){ String[] strArray = noLoginPaths.split(&quot;;&quot;); for (int i = 0; i &lt; strArray.length; i++) { if(strArray[i]==null || &quot;&quot;.equals(strArray[i]))continue; if(request.getRequestURI().indexOf(strArray[i])!=-1 ){ arg2.doFilter(arg0, arg1); return; } } } if(session.getAttribute(&quot;username&quot;)!=null){ arg2.doFilter(arg0, arg1);//已经存在session对象了，允许通过过滤器 }else{ response.sendRedirect(&quot;login.jsp&quot;);//防止任何人通过直接输入相对应的登录成功地网址都直接访问这个页面。除非是本人而且浏览器没关闭过 } } @Override public void init(FilterConfig arg0) throws ServletException { config = arg0;//怎么得到这个初始化参数呢？参数指的是&lt;param-name&gt;noLoginPaths&lt;/param-name&gt; //&lt;param-value&gt;login.jsp;fail.jsp;LoginServlet&lt;/param-value&gt; } web.xml &lt;servlet&gt; &lt;description&gt;This is the description of my J2EE component&lt;/description&gt; &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/LoginServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;LoginFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.LoginFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;noLoginPaths&lt;/param-name&gt; &lt;param-value&gt;login.jsp;fail.jsp;LoginServlet&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;charset&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;LoginFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; &lt;!-- &lt;init-param&gt; &lt;param-name&gt;noLoginPaths&lt;/param-name&gt; &lt;param-value&gt;login.jsp;fail.jsp;LoginServlet&lt;/param-value&gt; &lt;/init-param&gt;这里是配置不过滤的路径 --&gt; 本来未配置初始化参数时的写法:但是随着需要忽略过滤路径写法的页面越来越多，这种写法特别麻烦，不符合java开发原则，因此应该改用配置参数的写法，这里注意一下。 点击获取github源代码 异步过滤器待更新 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之反射机制]]></title>
    <url>%2F2018%2F09%2F29%2FJava%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[通俗地说,反射机制就是可以把一个类,类的成员(函数,属性),当成一个对象来操作,希望读者能理解,也就是说,类,类的成员,我们在运行的时候还可以动态地去操作他们。反射机制的利用其实我们经常在用，比如数据库JDBC中通过Class.forName(Driver).来获得数据库连接驱动；再比如，工厂模式：Factory类中用反射的话，添加了一个新的类之后，就不需要再修改工厂类Factory；访问一些不能访问的变量或属性：破解别人代码。 万物皆对象，那么类也是对象？所有的类都是java.lang.Class类的实例对象,这个类的对象称为类的类类型。这个类的构造方法是一个私有方法这个类的实例对象该如何表示呢？ Class类的三种表示方式:1.利用任何一个类都隐含有一个静态成员变量class。 Class c1 = A.class;2.已知该类的实例对象 Class c1 = a.getClass(): 3.Class c1 = Class.forName(“类的全称”); 我们可以通过类的类类型创建该类的对象实例,但是前提是Foo类有无参的构造方法 Foo foo = (Foo)c1.newInstance(); Java动态加载类区分静态加载类和动态加载类:编译时刻加载类是静态加载类，运行时刻加载类是动态加载类: new对象是静态加载类，在编译时刻就需要加载所有可能使用到的类动态加载类和静态加载类的区别:可以理解为装修房子(编译)买电器,我之前计划的有电视冰箱洗衣机,全都随着装修安装完毕了(静态加载),之后呢(运行),觉得少个微波炉,可是根本就没有规划微波炉的线路,那么就需要拆掉原先的线路为新的电器设置安装.而现在我不想那么麻烦,就在装修的时候预留好电源插座这种接口(interface),只要所有的电器都实现了这个接口,有了两孔或者三孔的插头,那么我后期想增添任何电器都可以随时增加(动态加载) Java获取方法信息 Java获取成员变量的信息成员变量也是对象，java.lang.reflect.Field，Filed类封装了关于成员变量的所有操作。构造函数也是对象，java.lang.Constructor封装了构造函数的信息 方法的反射:1.如如何获取某个方法:方法的名称和方法的参数列表才能唯一决定某个方法2.方法反射的操作:method.invoke(对象，参数列表) Demo： public Class A{ public void print(){}; public void Print(Sting a,String b){}; public void Print(int a,int b){}; } public Class B{ public static void main(String[] args){ A a1 = new A(); Class c= a1.getclass; Method getMet=c.getMethod(&quot;print&quot;,String.class,String.class); Object obj=getMet.invoke(a1,&quot;df&quot;,&quot;df&quot;); } } 理论介绍为了便于理解，在给出代码例子之前，首先用文字给大家说说关于”Java反射机制”的理论介绍。Java反射是Java语言的一个很重要的特征，它使得Java具有了“动态性”。在Java运行时环境中，对于一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？答案是肯定的。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java语言的反射(Reflection)机制。 Java反射机制提供的功能 在运行时判断任意一个对象所属的类。 在运行时构造任意一个类的对象。 在运行时判断任意一个类所具有的成员变量和方法。 在运行时调用任意一个对象的方法。 Reflection是Java被视为动态(或准动态)语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，包括modifiers(诸如public,static等等)、superclass(例如Object)、实现之interfaces(例如Serializable)，也包括fields和methods的所有信息，并可于运行时改变fields内容或调用methods。 一般而言，开发者社群说到动态语言，大致认同的一个定义是:“程序运行时，允许改变程序结构或变凉类型，这种语言成为动态语言”。从这个观点看，Java就不是动态语言。 尽管在这样的定义与分类下Java不是动态语言，它却有着一个非常突出的动态相关机制:Reflection。这个字的意思是“反射、映像、倒影”，用在Java身上指的是我们可以于运行时加载、探知、使用编译器件完全未知的classes。换句话说，Java程序可以加在一个运行时才得知名称的class，获悉其完整构造(但不包括methods定义)，并生成其对象实体、或对其fields设值、或唤起其methods。这种“看透class”的能力(the ability of the program to examine itselt)被称为introspection(内省、内观、反省)。Reflection和introspection是常被并提的两个术语。 Java反射机制的API Class类：代表一个类。 field类：代表类的成员变量(成员变量也被称为类的属性) Method类：代表类的方法 Constructor类：代表类的构造方法。 Array类：提供了动态创建数组，以及访问数组的元素的静态方法。 获得Class对象Java中每个类被加载之后，系统就会为该类生成一个对应的Class对象，通过该Class对象就可以访问到JVM中的这个类。在Java程序中获得Class对象通常有如下三种方式。 1.使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定类名(必须包括完整包名)。 代码示例：Class clazz=Class.forName(“demo.Person”);”Demo”代表包名，”Person”代表类名。 2.调用某个类的class属性来获取该类对应的Class对象，例如，Person.class将会返回Person类对应的Class对象 代码示例：Class clazz=Person.class; 3.调用某个对象的getClass()方法，该方法是java.lang.Object类中的一个方法，所以所有的Java对象都可以调用该方法，该方法将会返回该对象所属类对应的Class对象。 代码示例:Person person=new Person();Class clazz=person.getClass(); Class对象可以获得该类里的方法(由Method对象表示)、构造器(由Constructor对象表示)、成员变量(由Field)对象表示，这三个类都位于java.lang.reflect包下并实现了java.lang.reflect.Member接口。程序可以通过Method对象来执行对应的方法，通过Constructor对象来调用对应的构造器创建实例，能通过Field对象直接访问并修改对象的成员变量值。 创建实例对象通过反射来生成实例对象有如下两种方式。 1.使用Class对象的newInstance()方法来创建该Class对应类的实例，这种方式要求该Class对象的对应类有默认构造器，而执行newInstance()时实际上是利用默认构造器来创建该类的实例。 代码示例:Class clazz=Person.class;Object obj=clazz.newInstance(); 先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例。通过这种方式可以选择使用指定的构造器来创建实例。 代码示例:Class clazz=Person.class;Constructor constructor=clazz.getConstructor(String.class);Object obj=constructor.newInstance(); 请看，示例:一个例子让你了解Java反射机制 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习笔记之JSTL标签库]]></title>
    <url>%2F2018%2F09%2F29%2FJavaWeb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BJSTL%E6%A0%87%E7%AD%BE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[JSTL标签库介绍JSTL标签库的使用是为弥补html标签的不足，规范自定义标签的使用而诞生的。使用JSLT标签的目的就是不希望在jsp页面中出现java逻辑代码。JSTL也是对EL表达式的扩展(也就是说JSTL依赖EL)，是一门标签语言。JSTL标签使用起来非常方便，它与JSP动作标签一样，只不过它不是JSP内置的标签，需要我们自己导包，一定要指定标签库。 如果你使用MyEclipse开发JavaWeb，那么把项目发布到Tomcat时，你会发现MyEclipse在lib目录下自动存放了JSTL的Jar包。如果你使用其他IDE，那么你需要手动导入这个JSTL的Jar包:jstl-1.2.jar。 JSTL标签库的分类 core:核心标签库(用得最多) fmt:国际化标签库(只需学习两个，日期和数字) sql:数据库标签库(过时了，不需要学习) xml:xml标签库(过时了，不需要学习) 核心标签库使用说明JSTL的核心标签库标签共13个，使用这些标签能够完成JSP页面的基本功能，减少编码工作。从功能上可以分为4类:表达式控制标签、流程控制标签、循环标签、URL操作标签。 表达式控制标签:out标签、set标签、remove标签、catch标签 流程控制标签:if标签、choose标签、when标签、otherwise标签 循环标签:forEach标签、forTokens标签 URL操作标签 在JSP页面引入核心标签库的代码为: &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 表达式控制标签——out标签使用&lt;c:out&gt;标签的功能&lt;c:out&gt;标签主要是用来输出数据对象(字符串、表达式)的内容或结果。在使用Java脚本输出时常使用的方式为:&lt;% out.println(“字符串”); %&gt;或者&lt;%=表达式 %&gt;，在web开发中，为了避免暴露逻辑代码会尽量减少页面中的Java脚本，使用&lt;c:out&gt;标签就可以实现以上功能。 &lt;c:out value=&quot;字符串&quot;/&gt;或者&lt;c:out value=&quot;EL表达式&quot;/&gt; JSTL的使用是和EL表达式分不开的，EL表达式虽然可以直接将结果返回给页面，但有时得到的结果为空，&lt;c:out&gt;有特定的结果处理功能，EL的单独使用会降低程序的易读性，建议把EL的结果输入放入&lt;c:out&gt;标签中。 &lt;c:out&gt;标签的语法&lt;c:out&gt;标签的使用有两种语法格式: 语法1:&lt;c:out value=”要显示的数据对象” [escapeXml=”true|false”][default=”默认值”]/&gt; 语法2:&lt;c:out value=”要显示的数据对象” [escapeXml=”true|false”]&gt;默认值&lt;/c:out&gt; 这两种方式没有本质的区别，只是格式上的差别。[escapeXml=”true|false”][defult=”默认值”]这些使用[]属性表示是不是必须的。 &lt;c:out&gt;标签的属性 default 指定如果value属性的值为null时所输出的默认值注意，这个会直接输出到页面，不管你有没有把他放到table标签中。和&lt;% out.println(“字符串”)的效果一样。 &lt;c:out&gt;标签的使用范例&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%--引入JSTL核心标签库 --%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;JSTL: --表达式控制标签“out”标签的使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;&lt;c:out value=&quot;下面的代码演示了c:out的使用，以及在不同属性值状态下的结果。&quot;/&gt;&lt;/h3&gt; &lt;hr/&gt; &lt;ul&gt; &lt;%--（1）直接输出了一个字符串。 --%&gt; &lt;li&gt;（1）&lt;c:out value=&quot;JSTL的out标签的使用&quot; /&gt;&lt;/li&gt; &lt;li&gt;（2）&lt;c:out value=&quot;&lt;a href=&apos;http://www.cnblogs.com/&apos;&gt;点击链接到博客园&lt;/a&gt;&quot; /&gt;&lt;/li&gt; &lt;%--escapeXml=&quot;false&quot;表示value值中的html标签不进行转义，而是直接输出 --%&gt; &lt;li&gt;（3）&lt;c:out value=&quot;&lt;a href=&apos;http://www.cnblogs.com/&apos;&gt;点击链接到博客园&lt;/a&gt;&quot; escapeXml=&quot;false&quot;/&gt;&lt;/li&gt; &lt;%--(4）字符串中有转义字符，但在默认情况下没有转换。 --%&gt; &lt;li&gt;（4）&lt;c:out value=&quot;&amp;lt未使用字符转义&amp;gt&quot; /&gt;&lt;/li&gt; &lt;%--（5）使用了转义字符&amp;lt和&amp;gt分别转换成&lt;和&gt;符号。 --%&gt; &lt;li&gt;（5）&lt;c:out value=&quot;&amp;lt使用字符转义&amp;gt&quot; escapeXml=&quot;false&quot;&gt;&lt;/c:out&gt;&lt;/li&gt; &lt;%--（6）设定了默认值，从EL表达式${null}得到空值，所以直接输出设定的默认值。 --%&gt; &lt;li&gt;（6）&lt;c:out value=&quot;${null}&quot;&gt;使用了默认值&lt;/c:out&gt;&lt;/li&gt; &lt;%--（7）未设定默认值，输出结果为空。 --%&gt; &lt;li&gt;（7）&lt;c:out value=&quot;${null}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt; &lt;%--（8）设定了默认值，从EL表达式${null}得到空值，所以直接输出设定的默认值。 --%&gt; &lt;li&gt;（8）&lt;c:out value=&quot;${null}&quot; default=&quot;默认值&quot;/&gt;&lt;/li&gt; &lt;%--（9）未设定默认值，输出结果为空。 --%&gt; &lt;li&gt;（9）&lt;c:out value=&quot;${null}&quot;/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 运行结果如下: 表达式控制标签——set标签的使用&lt;c:set&gt;标签的功能&lt;c:set&gt;标签用于把某一个对象存在指定的域范围内，或者将某一个对象存储到Map或者JavaBean对象中。 &lt;c:set&gt;标签的语法&lt;c:set&gt;标签的编写共有4种语法格式。 语法1:存值，把一个值放在指定的域范围内.&lt;c:set value=”值1” var=”name1” [scope=”page|request|session|application”]/&gt;含义:把一个变量名为name1值为“值1”的变量存储在指定的scope范围内。 语法2:&lt;c:set var=”name2” [scope=”page|request|session|application”]&gt;值2&lt;/c:set&gt;含义：把一个变量名为name2，值为值2的变量存储在指定的scope范围内 语法3: &lt;c:set value=”值3” target=”JavaBean对象” property=”属性名”/&gt;含义:把一个值为“值3”赋值给指定的JavaBean的属性名。相当与setter()方法 语法4: &lt;c:set target=”JavaBean对象” property=”属性名”&gt;值4&lt;/c:set&gt;含义：把一个值4赋值给指定的JavaBean的属性名 从功能上分语法1和语法2、语法3和语法4的效果是一样的，只是把value值放置的位置不同，至于使用那个根据个人的喜爱，语法1和语法2是向scope范围内存储一个值，语法3和语法4是给指定的JavaBean赋值。 &lt;c:set&gt;标签的属性 注意，有的属性并不支持EL表达式 &lt;c:set&gt;标签的使用范例&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%--引入JSTL核心标签库 --%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; %--使用JSP的指令元素指定要使用的JavaBean --%&gt; &lt;jsp:useBean id=&quot;person&quot; class=&quot;javabean.Person&quot;/&gt; &lt;%--负责实例化Bean，id指定实例化后的对象名，可以通过${person}得到person在内存中的值（或者使用person.toString()方法）。 --%&gt; &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;JSTL: --表达式控制标签“set”标签的使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;代码给出了给指定scope范围赋值的示例。&lt;/h3&gt; &lt;ul&gt; &lt;%--通过&lt;c:set&gt;标签将data1的值放入page范围中。--%&gt; &lt;li&gt;把一个值放入page域中:&lt;c:set var=&quot;data1&quot; value=&quot;xdp&quot; scope=&quot;page&quot;/&gt;&lt;/li&gt; &lt;%--ta使用EL表达式从pageScope得到da1的值。--%&gt; &lt;li&gt;从page域中得到值：${pageScope.data1}&lt;/li&gt; &lt;%--通过&lt;c:set&gt;标签将data2的值放入request范围中。--%&gt; &lt;li&gt;把一个值放入request域中:&lt;c:set var=&quot;data2&quot; value=&quot;gacl&quot; scope=&quot;request&quot;/&gt;&lt;/li&gt; &lt;%--使用EL表达式从requestScope得到data2的值。--%&gt; &lt;li&gt;从request域中得到值：${requestScope.data2}&lt;/li&gt; &lt;%--通过&lt;c:set&gt;标签将值name1的值放入session范围中。--%&gt; &lt;li&gt;把一个值放入session域中。&lt;c:set value=&quot;孤傲苍狼&quot; var=&quot;name1&quot; scope=&quot;session&quot;&gt;&lt;/c:set&gt;&lt;/li&gt; &lt;%--使用EL表达式从sessionScope得到name1的值。--%&gt; &lt;li&gt;从session域中得到值:${sessionScope.name1} &lt;/li&gt; &lt;%--把name2放入application范围中。 --%&gt; &lt;li&gt;把一个值放入application域中。&lt;c:set var=&quot;name2&quot; scope=&quot;application&quot;&gt;白虎神皇&lt;/c:set&gt;&lt;/li&gt; &lt;%--使用EL表达式从application范围中取值，用&lt;c:out&gt;标签输出使得页面规范化。 --%&gt; &lt;li&gt;使用out标签和EL表达式嵌套从application域中得到值： &lt;c:out value=&quot;${applicationScope.name2}&quot;&gt;未得到name的值&lt;/c:out&gt; &lt;/li&gt; &lt;%--不指定范围使用EL自动查找得到值 --%&gt; &lt;li&gt;未指定scope的范围，会从不同的范围内查找得到相应的值：${data1}、${data2}、${name1}、${name2}&lt;/li&gt; &lt;/ul&gt; &lt;hr/&gt; h3&gt;使用Java脚本实现以上功能&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;把一个值放入page域中。&lt;%pageContext.setAttribute(&quot;data1&quot;,&quot;xdp&quot;);%&gt;&lt;/li&gt; &lt;li&gt;从page域中得到值:&lt;%out.println(pageContext.getAttribute(&quot;data1&quot;));%&gt;&lt;/li&gt; &lt;li&gt;把一个值放入request域中。&lt;%request.setAttribute(&quot;data2&quot;,&quot;gacl&quot;);%&gt;&lt;/li&gt; &lt;li&gt;从request域中得到值:&lt;%out.println(request.getAttribute(&quot;data2&quot;));%&gt;&lt;/li&gt; &lt;li&gt;把一个值放入session域中。&lt;%session.setAttribute(&quot;name1&quot;,&quot;孤傲苍狼&quot;);%&gt;&lt;/li&gt; &lt;li&gt;从session中域得到值:&lt;%out.println(session.getAttribute(&quot;name1&quot;));%&gt;&lt;/li&gt; &lt;%--out.println()方法与&lt;%=%&gt;表达式输出功能一样 但使用表达式输出（&lt;%=%&gt;）明显要比使用out.println()输出更好。 --%&gt; &lt;li&gt;&lt;%=session.getAttribute(&quot;name1&quot;) %&gt;&lt;/li&gt; &lt;li&gt;把另一个值放入application域中。&lt;%application.setAttribute(&quot;name2&quot;,&quot;白虎神皇&quot;);%&gt;&lt;/li&gt; &lt;li&gt; 从application域中得到值：&lt;%out.println(application.getAttribute(&quot;name2&quot;));%&gt;&lt;/li&gt; &lt;li&gt;&lt;%=application.getAttribute(&quot;name2&quot;)%&gt;&lt;/li&gt; &lt;li&gt;未指定scope的范围，会从不同的范围内查找得到相应的值： &lt;%=pageContext.findAttribute(&quot;data1&quot;)%&gt;、 &lt;%=pageContext.findAttribute(&quot;data2&quot;)%&gt;、 &lt;%=pageContext.findAttribute(&quot;name1&quot;)%&gt;、 &lt;%=pageContext.findAttribute(&quot;name2&quot;)%&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr/&gt; &lt;h3&gt;操作JavaBean，设置JavaBean的属性值&lt;/h3&gt; %--设置JavaBean的属性值，等同与setter方法，Target指向实例化后的对象，property指向要插入值的参数名。 注意：使用target时一定要指向实例化后的JavaBean对象，也就是要跟&lt;jsp:useBean&gt;配套使用， 也可以java脚本实例化，但这就失去了是用标签的本质意义。 使用Java脚本实例化： &lt;%@page import=&quot;javabean.Person&quot;% &lt;% Person person=new Person(); %&gt; --%&gt; &lt;c:set target=&quot;${person}&quot; property=&quot;name&quot;&gt;孤傲苍狼&lt;/c:set&gt; c:set target=&quot;${person}&quot; property=&quot;age&quot;&gt;25&lt;/c:set&gt; &lt;c:set target=&quot;${person}&quot; property=&quot;sex&quot;&gt;男&lt;/c:set&gt; &lt;c:set target=&quot;${person}&quot; property=&quot;home&quot;&gt;中国&lt;/c:set&gt; &lt;ul&gt; &lt;li&gt;使用的目标对象为：${person}&lt;/li&gt; &lt;li&gt;从Bean中获得的name值为：&lt;c:out value=&quot;${person.name}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt; &lt;li&gt;从Bean中获得的age值为：&lt;c:out value=&quot;${person.age}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt; &lt;li&gt;从Bean中获得的sex值为：&lt;c:out value=&quot;${person.sex}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt; &lt;li&gt;从Bean中获得的home值为：&lt;c:out value=&quot;${person.home}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt; &lt;/ul&gt; &lt;hr/&gt; &lt;h3&gt;操作Map&lt;/h3&gt; &lt;% Map map = new HashMap(); request.setAttribute(&quot;map&quot;,map); %&gt; &lt;%--将data对象的值存储到map集合中 --%&gt; &lt;c:set property=&quot;data&quot; value=&quot;gacl&quot; target=&quot;${map}&quot;/&gt; ${map.data} &lt;/body&gt; &lt;/html&gt; 运行结果如下: 表达式控制标签——remove标签的使用&lt;c:remove&gt;标签的功能&lt;c:remove&gt;标签主要用来从指定的JSP范围内移除指定的变量。 &lt;c:remove&gt;标签的语法&lt;c:remove var=”变量名” [scope=”page|request|session|application”]/&gt;其中var属性是必须的，scope可以以省略。 &lt;c:remove&gt;标签的使用范例&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; %--引入JSTL核心标签库 --%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;JSTL: --表达式控制标签“remove”标签的使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;c:set var=&quot;name&quot; scope=&quot;session&quot;&gt;孤傲苍狼&lt;/c:set&gt; &lt;c:set var=&quot;age&quot; scope=&quot;session&quot;&gt;25&lt;/c:set&gt; &lt;li&gt;&lt;c:out value=&quot;${sessionScope.name}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt; &lt;li&gt;&lt;c:out value=&quot;${sessionScope.age}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt; &lt;%--使用remove标签移除age变量 --%&gt; &lt;c:remove var=&quot;age&quot; /&gt; &lt;li&gt;&lt;c:out value=&quot;${sessionScope.name}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt; &lt;li&gt;&lt;c:out value=&quot;${sessionScope.age}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 运行结果如下: 表达式控制标签——catch标签的使用&lt;c:catch&gt;标签的功能&lt;c:catch&gt;标签用于捕获嵌套在标签体中的内容抛出的异常。 &lt;c:catch&gt;标签的语法其语法格式如下：&lt;c:catch [var=”varName”]&gt;容易产生异常的代码&lt;/c:catch&gt;var属性用于标识&lt;c:catch&gt;标签捕获的异常对象，它将保存在page这个Web域中。 &lt;c:catch&gt;标签的使用范例&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%--引入JSTL核心标签库 --%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;JSTL: --表达式控制标签“catch”标签实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h4&gt;catch标签实例&lt;/h4&gt; &lt;hr&gt; &lt;%--把容易产生异常的代码放在&lt;c:catch&gt;&lt;/c:catch&gt;中，自定义一个变量errorInfo用于存储异常信息 --%&gt; &lt;c:catch var=&quot;errorInfo&quot;&gt; &lt;%--实现了一段异常代码，向一个不存在的JavaBean中插入一个值--%&gt; &lt;c:set target=&quot;person&quot; property=&quot;hao&quot;&gt;&lt;/c:set&gt; &lt;/c:catch&gt; &lt;%--用EL表达式得到errorInfo的值，并使用&lt;c:out&gt;标签输出 --%&gt; 异常：&lt;c:out value=&quot;${errorInfo}&quot; /&gt;&lt;br/&gt; 异常 errorInfo.getMessage：&lt;c:out value=&quot;${errorInfo.message}&quot; /&gt;&lt;br /&gt; 异常 errorInfo.getCause：&lt;c:out value=&quot;${errorInfo.cause}&quot; /&gt;&lt;br /&gt; 异常 errorInfo.getStackTrace：&lt;c:out value=&quot;${errorInfo.stackTrace}&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 运行代码如下: 流程控制标签——if标签使用总结&lt;c:if&gt;标签的功能&lt;c:if&gt; 标签和程序中的if语句作用相同，用来实现条件控制。 &lt;c:if&gt;标签的语法 语法1:没有标签体内容:&lt;c:if test=”testCondition” var=”varName” [scope=”{page|request|session|application}”]/&gt; 语法2: 有标签体内容。&lt;c:if test=”testCondition” [var=”varName”] [scope=”{page|request|session|application}”]&gt;标签体内容。&lt;/c:if&gt; 参数说明: test属性用于存放判断的条件，一般使用EL表达式来编写。 var属性用来存放判断的结果，类型为true或false，即把值放在这个变量中 scopes属性用来指定var属性存放的范围。 &lt;c:if&gt;标签的属性 &lt;c:if&gt;标签的使用范例。&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%--引入JSTL核心标签库 --%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;JSTL: --流程控制标签 if标签示例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h4&gt;if标签示例&lt;/h4&gt; &lt;hr&gt; &lt;form action=&quot;JSTL_if_tag.jsp&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;uname&quot; value=&quot;${param.uname}&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt; &lt;%--使用if标签进行判断并把检验后的结果赋给adminchock，存储在默认的page范围中。 --%&gt; &lt;c:if test=&quot;${param.uname==&apos;admin&apos;}&quot; var=&quot;adminchock&quot;&gt; &lt;%--可以把adminchock的属性范围设置为session，这样就可以在其他的页面中得到adminchock的值， 使用&lt;c:if text=”${adminchock}”&gt;&lt;c:if&gt;判断，实现不同的权限。 --%&gt; &lt;c:out value=&quot;管理员欢迎您！&quot;/&gt; &lt;/c:if&gt; &lt;%--使用EL表达式得到adminchock的值，如果输入的用户名为admin将显示true。 --%&gt; ${adminchock} &lt;/body&gt; &lt;/html&gt; 流程控制标签——choose标签、when标签、otherwise标签配合使用讲解&lt;c:choose&gt;、&lt;c:when&gt;和&lt;c:otherwise&gt;标签的功能&lt;c:choose&gt;、&lt;c:when&gt;和&lt;c:otherwise&gt;这3个标签通常情况下是一起使用的，&lt;c:choose&gt;标签作为&lt;c:when&gt;和&lt;c:otherwise&gt;标签的父标签来使用。使用&lt;c:choose&gt;，&lt;c:when&gt;和&lt;c:otherwise&gt;三个标签，可以构造类似 “if-else if-else” 的复杂条件判断结构 语法&lt;c:choose&gt; &lt;c:when test=&quot;条件1&quot;&gt; //业务逻辑1 &lt;/c:when&gt; &lt;c:when test=&quot;条件2&quot;&gt; //业务逻辑2 &lt;/c:when&gt; &lt;c:when test=&quot;条件n&quot;&gt; //业务逻辑n &lt;/c:when&gt; &lt;c:otherwise&gt; //业务逻辑 &lt;/c:otherwise&gt; &lt;/c:choose&gt; 使用范例&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%--引入JSTL核心标签库 --%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;JSTL: -- choose及其嵌套标签标签示例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h4&gt;choose及其嵌套标签示例&lt;/h4&gt; &lt;hr/&gt; &lt;%--通过set标签设定score的值为85 --%&gt; &lt;c:set var=&quot;score&quot; value=&quot;85&quot;/&gt; &lt;c:choose&gt; &lt;%--使用&lt;c:when&gt;进行条件判断。 如果大于等于90，输出“您的成绩为优秀”； 如果大于等于70小于90，输出“您的成绩为良好”； 大于等于60小于70，输出“您的成绩为及格”； 其他（otherwise）输出“对不起，您没能通过考试”。 --%&gt; &lt;c:when test=&quot;${score&gt;=90}&quot;&gt; 你的成绩为优秀！ &lt;/c:when&gt; &lt;c:when test=&quot;${score&gt;70 &amp;&amp; score&lt;90}&quot;&gt; 您的成绩为良好! &lt;/c:when&gt; &lt;c:when test=&quot;${score&gt;60 &amp;&amp; score&lt;70}&quot;&gt; 您的成绩为及格 &lt;/c:when&gt; &lt;c:otherwise&gt; 对不起，您没有通过考试！ &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/body&gt; &lt;/html&gt; 循环标签——forEach标签的使用&lt;c:forEach&gt;标签的功能该标签根据循环条件遍历集合（Collection）中的元素。 &lt;c:forEach&gt;标签的语法&lt;c:forEach var=”name” items=”Collection” varStatus=”StatusName” begin=”begin” end=”end” step=”step”&gt; 本体内容 &lt;/c:forEach&gt; 参数说明: var设定变量名用于存储从集合中取出元素。 items指定要遍历的集合 varStatus设定变量名，该变量用于存放集合中元素的信息。 begin、end用于指定遍历的起始位置和终止位置（可选）。 step指定循环的步长 Dome: &lt;c:forEach items=&quot;${itemsList}&quot; var=&quot;item&quot; varStatus=&quot;s&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;itemsList[${s.index}].id&quot; value=&quot;${item.id}&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;itemsList[${s.index}].name&quot; value=&quot;${item.name}&quot;&gt; &lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;itemsList[${s.index}].price&quot; value=&quot;${item.price}&quot;&gt; &lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;/td&gt; &lt;td&gt;${item.detail }&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;${pageContext.request.contextPath }/items/editItems.action?id=${item.id}&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;c:forEach&gt;标签的属性其中varStatus有4个状态属性，如下表所示: &lt;c:forEach&gt;的使用范例OCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;JSTL: -- forEach标签实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h4&gt;&lt;c:out value=&quot;forEach实例&quot;/&gt;&lt;/h4&gt; &lt;% List&lt;String&gt;list = new ArrayList&lt;String&gt;(); list.add(0, &quot;贝贝&quot;); list.add(1, &quot;晶晶&quot;); list.add(2, &quot;欢欢&quot;); list.add(3, &quot;莹莹&quot;); list.add(4, &quot;妮妮&quot;); request.setAttribute(&quot;list&quot;, list); %&gt; &lt;B&gt;&lt;c:out value=&quot;不指定begin和end的迭代：&quot; /&gt;&lt;/B&gt;&lt;br&gt; &lt;%--不使用begin和end的迭代，从集合的第一个元素开始，遍历到最后一个元素。 --%&gt; &lt;c:forEach var=&quot;fuwa&quot; items=&quot;${list}&quot;&gt; &amp;nbsp;&lt;c:out value=&quot;${fuwa}&quot;/&gt;&lt;br/&gt; &lt;/c:forEach&gt; &lt;B&gt;&lt;c:out value=&quot;指定begin和end的迭代：&quot; /&gt;&lt;/B&gt;&lt;br&gt; &lt;%--指定begin的值为1、end的值为3、step的值为2， 从第二个开始首先得到晶晶，每两个遍历一次， 则下一个显示的结果为莹莹，end为3则遍历结束。 --%&gt; &lt;c:forEach var=&quot;fuwa&quot; items=&quot;${list}&quot; begin=&quot;1&quot; end=&quot;3&quot; step=&quot;2&quot;&gt; &lt;c:out value=&quot;${fuwa}&quot;/&gt;&lt;br/&gt; &lt;/c:forEach&gt; &lt;B&gt;&lt;c:out value=&quot;输出整个迭代的信息：&quot; /&gt;&lt;/B&gt;&lt;br&gt; &lt;%--指定varStatus的属性名为s，并取出存储的状态信息 --%&gt; &lt;c:forEach var=&quot;fuwa&quot; items=&quot;${list}&quot; begin=&quot;3&quot; end=&quot;4&quot; varStatus=&quot;s&quot; step=&quot;1&quot;&gt; &lt;c:out value=&quot;${fuwa}&quot; /&gt;的四种属性：&lt;br&gt; 所在位置，即索引：&lt;c:out value=&quot;${s.index}&quot; /&gt;&lt;br&gt; 总共已迭代的次数：&lt;c:out value=&quot;${s.count}&quot; /&gt;&lt;br&gt; 是否为第一个位置：&lt;c:out value=&quot;${s.first}&quot; /&gt;&lt;br&gt; 是否为最后一个位置：&lt;c:out value=&quot;${s.last}&quot; /&gt;&lt;br&gt; &lt;/c:forEach&gt; &lt;/body&gt; /html&gt; 运行结果为: URL操作标签——import标签的使用&lt;c:import&gt;标签的功能该标签可以把其他静态或动态文件包含到本JSP页面，与jsp:include的区别为：jsp:include只能包含同一个web应用中的文件。而&lt;c:import&gt;可以包含其他web应用中的文件，甚至是网络上的资源。 &lt;c:import&gt;标签的语法 语法1:&lt;c:import url=”url” [context=”context”][value=”value”] [scope=”page|request|session|application”] [charEncoding=”encoding”]/&gt; 语法2:&lt;c:import url=”url” varReader=”name” [context=”context”] [charEncoding=”encoding”]/&gt; 参数说明: URL为资源的路径，当引用的资源不存在时系统会抛出异常，因此该语句应该放在&lt;c:catch&gt;&lt;/c:catch&gt;语句块中捕获。 引用资源有两种方式：绝对路径和相对路径。 使用绝对路径的示例如下：&lt;c:import url=”http://www.baidu.com”&gt; 使用相对路径的示例如下：&lt;c:import url=”aa.txt”&gt;，aa.txt放在同一文件目录。 如果以“/”开头表示应用的根目录下。例如：tomcat应用程序的根目录文件夹为webapps。导入webapps下的文件bb.txt的编写方式为：&lt;c:import url=”/bb.txt”&gt; context属性用于在访问其他web应用的文件时，指定根目录。例如，访问root下的index.jsp的实现代码为：&lt;c:import url=”/index.jsp” context=”/root”&gt;。等同于webapps/root/index.jsp var、scope、charEncoding、varReader是可选属性。 &lt;c:import&gt;标签使用范例&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%--引入JSTL核心标签库 --%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;JSTL: -- import标签实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h4&gt;&lt;c:out value=&quot;import实例&quot;/&gt;&lt;/h4&gt; &lt;hr/&gt; &lt;h4&gt;&lt;c:out value=&quot;绝对路径引用的实例&quot; /&gt;&lt;/h4&gt; &lt;%--使用绝对路径导入百度首页,导入时使用&lt;c:catch&gt;&lt;/c:catch&gt;捕获异常。--%&gt; &lt;c:catch var=&quot;error1&quot;&gt; &lt;c:import url=&quot;http://wwww.baidu.com&quot; charEncoding=&quot;utf-8&quot;/&gt; &lt;/c:catch&gt; ${error1} &lt;hr/&gt; &lt;h4&gt;&lt;c:out value=&quot;相对路径引用本应用中的文件&quot; /&gt;&lt;/h4&gt; &lt;%--使用相对路径导入同一文件夹下的“JSTL的import标签使用说明”文件，接收的字符编码格式使用charEncoding设置为utf-8。 --%&gt; &lt;c:catch var=&quot;error2&quot;&gt; &lt;c:import url=&quot;JSTL的import标签使用说明&quot; charEncoding=&quot;utf-8&quot;/&gt; &lt;/c:catch&gt; ${error2} &lt;hr/&gt; &lt;h4&gt;&lt;c:out value=&quot;使用字符串输出相对路径引用的实例，并保存在session范围内&quot; /&gt;&lt;/h4&gt; &lt;%--导入“JSTL的import标签使用说明.txt”，使用var定义的变量接收要导入的文件，并存储在session中， 如果在其他页面同样也要导入该文件，只须使用&lt;c:out&gt;输出“JSTL的import标签使用说明.txt”的值即可。--%&gt; &lt;c:catch var=&quot;error3&quot;&gt; &lt;c:import var=&quot;myurl&quot; url=&quot;JSTL的import标签使用说明&quot; scope=&quot;session&quot; charEncoding=&quot;utf-8&quot;/&gt; &lt;c:out value=&quot;${myurl}&quot;&gt;&lt;/c:out&gt; &lt;hr/&gt; &lt;c:out value=&quot;${myurl}&quot; /&gt; &lt;/c:catch&gt; ${error3} &lt;/body&gt; &lt;/html&gt; URL操作符——url标签的使用&lt;c:url&gt;标签的功能标签用于在JSP页面中构造一个URL地址，其主要目的是实现URL重写。 &lt;c:url&gt;标签的语法 语法1:指定一个url不做修改，可以选择把该url存储在JSP不同的范围中。&lt;c:url value=”value” [var=”name”][scope=”page|request|session|application”] [context=”context”]/&gt; 语法2:配合 &lt;c:param&gt;标签给url加上指定参数及参数值，可以选择以name存储该url。 &lt;c:url value=”value” [var=”name”] [scope=”page|request|session|application”] [context=”context”] &lt;c:param name=”参数名” value=”值”&gt;&lt;/c:url&gt;` &lt;c:url&gt;标签的主要属性 &lt;c:url&gt;标签使用范例&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; %--引入JSTL核心标签库 --%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;JSTL: -- url标签实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;c:out value=&quot;url标签使用&quot;&gt;&lt;/c:out&gt; &lt;h4&gt;使用url标签生成一个动态的url，并把值存入session中.&lt;/h4&gt; &lt;hr/&gt; &lt;c:url value=&quot;http://www.baidu.com&quot; var=&quot;url&quot; scope=&quot;session&quot;&gt; &lt;/c:url&gt; &lt;a href=&quot;${url}&quot;&gt;百度首页(不带参数)&lt;/a&gt; &lt;hr/&gt; &lt;h4&gt; 配合 &amp;lt;c:param&amp;gt;标签给url加上指定参数及参数值，生成一个动态的url然后存储到paramUrl变量中 &lt;/h4&gt; &lt;c:url value=&quot;http://www.baidu.com&quot; var=&quot;paramUrl&quot;&gt; &lt;c:param name=&quot;userName&quot; value=&quot;codingxiaxw&quot;/&gt; &lt;c:param name=&quot;pwd&quot;&gt;123456&lt;/c:param&gt; &lt;/c:url&gt; &lt;a href=&quot;${paramUrl}&quot;&gt;百度首页(带参数)&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习笔记之EL表达式]]></title>
    <url>%2F2018%2F09%2F27%2FJavaWeb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[EL，即Expression Language。在JavaWeb中属于JSP技术，是一种JSP表达式语言。而另一种表达式语言是Java脚本表达式&lt;%=Java表达式%&gt;。JavaWeb中最好不要在JSP中写Java代码，所以用EL表达式来替代Java表达式。 语法及用法1.获取某个对象的值，并将其输出到页面上 点运算符：${stu.name}，即调用域中stu对应的对象的name的读属性getName()。但，若stu在4个域中没有绑定相应对象，那么就在网页上输出空字符串(即什么都不输出)。 ${stu.name}相当于: &lt;% Student stu=pageContext.getAttribute(&quot;stu&quot;); if(stu!=null) out.println(stu.getName()); %&gt; []运算符:${stu[‘name’]}或者${stu[“name”]}。与点运算符作用一样，但当索引或者名称不符合Java名称规范时(如，获取数组中的某个值)，只能用[]运算符。 获取集合中的元素:List按照索引来获取元素:${obj.list[1]}，Map按照指定的key来获取元素:${obj.map.key}或者${obj.map[‘key’]}。 Demo： 2.逻辑和数学运算 1.empty运算符:判断一个对象是否为null或者””，是则返回true，否则返回false。也可以判断一个数组和集合，当数组或集合对象不是null，但对象中没有原素也返回true。 2.数学运算符:+-*/。如${i+1} 3.三元运算符:${表达式?T表达式:F表达式}。如${a&gt;1?a+1:a-1} 4.不支持字符串连接。如${str+str}，这是错误的。 EL表达式十一个内置对象EL内置对象(或隐式对象)，即在EL表达式中可以直接调用的对象。总结起来就是有一个JSP对象，十个Map对象。 pageContext:与JSP内置对象pageContext完全一样。 pageScope:当前页面的域对象的Map。 requestScope:请求域对象的Map。 sessionScope:会话域对象的Map。 applicationScope:应用域对象的Map。 param:请求参数的Map，key为请求参数名，value为请求参数的值。 paramValues:请求参数(可重名)的Map&lt;String,String[])，key为请求参数名，value为请求参数的值数组。 header:请求消息头Map，key为请求头名，value为对应的值。 headerValues:请求消息头(可重名)的Map&lt;String,String[]&gt;，key为请求名，value为请求头值数组。 cookie:封装cookie的Map&lt;String,Cookie&gt;，key为cookie的name属性，value为cookie对象本身。 initParam:初始化参数的Map，在web.xml中的context-param元素中定义的初始化参数。 自定义EL函数第一步:定义一个有静态方法的类: package net.codingXiax.util; public class StringUtil{ public static String toUppercase(String str){ return &quot;字符串&quot;; } } 第二步:配置tld文件在Web-INF目录下(也可以在其他目录下，该目录下建立安全性更高)，建立一个扩展名为tld的xml文件。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot; version=&quot;2.0&quot;&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;myfn&lt;/short-name&gt; &lt;uri&gt;http://www.yrom.net/jsp/string/fn&lt;/uri&gt; &lt;function&gt; &lt;name&gt;toUppercase&lt;/name&gt; &lt;function-class&gt;net.yrom.util.StringUtil&lt;/function-class&gt; &lt;function-signature&gt;java.lang.String toUpperCase( java.lang.String )&lt;/function-signature&gt; &lt;/function&gt; &lt;/taglib&gt; 第三步，配置web.xml如果tld文件是在Web-INF目录或类路径下，此步可跳过。 &lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://www.yrom.net/jsp/string/fn&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/myfn.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;/jsp-config&gt; 第四步，在JSP中使用。注意应先用taglib指令引入该uri。 &lt;%@ taglib uri=&quot;/该tld所在位置&quot; prefix=&quot;myfn&quot; %&gt; ... &lt;body&gt; &lt;% pageContext.setAttribute(&quot;a&quot;,&quot;aaa&quot;); %&gt; ${myfn:toUppercase(a)} &lt;/body&gt; ... JSTL标签库JSTL标签库的使用是为弥补html标签的不足，规范自定义标签的使用而诞生的。使用JSLT标签的目的就是不希望在jsp页面中出现java逻辑代码。JSTL也是对EL表达式的扩展(也就是说JSTL依赖EL)，JSTL标签库将在下篇文章JavaWeb学习笔记之JSTL标签库中详细介绍。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解session和cookie机制]]></title>
    <url>%2F2018%2F09%2F26%2F%E7%90%86%E8%A7%A3session%E5%92%8Ccookie%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[SessionHttpSession概述与作用 HttpSession是由JavaWeb提供的，用来会话跟踪的类。session是服务器端对象，保存在服务器端。 HttpSession是Servlet三大域对象(request、session、application)之一，所以它也有setAttribute()、getAttribute()、removeAttribute()三个方法。 HttpSession底层依赖Cookie，或是URL重写。 HttpSession的作用 会话范围:会话范围是某个用户从首次访问服务器开始，到该用户关闭浏览器结束。(会话:一个用户对服务器的多次连贯性请求！所谓连贯请求，就是该用户多次请求 中间没有关闭浏览器) 服务器会为每个客户端创建一个session对象，session就好比客户在服务器端的账户，它们被服务器保存到一个Map中，这个Map被称之为session缓存。 Servlet中得到session对象的方法为:HttpSession session=request.getSession(); Jsp中得到session对象的方法:session是JSP内置对象之一，不用创建就可以直接使用。 session域相关方法: void setAttribute(String name,Object value); Object getAttribute(String name); void removeAttribute(String name); session的生命周期:1.创建时机: 某个用户访问服务器开始2.销毁时机: 关闭服务器 关闭浏览器一段时间直到session过期，可以通过在web.xml配置这个时间，单位是分钟，但是这个并不是定时器，所以时间可能有点不准确的 &lt;session-config&gt; &lt;session-timeout&gt;1&lt;/session-timeout&gt;0是不限制时间 &lt;/session-config&gt; 不关闭浏览器，session超时 session保存用户登录信息login.jsp LoginServlet.java success.jsp HttpSession原理初入HttpSession原理 1.每当客户端与服务器建立了一个会话，服务器就会为该客户端建立一个session对象，将session对象保存在服务器端的同时服务器还会给客户端发送一个带有JSESSIONID的Cookie(放在响应头中)；2.当客户端在不关闭浏览器的情况下再次访问该服务器时，客户端就会通过这个JSESSIONID来取出保存在服务器端相应session对象。3.当客户关闭了浏览器时，意味着与服务器断开连接然后会话session也随着就结束了，此时能识别存在服务器端的HttpSession对象的JSESSIONID也就跟着丢失了。4.但是此HttpSession对象依旧保存在服务器端。5.当再次打开浏览器时，就会重新建立新连接，服务器给过来的JSESSIONID也是新的了。 这就好比你第一次去银行办卡，1.银行给你办了一张带有独特帐号的银行卡(JSESSIONID)然后你回家了，你存在银行卡里的钱保存在银行里(相应的HttpSession对象)(对应上面的步骤1)；2.当你再次访问该银行取钱时，你首先要给银行你的带有独特帐号的银行卡(将JSESSIONID给服务器),然后银行会给你要取的钱(获取相应的HttpSession对象)(对应上面的步骤2)。3.当你丢失了你的银行卡，而银行的工作人员又不小心在数据库中删除了你银行卡对应的帐号(对应上面的步骤3关闭浏览器)。4.但是你的钱还保存在银行里(对应上面的步骤4)。5.这时当你再次返回该银行时，你就需要重新办一张银行卡(由于工作人员删除了你原先的帐号所以不能补办),并且新办理的银行卡会对应新的帐号(新的JSESSIONID)。 对于断开连接后保存在服务器端的HttpSession对象不会一直存在，它有它的生命时间，一般为30分钟，到达这个时间后服务器端就会将它删除。还有一种情况就是当客户端与服务器建立一个会话后，但是该客户却很长时间不对服务器发请求，当时间到达该session对象存活的时间后服务器也会删除该session对象。就比如你登录了淘宝的主页，然后你半天时间不去碰电脑，当你想起要去购物时，你点击一个超链接后服务器就会要求你重新登录，因为由于你长时间不给服务器发起请求，服务器就误认为这是一个没用的session，然后服务器就将它删了。 深入HttpSession原理只有当客户端请求的Servlet中调用了request.getSession()方法要求获取HttpSession对象时服务器才会创建；但是若请求的是jsp页面，则服务器会立刻创建HttpSession对象，因为jsp对应的Servlet类中已经默认调用了request.getSession()。 HttpSession的其它方法 String getId():获取JSESSIONID。 int getMaxInactiveInterval():获取session可以的最大不活动时间(秒),默认为30分钟，当session在30分钟内没有使用，哪么Tomcat会在session缓存中删掉这个session。 void invalidate():让session失效。调用这个方法会被session失效，当session失效后，客户端再次请求，服务器会给客户端创建一个新的session，并在响应中创建一个新的JSESSIONID。 boolean isNew():查看session是否为新。当客户端第一次请求时，服务器为客户端创建session，并把JSESSIONID存在Cookie中发给客户端，这时调用这个方法返回的就是新session；当再次发起请求时，JSESSIONID放在Cookie中作为请求头发给服务器，这时调用此方法，返回的就是false，即此session不是新的。 Demo: CookieHttp协议与Cookie(了解) Cookie是Http协议制定的。先有服务器保存Cookie到浏览器，再下次浏览器请求服务器时把上一次请求得到的Cookie归还给服务器。 由服务器创建保存到客户端的一个键值对。服务器保存Cookie的响应头,使用response发送响应头:Set-Cookie:aaa=AAA;Set-Cookie:bbb=BBB;例如: response.addHeader(“Set-Cookie”,”aaa=AAA”); response.addHeader(“Set-Cookie”,”bbb=BBB”); 当浏览器请求服务器时，会把该服务器保存的Cookie随请求发送给服务器。浏览器归还Cookie的请求头:Cookie:aaa=AAA;bbb=BBB。多个键值对间用分号隔开。Http协议规定(为了不给浏览器太大压力) 1个Cookie最大4KB 1个服务器最多向1个浏览器保存20个Cookie 1个浏览器最多可以保存300个Cookie Cookie的用途 服务器使用Cookie来跟踪客户端状态。 保存购物车(购物车中的商品不能使用request域来保存，因为它是一个用户向服务器发送的多个请求信息) 显示上次登录用户名(并记住密码) 下面请看Demo: Java Web中使用Cookie. Cookie详解 Cookie不只有name和value两个属性。 Cookie的maxAge:指Cookie的最大生命，即Cookie可保存在客户端中的最大时长，以秒为单位。 maxAge&gt;0:浏览器会把Cookie保存到客户端硬盘上，有效时长为maxAge的值决定，例如:cookie.setMaxAge(60)表示这个Cookie会被浏览器保存到硬盘上60秒。 maxAge&lt;0:Cookie只会在浏览器内存中存在，当用户关闭浏览器时浏览器进程结束，同时Cookie也就死亡了。 maxAge=0:浏览器会马上删除这个Cookie。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet请求转发和请求包含]]></title>
    <url>%2F2018%2F09%2F26%2FServlet%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E8%AF%B7%E6%B1%82%E5%8C%85%E5%90%AB%2F</url>
    <content type="text"><![CDATA[为什么需要这样的操作呢？因为很多时候一个请求需要多个Servlet协作才能完成，所以需要在一个Servlet中跳转到另一个Servlet中处理。类似于以后学到的框架中的controller的写法。 请求转发和请求包含的语法格式 ResquestDispatcher rd=request.getRequestDispatcher(“/MyServlet”); 参数为被包含或被转发的目标Servlet路径。 请求转发: rd.forward(request,response); 请求包含: rd.include(request,response); 这样就完成我们的请求转发和请求包含。二者的区别为: 请求转发:由当前Servlet设置响应头(不能设置响应体)，下一个Servlet既可设置响应头也可设置响应体。 请求包含:当前Servlet和下一个Servlet共同完成相应头和响应体 请求转发具体效果请看下图输出结果是 This is Two Servlet 由响应结果我们可以看到OneServlet中设置的响应体没有在网页中显示出来，只有TwoServlet中设置的响应体显示出来了。 请求包含具体效果请看下图 This is One ServletThis is Two Servlet 从响应结果中我们可以看到在OneServlet和TwoServlet中设置的响应体都显示了出来。 需要注意的是无论是请求转发还是请求包含，都在一个请求范围内，所以多个Servlet中其实使用的是同一个request和response。 请求转发和请求重定向的区别 请求转发是一个请求一次响应，而重定向是两次请求两次响应。 请求转发地址栏不变化，而重定向会显示后一个请求的地址。 请求转发只能转发到本项目其他Servlet，而重定向不仅能重定向到本项目的其它Servlet，还能定向到其它项目。 请求转发是服务器端行为，只需给出转发的Servlet路径，而重定向需要给出requestURI,即包含项目名。 请求转发和重定向二者效率前者高，因为前者只发出一个请求。 什么时候用请求转发/重定向 很多时候我们需要地址栏发生变化，那时候必须使用重定向。需要在下一个Servlet中获取到request域中的数据，必须用请求转发。 Servlet间传递数据之request域何为域？上一篇文章中提到对ServletContext域对象的介绍时已经说过域的功能，即具有能存数据和取数据的功能(Servlet三大域对象request,session,application) 同一请求范围内使用request.setAttribute()来传值、使用request.getAttribute()方法来取值即前一个Servlet使用request.setAttribute()来传值、后一个Servlet使用request.getAttribute()方法来取值 而当想清除request中的值时，调用request.removeAttribute()方法即可清除。 三大域对象的生命周期长度为: request&lt;session&lt;application 扩展: 注意上图中三个方法和请求参数方法的区别，请求参数是客户端传给服务器的，我们不能修改；而此处的setAttribute()是我们自己设置的属性与属性值。另外Servlet类中有上述三大域，而JSP中有四大域，多了一个pageContext域。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet的生命周期与创建时机]]></title>
    <url>%2F2018%2F09%2F26%2FServlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Servlet的生命周期指的是Servlet从被Web服务器加载到它被销毁的整个生命过程。那么他的生命周期主要分为哪几个阶段以及它的工作原理是怎么样的呢？本博文接下来将讨论这些内容。 Servlet的生命周期的详细分析首先看图: Servlet的生命周期分为三个阶段: 初始化阶段，先判断Servlet实例是否已经存在，若不存在，调用都早方法，调用init(ServletConfig)方法,注意调用构造方法先于调用init()方法，且在一个生命周期内，只调用一次init()方法 响应客户端请求阶段，调用service()方法，决定doGet还是doPost方法 销毁阶段，调用destory()方法 ###一个Servlet的具体步骤以及和JSP的区别(web.xml和Service方法) 注意严格来说，第一个的类型不一样，一个是JspWrite,另一个是PrintWriter 1.Tomcat服务器加载Servlet：Web服务器启动后，它会根据每个工程的web.xml文件去查找该工程的Servlet，并且找到这些Servlet的Class文件所在的地址，将它们载入到Web容器中，不同的Servlet被Web容器加载的次序不同，通过web.xml文件可以配置每个Servlet载入的次序。 一般来说，Servlet在服务器启动时就会被Web服务器加载，而JSP文件只有在用户访问到该页面时才会被动态载入。 创建一个Servlet实例：这时会调用该Servlet的构造函数去创建一个具体的Servlet对象。 经过以上的两个步骤后，这时如果有客户端请求，Web服务器就会调用Servlet对象的init()方法 接着Web服务器调用Servlet的service()方法去接收请求，处理请求，并把处理结果返回。 销毁：Servlet实例被销毁，这是通过调用Servlet的destory()方法来实现的。 在以上的几个阶段中，Servlet对外提供服务阶段最重要的。service()方法是编程人员真正要关心的方法，因为它才是Servlet真正开始响应客户端请求，并且处理业务逻辑的方法。Service()接收到客户端请求后，再调用Servlet的doGet()方法或者doPost()方法去处理请求。所以在编写自己的Servlet时，一般只需要重写doGet()和doPost()方法，在该方法中去处理客户端请求，并把处理结果返回。 注意Servlet的构造函数和init()函数的带哦用实际 web请求的过程具体分析: Web 客户端向Servlet容器(tomcat)发出Http请求 Servlet容器接收Web 客户端的请求 Servlet容器创建一个HttpRequest对象，将Web 客户端请求的信息封装到这个对象中。 Servlet容器创建一个HttpResponse对象 Servlet容器调用HttpServlet对象的service方法，把HttpRequest对象与HttpResponse对象作为参数传递给HttpServlet对象。 HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息 HttpServlet调用HttpResponse对象的有关方法，生成响应数据 Servlet容器把HttpServlet的响应结果传入Web 客户端。 Servlet工作原理:首先客户发送个请求，Servlet容器会创建特定于这个请求的ServletRequest对象和ServletResponse对象，然后调用Servlet的service()方法。Service()方法从ServletRequest对象获得客户请求信息，处理该请求，然后通过ServletResponse对象向客户返回响应信息。 Tomcat同期装载Servlet的三个时机: 1.Servlet容器启动时自动装载，但是这需要配置以下代码内容：读取web.xml配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，同时将ServletConfig对象作为参数来调用Servlet对象的init方法。 &lt;servlet-name&gt;Init&lt;/servlet-name&gt; &lt;servlet-class&gt;org.xl.servlet.InitServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 在servlet的配置当中，1的含义是：标记容器是否在启动的时候就加载这个servlet。当值为0或者大于0时，表示容器在应用启动时就加载这个servlet；当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。正数的值越小，启动该servlet的优先级越高。 2.在Servlet容器启动后：客户首次向Servlet发出请求的时候。Servlet容器会判断内存中是否存在指定的Servlet对象，如果没有那么创建它，然后根据客户的请求创建HttpRequest、HttpResponse对象，从而调用Servlet 对象的service方法。 3.Servlet被更新后，重新装载Servlet的时候 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb之Servlet学习]]></title>
    <url>%2F2018%2F09%2F26%2FJavaWeb%E4%B9%8BServlet%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Servlet（Servlet Applet），全称Java Servlet,是JSP页面的前身,是SUN公司规定的用Java编写的服务器端程序。而这些Servlet都要事先Servlet接口或继承了HttpServlet的java代码(一般用继承的方法)。其主要功能在于交互式的浏览和修改数据，生成动态Web内容。Servlet运行于支持Java的应用服务器中。HttpServlet 重写doGet 和 doPost 方法或者你也可以重写service方法完成对get和post请求响应。 Servlet的概念Servlet是Java Web三大组件之一(Filter、Servlet、Listener)，它属于动态资源。Servlet的作用是处理请求，服务器会把接收到的请求交给Servlet来处理，在Servlet中通常需要: 接受数据请求 处理请求 完成响应 客户端发出登录请求，或者输入注册请求，这些请求都应该由Servlet来完成处理。当然Servlet类需要我们自己来编写，每个Servlet类都必须实现javax.servlet.Servlet接口。 Servlet的执行流程 注意超链接其实对应的是GET方式。 实现Servlet的方式(需要我们自己来写) 实现javax.servlet.Servlet接口; 继承javax.servlet.GenericServlet类; 继承javax.servlet.http.HttpServlet类; 一般来说我们都选择实现HttpServlet类来完成我们的Servlet，但学习Servlet还要从javax.servlet.Servlet接口来学起。 实现javax.servlet.Servlet接口 其中只有三个生命周期的方法是由服务器(例如我用的Tomcat)在认为需要调用的时候自动调用的(即我们自己是无法调用的)，另外的两个方法由我们自己需要的时候调用。 继承javax.servlet.GenericServlet类有人会说，那我每次实现Servlet接口都要重写这5个方法岂不是很麻烦？那肯定麻烦！所以GenericServlet类派上用场了。GenericServlet类实现了Servlet接口，所以在GenericServlet类中实现了Servlet接口中的5个抽象方法，另外在GenerecServlet类中还定义了自己的方法，将其作为我们要定义的xxxServlet类的父类，这样我们在自己定义的xxxServlet类中便可以不用全部实现Servlet接口中的方法。GenericServlet类中的方法如下: GenericServlet类除了实现Servlet接口中的四个方法外，还定义了getInitParameter()返回Servlet的参数值、getInitParameterNames()返回Servlet的参数名、getServletName()返回Servlet名、getServletContext()返回Servlet上下文、不带参数的init()、log()等方法。这些自己定义的方法中，前面四个是ServletConfig接口中的方法，不带参数的init()方法跟Servlet接口中的init(ServletConfig config)方法要区别，在init()方法中，我们可以添加当xxxServlet被初始化的操作，此方法在初始化方法init(ServletConfig config)中被调用(若是文字解析看不懂见下图GenericServlet源代码中注释)。 图中只有service()方法属于抽象方法，所以当我们定义的xxxServlet类去继承GenericServlet类时我们只需重写这一个方法即可，其他方法可重写可不重写。 注意，为什么会出现GenericServlet？如果我们直接通过实现Servlet接口来编写一个Servlet类，就需要实现Servlet接口中定义的5种方法，为了简化Servlet的编写，在javax.servlet包中，给我们提供了一个抽象的类GenericServlet，它提供了除service()方法外的其他4种方法的简单实现。GenericServlet类定义了一个通用的，不依赖具体协议的Servlet 另外附上GenericServlet类的源代码: JavaWeb，Servlet，JSP的域对象扩展:对ServletContext的解释: 服务器会为每个应用创建一个ServletContext对象，一个应用只有一个ServletContext对象！我们可以在N多个Servlet中来获取这个唯一的对象，使用它可以给多个Servlet传递数据。此对象在Tomcat(服务器)启动时就创建，在服务器关闭时就销毁。 ServletContext是Java Web四大域对象(PageContext、ServletRequest、HttpSession、ServletContext)之一，域对象所具有的特点是: 能够存数据 能够取数据 所有的域对象都有存取数据的功能，因为域对象内部都有一个Map，用来存储数据和读取数据，下面是ServletContext对象用来操作数据的方法: 扩展:Servlet类三大域对象: request:在Servlet中直接用，因为实现的doPost()方法中有request这个参数。 session:在Servlet中通过HttpSession session=request.getSession();得到。 application:在Servlet中通过ServletContext application=this.getServletContext();得到。 扩展:JSP中四大域对象 page域:即9大内置对象中的pageContext，为PageContext的实例。 request域:即9大内置对象中的request，为HttpServletRequest的实例。 session域:即9大内置对象中的session,为HttpSession的实例。 application:即9大内置对象中的ServletContext的实例 注意:“page域”不同于9大内置对象中“page”。 继承HttpServlet类HttpServlet类是我们用到次数最多的，也是最简单的。由类名可知，该类总是跟http协议相关的。HttpServlet类中的方法如下图: 方法中值得我们注意的有doGet()、doPost()、还有两个service()方法。其中doGet()和doPost()方法是需要我们重写的，我来解释下两个service()方法的区别。 其中一个service()方法是Serlvet接口中的生命周期方法，另外一个是跟http协议有关的方法。二者方法的解释见下两站图的说明(图1中指出HttpServlet类是继承自GenderServlet类): 图中405的含义是说服务器不支持客户端(即浏览器)用此种方法访问。因为HttpServlet类的源代码中的doGet()和doPos88t()方法体里面就是这样写的，你在定义的xxxservlet中如果不重新重写这两个方法就会出现405的响应状态码。 Servlet获取表单数据 Servlet高级1.获取初始化参数:在web.xml中配置servlet时，可以配置一些初始化参数。而在Servlet可以通过ServletConfig接口提供的方法来获取这些参数的值2.MVC模式:分层思想，即Model2 使用Model2实现购物车 注意首先明确，Servlet并不是专门用于处理Http请求的。由于大多数网络应用中，都是浏览器通过HTTP协议去访问服务器资源，而我们编写的Servlet也主要是应用于HTTP协议的请求和响应，为了快速开发应用于HTTP协议的Servlet，Sun公司在javax.servlet.http包中给我们提供了一个抽象的类HttpServlet 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之Socket编程与应用]]></title>
    <url>%2F2018%2F09%2F26%2FJava%E4%B9%8BSocket%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本博文首先是对TCP的简单介绍，然后在分析Socket通信的模型后进行Java Socket实现TCP编程的代码编写，最后是利用Socket的知识编写一个简单的聊天室 TCP(基于字节流)与数据传递TCP(Transmission Control Protocol 传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能。在因特网协议族(Internet protocol suite)中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。网络模型中的数据传递:应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段(通常受该计算机连接的网络的数据链路层的最大传输单元(MTU)的限制)。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。 Socket通信模型(描述IP地址和端口)所谓socket 通常也称作”套接字“，用于描述IP地址和端口，是一个通信链的句柄。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。首先我们看看Socket基于TCP的通信模型图:图中通信模型的各个步骤如下: 在服务端建立一个ServerSocket,绑定相应的端口，并且在指定的端口进行侦听，等待客户端的连接。 当客户端创建连接Socket并且向服务端发送请求。 服务器收到请求，并且接受客户端的请求信息。一旦接收到客户端的连接请求后，会创建一个连接socket，用来与客户端的socket进行通信。通过相应的输入/输出流进行数据的交换，数据的发送接收以及数据的响应等等。 当客户端和服务端通信完毕后，需要分别关闭socket，结束通信。 基于TCP的Socket服务端开发 创建ServerSocket对象，绑定监听器 通过accept（）方法监听客户端请求 连接建立以后通过读取客户端发送请求消息 通过输出流向客户端发送响应信息，关闭资源 ServerSocket类中涉及到的常用方法: ServerSocket(int port)——创建并绑定到特定端口的服务器套接字 accept()——侦听并接受到此套接字的连接 close()——关闭此套接字 getInetAddress()——得到ServerSocket对象绑定的IP地址。如果ServerSocket对象未绑定IP地址，返回0.0.0.0 getLocalPort()——返回此套接字在其上侦听的端口 public class Server { public static void main(String[] args) { //1.创建一个服务器Socket，即ServerSocket,指定绑定的端口，并坚挺 try { ServerSocket serverSocket=new ServerSocket(8888); //2，调用accept()开始监听，等待客户端的链接 System.out.println(&quot;****服务器即将启动，等待客户端的连接****&quot;); Socket socket=serverSocket.accept(); //3.获取输入流并获取客户信息 InputStream in=socket.getInputStream(); InputStreamReader isr=new InputStreamReader(in,&quot;utf-8&quot;); BufferedReader br=new BufferedReader(isr); String info; StringBuilder sb=new StringBuilder(); while ((info=br.readLine())!=null) { sb.append(info); } System.out.println(&quot;我是服务器，客户端发来的消息为:&quot;+sb); socket.shutdownInput();//关闭输入流 //4.获取输出流，用于响应客户端的请求 OutputStream os=socket.getOutputStream(); PrintWriter pw=new PrintWriter(os); pw.write(&quot;欢迎您&quot;); pw.flush();//将缓冲输出 //4.关闭相关资源 pw.close(); os.close(); br.close(); isr.close(); in.close(); socket.close(); serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } 基于TCP的Socket客户端开发客户端需要完成的工作是: 创建Socket对象，指明需要连接的服务器地址和端口号(1023以后的端口,因为0~1023之间的端口号是我们系统需要使用的端口号) 连接建立后，通过输出流向服务器端请求 通过输入流获取服务器响应信息, 关闭资源 Socket类中常用的方法: Socket(InetAddress address, int port)——创建一个套接字并将其连接到指定ip地址的指定端口号 Socket(String host, int port)——创建一个套接字并将其连接到指定主机上的指定端口号 close()——关闭此套接字 getInetAddress()——返回套接字连接的地址 getInputStream()——返回此套接字的输入流 getOutputStream——返回此套接字的输出流 public class Client { public static void main(String[] args) { //1.创建客户端Socket,指定服务器端地址和端口号 try { Socket socket=new Socket(&quot;localhost&quot;,8888); //2.获取输出流，用来向服务器端发送登录信息 OutputStream os=socket.getOutputStream(); PrintWriter pw=new PrintWriter(os);//将输出流打包成打印流 pw.write(&quot;用户名:codinglembre;密码:123&quot;); pw.flush();//刷新缓存 socket.shutdownOutput();//关闭输出流 //3.获取服务器传过来的输入流，读取服务器的响应信息 InputStream in=socket.getInputStream(); BufferedReader br=new BufferedReader(new InputStreamReader(in,&quot;utf-8&quot;)); String info; StringBuilder sb=new StringBuilder(); while ((info=br.readLine())!=null) { sb.append(info); } System.out.println(&quot;我是客户端，服务器给我的信息为:&quot;+sb); //3.关闭资源 br.close(); in.close(); pw.close(); os.close(); socket.close(); } catch (IOException e) { e.printStackTrace(); } } } 代码执行过程运行服务器Server.java，代码在执行到Socket socket=serverSocket.accept();时会在此阻塞，控制台输出: 服务器即将启动，等待客户端的连接 直到等到客户端连接到该端口号的服务器后服务器的代码才会向下执行，此时运行客户端Client.java，客户端的控制台输出: 我是客户端，服务器给我的信息为:欢迎您 然后此时切换到服务器的控制台，发现输出信息: **服务器即将启动，等待客户端的连接我是服务器，客户端发来的消息为:用户名:codinglembre;密码:123 服务器端多线程接收客户端传递过来的信息的代码编写线程类: public class ServerThread extends Thread { private Socket socket; public ServerThread(Socket socket) { this.socket=socket; } public void run() { //3.获取输入流并获取客户信息 InputStream in= null; InputStreamReader isr=null; BufferedReader br=null; OutputStream os=null; PrintWriter pw=null; try { in = socket.getInputStream(); isr=new InputStreamReader(in,&quot;utf-8&quot;); br=new BufferedReader(isr); String info; StringBuilder sb=new StringBuilder(); while ((info=br.readLine())!=null) { sb.append(info); } System.out.println(&quot;我是服务器，客户端发来的消息为:&quot;+sb); socket.shutdownInput();//关闭输入流 //4.获取输出流，用于响应客户端的请求 os=socket.getOutputStream(); pw=new PrintWriter(os); pw.write(&quot;欢迎您&quot;); pw.flush();//将缓冲输出 } catch (IOException e) { e.printStackTrace(); }finally { //4.关闭相关资源 try { if (pw!=null) pw.close(); if (os!=null) os.close(); if (br!=null) br.close(); if (isr!=null) isr.close(); if (in!=null) in.close(); if (socket!=null) socket.close(); }catch (Exception e) { e.printStackTrace(); } } } } 之后修改Server.java中的代码为: public class Server { public static void main(String[] args) { //1.创建一个服务器Socket，即ServerSocket,指定绑定的端口，并坚挺 try { ServerSocket serverSocket=new ServerSocket(8888); //2，调用accept()开始监听，等待客户端的链接 System.out.println(&quot;****服务器即将启动，等待客户端的连接****&quot;); //记录客户端的数量 int count=0; while (true) { //调用accept()方法开始监听，等待客户端的连接 Socket socket = serverSocket.accept(); //创建一个新的线程 ServerThread serverThread=new ServerThread(socket); //启动线程 serverThread.start(); //如果不要启动线程的话这里直接调用run()也行. count++;//统计客户端的数量 System.out.println(&quot;客户端的数量：&quot;+count); InetAddress address=socket.getInetAddress(); System.out.println(&quot;当前客户端的IP：&quot;+address.getHostAddress()); } } catch (IOException e) { e.printStackTrace(); } } } 运行Server.java，服务器控制台输出信息: 服务器即将启动，等待客户端的连接 然后运行Client.java，客户端控制台输出信息: 我是客户端，服务器给我的信息为:欢迎您 此时跳转到服务器控制台，信息变为: 服务器即将启动，等待客户端的连接我是服务器，客户端发来的消息为:用户名:codinglembre;密码:123客户端的数量：1当前客户端的IP：127.0.0.1 然后更改Client.java中传递给服务器的数据代码为:pw.write(“用户名:codingxiaxw;密码:456”);，再运行Client.java，发现服务器的控制台输出信息变为: 服务器即将启动，等待客户端的连接我是服务器，客户端发来的消息为:用户名:codingxiaxw;密码:13客户端的数量：1当前客户端的IP：127.0.0.1我是服务器，客户端发来的消息为:用户名:codingxiaxw;密码:456客户端的数量：2当前客户端的IP：127.0.0.1 QQ的通信模式c/sqq中的用户A发送信息给用户B，过程是这样的:当A打开和B的聊天窗口时即和B还有服务器建立了一个聊天室(同时服务器和客户端开启连接)，A发送信息，其实是发送到了qq聊天室服务器的接收容器中，然后qq服务器将该客户端地址(即qq头像)和信息内容显示在聊天室中(即聊天窗口)，你每和一个好友进行聊天打开一个窗口就等于和她(另一个客户端)还有我们的qq服务器组成了一个聊天室(当然聊天室的服务器肯定是多线程的)。qq上还有多人聊天的功能，实现道理也是这样，只是该聊天室中有多个客户端给服务器发送消息罢了 qq服务器挂在腾讯的某台主机上，相当于起了一个中转站的成分，这种聊天功能的实现对于客户端数量比较少时服务器端还能接受，但是在客户端数量很多时服务器肯定要瘫痪。所以为了减少服务器端的压力，需要实现客户端和客户端之间的直接通信，这样客户端上的qq既要实现服务器端的功能(用于接收信息)又要实现客户端的功能(用于发送信息)。此时qq服务器就不再作为一个中转站的功能了，它主要用于:用于客户端程序登陆,验证用户名密码,获取其他在线好友信息等等。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之IO流深入理解]]></title>
    <url>%2F2018%2F09%2F26%2FJava%E4%B9%8BIO%E6%B5%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[大多数程序都要实现和设备之间的数据传输，例如键盘可以输入数据，显示器可以显示程序的运行结果等。在Java中，将这种通过不同输入输出设备(键盘，内存，显示器，网络等)之间的数据传输抽象表述为”流”，程序允许通过流的方式与输入输出设备进行数据的传输。Java中的”流”都位于java.io包中，称为IO(输入输出)流。 文件的编码 gbk一个中文两个字节，一个英文一个字节 utf-8一个中文三个字节，一个英文一个字节 java是双字节编码，英文中文都是两个字节。 这里的byte4是以utf-16be的编码编成字节序列，所以将字节序列转解码成字符串时也要用utf-16be；而现实生活中，文本文件就是一种字节序列总结:当你的字节序列是某种编码时，这个时候想把字节序列变成字符串，也需要用这种编码方式，否则会出现乱码。 File常用APIjava中java.io.File代表文件(目录)，注意File类只用于表示文件(目录)的信息(名称，大小等)，不能用于文件内容的访问。 文件路径分隔符写法需要注意的地方，为了使得程序更有健壮性,路径分隔符的写法应该这样写File.separator: 遍历目录 递归实现子目录的内容的遍历这个要注意一下 文件内容的访问类RandomAccessFile类既可以读文件，也可以写文件，它支持随机访问文件的任何位置，但是这个类是读写操作，没有删除操作在学习RandomAccessFile之前先了解一下：1.java文件模型: 在硬盘上的文件是byte存储的，是数据的集合。 2.打开硬盘文件有两种模式 “rw”是读写 “r”是只读 RandomAccessFile raf = new RandomAccessFile(file,”rw”)文件指针，打开文件时，指针在pointer=0;getFilePointer()获得指针的位置3.写方法raf.write(int)–&gt;只写一个字节(后八位)，同时指针指向下一个文件的位置raf.writeInt()–&gt;直接写一个int4.读方法raf.read(int)–&gt;一次读一个字节 Demo: 注意Arrays.toString是将数组转化成字符串进行输出5.文件读写以后一定要关闭 IO流的四大抽象类 InputStream:输入字节流。抽象了应用程序读取数据的方式 OutputStream:输出字节流 抽象了应用程序写出数据的方式 Reader:输入字符流 Writer:输出字符流 其中，前两个是字节流，后两个是字符流。 字节流概念在计算机中，无论文本，图片，视频，音频，所有的文件都是以二进制(字节)形式存在。IO流中针对字节的输入输出设备提供了一系列的流，统称为字节流。字节流是程序中最常用的流，根据数据的传输方向可将其分为字节输入流和字节输出流。在JDK中，提供了两个抽象类InputStream和OutputStream，它们是字节流的顶级父类，所有的字节输入流都继承自InputStream，所有的字节输出流都继承自OutputStream。 字节输入流(InputStream)常用API方法: int read()从输入流读取一个8位的字节，把它转换成0~255之间的整数，并返回这一整数。 int read(byte[] b);从输入流读取若干字节，把它们保存到参数b指定的字节数组中，返回的整数表示读取字节数。 int read(byte[] b,int off,int len);从输入流读取若干字节，把它们保存到参数b指定的字节数组中，off指定字节数组开始保存数据的起始下标，len表示读取的字节数目，注意这个返回的是读到字节的个数 Demo: void close();关闭此输入流并释放与该流关联的所有系统资源。 前三个read()方法都是用来读数据的，其中，第一个read()方法是从输入流中逐个读入字节，而第二个和第三个read()方法则将若干字节以字节数组的形式一次性读入，从而提高读数据的效率。在进行IO流操作时，当前IO流会占用一定的内存，由于系统资源宝贵，因此，在IO流操作结束后，应该调用close()方法关闭流，从而释放当前IO流所占的系统资源。实例: import java.io.*; public class Example{ public static void main(String[] args){ FileInputStream in=new FileInputStream(源文件的路径); int b;//定义一个int类型的变量，记住每次读取的一个字节。 while((b=in.read())!=-1) { System.out.prinln(b);//逐个打印出读取的每一个字节 } in.close(); } 字节输入流(OutputStream) void write(int b);向输出流写入一个字节。 void write(byte[] b);把参数b指定的字节数组的所有字节写到输出流。 void write(byte[] b,int off,int len);将指定byte数组中从偏移量off开始的len个字节写入输出流。 void flush();刷新此输出流并强制写出所有缓冲的输出字节。 void close();关闭此输出流并释放与此流相关的所有系统资源。 实例: import java.io.*; public class Example{ public static void main(String[] args){ FileOutputStream out=new FileOutputStream(目标文件的路径); String str=&quot;hello world&quot;; byte[] b=str.getBytes();//字符串调用getBytes()方法即可转换成字节数组。 for(int i=0;i&lt;b.length;i++) { out.write(b[i]); } out.close(); } } InputStream和OutputStream这两个类虽然提供了一系列和读写数据有关的方法，但是这两个类都是抽象类，不能被实例化。因此，针对不同的功能，二者提供了不同的子类。 代码示例import java.io.*; public class Example{ public static void main(String[] args){ String fileName=&quot;xxx&quot;;//源文件路径 String fileName2=&quot;xxx&quot;;//目标文件路径 InputStream in=null; OutputStream out=null; try { in = new FileInputStream(fileName); out = new FileOutputStream(fileName2); int b; while ((b = in.read())!= -1) { out.write(b); } }catch (Exception e) { throw new RuntimeException(e); }finally { try { if (in != null) in.close(); if (out!=null) out.close(); }catch (Exception e) { throw new RuntimeException(e); } } } } 注意在填写文件名时，扩展名要写对 字节缓冲流(BufferedInputStream和BufferedOutputStream)上面的例子实现了对文件的复制，但是一个字节一个字节的读写，需要频繁的操作文件，效率非常低。为了提高效率，需要使用两个带缓冲的字节流，分别是BufferedInputStream和BufferedOutputStream,它们两个同时也属]JDBC之高级知识点中讲到的装饰者模式。下面通过增加字节缓冲流来对上述例子进行变动: import java.io.*; public class Example{ public static void main(String[] args){ String fileName=&quot;XXX&quot;;//源文件路径 String fileName2=&quot;XXX&quot;;//目标文件路径 InputStream in=null; OutputStream out=null; BufferedInputStream bis=null; BufferedOutputStream bos=null; try { in = new FileInputStream(fileName); bis = new BufferedInputStream(in);//将输入流对象作为参数传递给输入缓冲流 out = new FileOutputStream(fileName2); bos = new BufferedOutputStream(out); int len; while((len=bis.read())!=-1) { bos.write(len); } catch (Exception e) { throw new RuntimeException(e); }finally { try { if (in != null) in.close(); if (bis!=null) bis.close(); if (out!=null) out.close(); if (bos!=null) bos.close(); }catch (Exception e) { throw new RuntimeException(e); } } } } 字符流定义前面我们讲过的InputStream和OutputStream类在读写文件时操作的都是字节，如果希望在程序中操作字符，使用这两个类就不太方便，为此JDK提供了字符流。同字节流一样，字符流也有两个抽象的顶级父类，分别是Reader和Writer。 其中Reader是字符输入流，用于从某个源设备读取字符，Writer是字符输出流，用于向某个目标设备写入字符。其API跟字节流的类似。 输入字符流(FileReader)import java.io.*; public class Example{ public static void main(String[] args){ FileReader reader=new FileReader(&quot;reader.txt&quot;); int ch; while((ch=reader.read())!=-1) { System.out.println((char)ch);//通过read()方法读取到的是int类型的值，所以需要进行强制转换。 } reader.close(); } } 输出字符流(FileWrite)import java.io.*; public class Example{ public static void main(String[] args){ FileWrite out=new FileWrite(目标文件的路径); String str=&quot;hello world&quot;; out.write(str); out.close(); } } 字符缓冲流(BufferedWriter和BufferedReader) 字符流同样提供了带缓冲区的包装流，分别是BufferedWriter和BufferedReader,其中BufferedReader用于对字符输入流的包装，BufferedWriter用于对字符输出流的包装。需要注意的是，在BufferedReader中有一个重要的方法readLine()，该方法用于一次读取一行文本。 import java.io.*; public class Example{ public static void main(String[] args){ String fileName=&quot;xxx&quot;;//源文件路径 String fileName2=&quot;xxx&quot;;//目标文件路径 Reader reader=null; BufferedReader bf=null; Writer writer=null; BufferedWriter bw=null; try { reader = new Reader(fileName); br=new BufferedReader(reader); writer = new Writer(fileName2); bw=new BufferedWriter(writer); String str; while ((str = bf.readLine())!= null) { bw.write(str); bw.newLine();//写入一个换行符，该方法会根据不同的操作系统生成相应的换行符。 } }catch (Exception e) { throw new RuntimeException(e); }finally { try { if (reader != null) reader.close(); if (br !=null) br.close(); if (writer!=null) writer.close(); if (bw !=null) bw.close(); }catch (Exception e) { throw new RuntimeException(e); } } } } 关键点设置int变量接收读到的字节还有字节数组形式的方法还有用System.out.println(in.read());输出字节到控制台的形式的（设置类型转换）,以及字符缓冲流的readline和newline()方法的方法Demo: 字节字符转换流(InputStreamReader和OutputStreamWriter)转换流也是一种包装流，其中OutputStreamWriter是Writer的子类，它可以将一个字节输出流包装成字符输出流，方便直接写入字符，而InputStreamReader是Reader的子类，它可以将一个字节输入流包装成字符输入流，方便直接读取字符。 import java.io.*; public class Example{ public static void main(String[] args){ String fileName=&quot;XXX&quot;;//源文件路径 String fileName2=&quot;XXX&quot;;//目标文件路径 InputStreamReader isr=new InputStreamReader(new FileInputStream(fileName1)); BufferedReader br=new BufferedReader(isr); OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream(fileName2)); BufferedWriter bw=new BufferedWriter(osw); String line; while((line=br.readLine())!=null) { bw.write(line); } br.close(); bw.close(); } } 其他IO流ByteArrayInputStream和ByteArrayOutputStream在前面的学习中，都是将文件直接存储到硬盘，但有时候我们希望将文件临时存储到缓冲区，方便以后读取。为此JDK中提供了一个ByteArrayOutputStream类。该类会在创建对象时就创建一个byte型数组的缓冲区，当向数组中写数据时，该对象会把所有的数据先写入缓冲区，最后一次行写入文件。Demo:将数据写入缓冲区 import java.io.*; public class Example{ public static void main(String[] args){ String fileName1=&quot;/Users/codingBoy/Desktop/example1.jpg&quot;;//源文件路径 String fileName2=&quot;/Users/codingBoy/Desktop/example2.jpg&quot;;//目标文件路径 FileInputStream in=new FileInputStream(fileName1); ByteArrayOutputStream bos=new ByteArrayOutputStream(); FileOutputStream out=new FileOutputStream(fileName2); int b; while((b=in.read())!=-1) { bos.write(b); } in.close(); bos.close(); out.write(bos.toByteArray());//先将数据写入缓冲区，当需要写入目标文件中的时候再调用输出流的write(bos.toByteArray())方法。 out.close(); } 将从fileName1文件中读取的字节全部写入该对象的缓冲区，通过FileOutputStream对象将缓冲区的数据一次性写入fileName2文件。与ByteArrayOutputStream类似，ByteArrayInputStream是从缓冲区中读取数据，接下来通过一个案例来演示ByteArrayInputStream如何读取缓冲区的数据。 import java.io.*; public class Example{ public static void main(String[] args){ byte[] bytes=new byte[]{97,98,99,100}; ByteArrayInputStream bis=new ByteArrayInputStream(bytes); int b; while((b=bis.read())!=-1) { System.out.println((char)b); } } 对象序列化和反序列化待更新 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC之高级知识点]]></title>
    <url>%2F2018%2F09%2F25%2FJDBC%E4%B9%8B%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[事务管理事务的四大特性（ACID） 原子性:事务中的所有操作要么全部执行成功，要么执行全部失败。 一致性:事务执行后，数据库状态与其它业务规则保持一致。 张三必须扣100，李四必须加100，这个就是一致性了，如果因为某些逻辑原因，导致张三扣了100，流水记录100转账，而李四只加了60。然后这3条操作都成功了，那原子性就符合了，但是一致性就不符合了 隔离性:隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。 持久性:一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中。即使提交事务后数据库马上崩溃，在数据库重启后，也必须能保证通过某种机制恢复数据。 mysql中操作数据库 在控制台中输入语句:start transaction;即开始事务。 在控制台中输入语句:rollback;回滚事务，即在此事务中执行的操作全部无效，数据库回到start transaction;之前(但是前提是使用该语法前没有执行commit transaction;操作)。 在控制台中输入语句:commit transaction;即提交事务。 注意这个在测试时，未commit transaction时，是看不出效果的。 JDBC中操作事务事务的隔离级别事务的并发读问题 脏读:读取到另一份事务未提交数据，即读到了脏数据。也就是当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。 不可重复读：两次读取不一致。对统一记录的两次读取不一致，因为另一事务对该记录做了修改。当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义 幻读：又叫虚读。对同一张表的两次查询不一致，因为另一事务进行了插入了一条记录的操作。事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。也就是说，当前事务读第一次取到的数据比后来读取到数据条目少。 四大隔离级别(防止上述问题) SERIALIZABLE(串行化)：不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的。性能最差，可能导致死锁。 REPEATABLE READ(可重复读)(mysql默认级别)：防止脏读和不可重复读，不能处理幻读问题。性能比a的好。 READ COMMITTED(读已提交数据)(Oracle默认级别)：防止脏读，没有处理不可重复读，也没有处理幻读。性能比上述b好。 READ UNCOMMITTED(读未提交数据):可能出现任何事务并发问题。性能最好。但基本没人用。 查看mysql隔离级别 在控制台中输入语句:select @@tx_isolation;也可以通过下面命令来设置隔离级别:set transaction isolationlevel[4选1]; 在Jdbc中设置隔离级别con.setTransactionisolation[int lever]; 数据库连接池用户每次请求都需要向数据库获得链接，而数据库创建连接通常需要消耗相对较大的资源，创建时间也较长。假设网站一天10万访问量，数据库服务器就需要创建10万次连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。 数据库连接是一种关键的有限的昂贵的资源,这一点在多用户的网页应用程序中体现的尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正式针对这个问题提出来的。数据库连接池负责分配，管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中, 这些数据库连接的数量是由最小数据库连接数来设定的.无论这些数据库连接是否被使用,连接池都将一直保证至少拥有这么多的连接数量.连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数,当应用程序向连接池请求的连接数超过最大连接数量时,这些请求将被加入到等待队列中。 设置池参数设置初始化大小:connection.setInitialSize(); 设置最小空闲连接数:connection.setMinIdle(); 设置最大空闲连接数:connection.setMaxIdle(); 设置最小连接数:connection.setMinActive(); 设置最大连接数:connection.setMaxActive(); 设置增量:一次创建的最小单位。 设置最大的等待时间:connection.setMaxWait(); c3p0数据库连接池c3p0,全名叫ComboPooledDataSource; 需要导入的jar包连接池的实现:c3p0-0.9.5.2.jar和依赖库:mchange－commons.jar实例: public class Demo{ public static void main(String[] args) { //创建连接池对象 ComboPooledDataSource dataSource=new ComboPooledDataSource(); //进行四大参数的配置 dataSource.setDriverClass(“com.mysql.jdbc.Driver”); dataSource.setJdbcUrl(“jdbc:mysql://localhost:3306/mydb”); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;123&quot;); //池配置 dataSource.setAcquireIncrement(5); dataSource.setInitialPoolSize(20); dataSource.setMinPoolSize(2); dataSource.setMaxPoolSize(50); Connection con=dataSource.getConnection(); System.out.println(con); con.close(); } } c3p0配置文件的使用： 文件名称:必须叫c3p0-config.xml。文件的位置:必须在src下。 实例: public class Demo{ public static void main(String[] args) { //在创建连接池对象时，这个对象就会自动加载配置文件，不用我们来指定。 ComboPooledDataSource data=new comboPooledDataSource(); Connection con=data.getConnection(); System.out.println(con); } } Tomcat服务器配置数据库连接池JNDI:java命名和目录接口。作用:在服务器上配置资源，然后通过统一的方式来获取配置的资源。首先需要在Tomcat/conf/Catelina/localhost目录下新建文件名: 项目名.xml 获取资源的代码: Context initCtx=new InitialContext();//创建一个上下文。 Context envCtx=(Context) initCtx.lookup(“java:comp/env”);//这个路径是固定的不能改。 MyBean bean=(MyBean)envCtx.lookup(“bean/MyBeanFactory”);//通过该上下文进行二次查找才能找到资源 测试: dbtils结果集处理器介绍需要导入的jar包:common-dbutil.jar;c3p0.jar;mchange-commons.jar。关键要得到QueryRunner对象，然后调用其各种方法。 update()方法: int update(String sql,Object… params) 可执行增删改语句。重载方法int update(Connection con,String sql, Object… params)需要调用者提供Connection，这说明本方法不再管理Connection了。本重载方法支持事务。 query()方法: T query (String sql,ResultSetHandler rsh,Object… params)可执行查询操作。 重载方法:T query(Connection con,String sql,ResultSetHandler rsh,Object… params); 本重载方法支持事务。它会先得到ResultSet，然后调用rsh的handle()把rs转换成需要的类型。 ResultSetHandler接口 BeanHandler(单行)－－&gt;构造器需要一个class类型的参数，用来把一行结果转换成指定类型的javaBean对象。 BeanListHandler(多行)—&gt;构造器也是需要一个Class类型的参数，用来把一行结果集转换成一个javabean，哪么多行就是转换成List对象，一堆javabean。 MapHandler(单行)—&gt;把一行结果集转换成Map对象。 MapListHandler(多行)—&gt;把一行记录转换成一个Map，多行就是多个Map，即List。 ScalarHandler(单行单列)－&gt;同来用于select count(＊)from t_stu语句，结果集是单行单列的，它返回一个Object，就是count(*)的值，为long类型。 dbutil结果处理集原理代码: public class QR { private DataSource dataSource; public QR(DataSource dataSource) { this.dataSource=dataSource; } public QR(){ super(); } public int update(String sql,Object... params) { Connection con=null; PreparedStatement pstmt=null; try { con=dataSource.getConnection();//通过连接池得到连接对象 pstmt=con.prepareStatement(sql); initParams(pstmt,params);//给出参数 return pstmt.executeUpdate();//调用update执行增、删、该 }catch (Exception e) { throw new RuntimeException(e); }finally { try{ if (pstmt!=null) pstmt.close(); if (con!=null) con.close(); }catch (SQLException e){} } } //给参数赋值 public void initParams(PreparedStatement pstmt,Object... params) throws SQLException { for (int i = 0; i &lt; params.length; i++) { pstmt.setObject(i+1,params[i]); } } public T query(String sql,RsHandler&lt;T&gt; rh,Object... params) throws SQLException { Connection con=null; PreparedStatement pstmt=null; ResultSet rs=null; try { con=dataSource.getConnection();//通过连接池得到连接对象 pstmt=con.prepareStatement(sql); initParams(pstmt,params);//给出参数 rs=pstmt.executeQuery();//调用update执行增、删、该 return rh.handle(rs); }catch (Exception e) { throw new RuntimeException(e); }finally { if (rs!=null) rs.close(); if (pstmt!=null) pstmt.close(); if (con!=null) con.close(); } } interface RsHandler&lt;T&gt; { public T handle(ResultSet rs); } } 这样我们以后对数据库进行增、删、改操作时，只需写以下代码即可: 1.QueryRunner qr=new QueryRunner(JdbcUtils.getDataSource);//创建QueryRunner对象，并传入连接池对象 2.String sql=&quot;insert into user values(?,?,?,?);//给出sql语句模板 3.Object[] params={参数1，参数2，参数3，参数4};//传入参数 4.qr.update(sql,params);//调用qr方法。 通过这简单的四步就可以对数据库进行增删改了。 在jar包中，QueryRunner类的update(没有connection参数的)方法，在finally中将connection进行了关闭;在update(有connection参数的)方法中，在finally中没有对connection进行关闭(暂时这么记吧，不然要是进行关闭了的话，在传智播客写的小工具封装类TxQueryRunner中将connection传入JdbcUtils的releaseConnecion()方法中对connection进行关闭时会出现报错)。 在讲到事务时，我们会对QueryRunner进行再次封装。上述写出的QueryRunner的代码只是包中的QueryRunner源码方法的一部分(因为源码中还有很多的重载方法)，我们会通过另一个类TxQueryRunner(较QueryRunner多出的一个功能就是它支持事务)继承该类，在TxQueryrunner类中，对connection进行了判断:若connection为事务中的connection则在TxqueryRunner的update()方法中不对connection进行关闭，而是在commitTransaction()即提交事务时进行关闭;若connection为普通连接，则将connection进行关闭。那么以后我们在DAO中要获取的就不是QueryRunner对象，而是通过QueryRunner qr=new TxQueryRunner();获取TxQueryRunner对象了。 装饰者模式将对象增强的手段有: 继承 缺点:1.增强的内容是死的，不能动。2.被增强的对象也是死的。 装饰着模式 特点:1.增强的内容是不能修改的。2.被增强的对象可以是任意的。 动态代理AOP 下面通过一个简单的例子来对装饰者模式进行讲解 class 咖啡类 {}; class 加奶咖啡 extends 咖啡类 {}; class 加糖咖啡 extends 咖啡类 {}; class 加盐咖啡 extends 咖啡类 {}; 咖啡 a＝new 加糖咖啡(); 咖啡 b＝new 加盐咖啡(a);//对a进行装饰，就是给a加盐 咖啡 c＝new 加奶咖啡(b);//对b进行装饰，就是给b加奶 装饰者模式在Java API中的IO流中用到的很多。如BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter、ObjectInputStream、ObjectOutputStream这几个都是运用了装饰模式的装饰流。关于的IO流的详情见IO博文。 ThreadLocal早在JDK 1.2的版本中就提供Java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。 Thread API void set(Object value);设置当前线程的线程局部变量的值。 Object get();该方法返回当前线程所对应的线程局部变量。 void remove();将当前线程局部变量的值删除，目的是为了减少内存的占用。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。 ThreadLocal内部结构ThreadLocal内部用Map来保存数据。虽然在使用上述API时没有给出键，但其实它内部使用了当前线程作为键。内部结构见下面demo: class ThreadLocal { private Map&lt;Thread,T&gt; map=new HashMap&lt;Thread,T&gt;(); public void set(T value){ map.put(Thread.currentThread(),value); } public void remove(){ map.remove(Thread.currentThread()); } public T get(){ return map.get(Thread.currentThread()); } } 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>JDBC</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb之JDBC详解]]></title>
    <url>%2F2018%2F09%2F25%2FJavaWeb%E4%B9%8BJDBC%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概念JDBC，全称java database connectity,即Java数据库连接，意思是用Java语言操作数据库，可以为多种数据库提供统一的连接(MySql,Sql Server, Oracle)。原本我们都是通过在命令行或者在数据库图形化界面工具上面输入SQL语句操作数据库。而JDBC则是用Java语言向数据库发送SQL语句来操作数据库。 JDBC流程 获得Connection的对象 导jar包。mysql-connector-java jar 加载驱动类:Class.forName(“类名”); 配置url、username、password等参数 使用DriverManager类来的到Connection对象。 示例: public class Demo{ public void main(String[] args) throws ClassNotFoundException,SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载驱动类。 String url=&quot;jdbc:mysql://localhost:3306/数据库名&quot;; String username=&quot;数据库账号&quot;; String password=&quot;数据库密码&quot;; Connection con=DriverManager.getConnection(url,username,password); } } 代码分析: url的格式为–jdbc:厂商名称:子协议(由厂商自己来规定)。对于mysql而言，它的子协议结构的格式为://localhost:3306/数据库名。 出现SQLException的原因:1.url username password 是否正确。2.检查是否打开了sql服务器 出现ClassNotFoundException的原因:1.没导入驱动包。2.Class.forName()传入的驱动类错误。 JDBC之增删改查增，删，改示例: public class Demo{ public void main(String[] args) throws ClassNotFoundException,SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载驱动类。 String url=&quot;jdbc:mysql://localhost:3306/数据库名&quot;; String username=&quot;root&quot;; String password=&quot;123&quot;; Connection con=DriverManager.getConnection(url,username,password); Statement stmt=con.createStatement(); String sql＝&quot;insert into stu values(&apos;...&apos;,&apos;...&apos;,&apos;...&apos;,&apos;...&apos;)&quot;; stmt.executeUpdate(sql); } } 代码分析: 数据库连接对象调用createStatement()的方法创建Statement对象，它是sql语句的发送器，功能就是向数据库发送sql语句 这里的sql不需要打分号，打了就会出错，因为程序会自动帮我们加。 调用此方法向数据库发送sql语句。该语句返回的值为改变数据库的行数。 查询public class Demo{ public void main(String[] args) throws ClassNotFoundException,SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载驱动类。 String url=&quot;jdbc:mysql://localhost:3306/数据库名&quot;; String username=&quot;root&quot;; String password=&quot;123&quot;; Connection con=DriverManager.getConnection(url,username,password); Statement stmt=con.createStatement(); String sql=&quot;selece * from stu&quot;; ResultSet rs=stmt.execute(sql);//ResultSet提供了一系列的getXxx()方法 while(rs.next())//第一次调用next()方法是将光标移动到该表的第一行 { rs.getInt(1);//通过列编号来获取该列的值，如果第一列是id，此时得到id的值 rs.getString(&quot;name&quot;);//通过列名称来获取该列的值。 } } } 关闭资源因为数据库连接重要的资源，所以不用时应该及时关闭。关闭资源时采用倒关的手法将对象进行处理:即先得到的对象后关，后得到的对象先关 PreparedStatement接口PrepaerdStatement是Statement的子接口，下面通过一个例子了解PreparedStatement。示例: public class Demo{ public void main(String[] args) throws ClassNotFoundException,SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载驱动类。 String url=&quot;jdbc:mysql://localhost:3306/数据库名&quot;; String username=&quot;root&quot;; String password=&quot;123&quot;; Connection con=DriverManager.getConnection(url,username,password); String sql=&quot;insert into stu values(?,?)&quot;;//定义sql模板，即参数以问号的形式给出 PreparedStatement pst=con.prepaerStatement(sql); pst.setString(1,username);//数字1代表第一个问号 pst.setString(2.password);//数字2代表第二个问号 pst.executeUpdate();//向数据库发送sql语句 } } 原理： 检验sql语句的语法 编译：一个与函数相似的东西 执行：调用函数 Java中的时间类型和mysql中的时间类型转换数据库类型与Java中类型的对应关系 数据库中的DATE–&gt;java.sql.Date–&gt;java.util.Date; 数据库中的TIME–&gt;java.sql.Time–&gt;java.util.Date; 数据库中的TIMESTAMP–&gt;java.sql.Timestamp–&gt;java.util.Date; 需要注意的是: (面向对象的架构模式)领域对象(domain)中的所有属性不能出现java.sql包下的东西，即不能使用java.sql.Date、java.sql.Time、java.sql.TimeStamp。 ResultSet的getDate()返回的是java.sql.Date()。 PreparedStatment的setDate(int,Date),其中第二个参数是sql包下的java.sql.Date()。为了在java中使用sql包下的时间类型，这时就出现了时间类型的转换。 具体的转换将util包下的Date转换为sql包下的Date、Time、Timestamp 把util的的Date转换成毫秒值。 使用毫秒值创建sql的Date、Time、Timestamp java.util.Date date=new java.util.Date(); long l=date.getTime(); java.sql.Date sqlDate=new java.sql.Date(l); 将sql包下的Date、Time、Timestamp转换为util包下的Date 因为sql包下的Date、Time、和Timestamp继承自util包下的Date。所以可以直接用; 实际上关于转换日期以及格式化日期的内容还有很多，下面是几个Demo1.String类型的转换为日期，并格式化String str= scan.next().toString();2.JSTL的fmt标签3.easyui的data_grid日期格式转换 JDBC之数据库存取大文件示例:存 String sql = &quot;INSERT INTO tab_bin VALUES(?,?,?)&quot;; PreparedStatement pstmt = con.prepareStatement(sql); pstmt.setInt(1,001); pstmt.setString(2,&quot;hello.mp3&quot;); // mp3 保存为 blob 类型的数据 // 通过 commons-io 工具类, 将 mp3 转换成 byte[] Byte[] bytes = IOUtils.toByteArray(new FileInputStream(&quot;/Users/姓名/Desktop/hello.mp3&quot;)); // 使用 bytes, 创建 Blob 对象 Blob blob = new SerialBlob(bytes); pstmt.setBlob(3,blob); // 发送 sql 语句 pstmt.executeUpdate(); 示例:取 String sql = &quot;SELECT * FROM tab_bin&quot;; PreparedStatement pstmt = con.prepareStatement(sql); ResultSet rs = pstmt.executeQuery(); // 将 rs 中名为 data 列的数据 if(rs.next()){ Blob blob = rs.getBlob(&quot;data&quot;); // 把 blob 转换成硬盘上的 mp3 文件 // 1. 通过 blob 得到输入流对象 // 2. 自己创建输出流对象 // 3. 把输入流的数据写入到输出流中 InputStream in = blob.getBinaryStream(); OutputStream out = new FileOutputStream(&quot;/Users/姓名/Document/world.mp3&quot;); // 使用io流工具类中的方法 IOUtils.copy(in,out); 批处理批处理只针对更新(增、删、改)当需要向数据库发送多条sql语句时, 为了提升执行效率, 可以考虑采用JDBC的批处理机制.JDBC的批处理机制主要涉及Statement或PreparedStatement对象的以下方法： addBatch(String sql) ：Statement类的方法, 多次调用该方法可以将多条sql语句添加到Statement对象的命令列表中. addBatch(): PreparedStatement类的方法, 多次调用该方法可以将多条预编译的sql语句添加到PreparedStatement对象的命令列表中.执行批处理时将一次性的把这些sql语句发送给数据库进行处理. executeBatch()：把Statement对象或PreparedStatement对象命令列表中的所有sql语句发送给数据库进行处理. clearBatch(): 清空当前sql命令列表. 采用Statement.addBatch(sql)方式实现批处理的优缺点： 优点：可以向数据库发送多条不同的ＳＱＬ语句。 缺点：SQL语句没有预编译。当向数据库发送多条语句相同，但仅参数不同的SQL语句时，需重复写上很多条SQL语句 采用PreparedStatement.addBatch()方式实现批处理的优缺点: 优点：发送的是预编译后的SQL语句，执行效率高。 缺点：只能应用在SQL语句相同，但参数不同的批处理中。因此此种形式的批处理经常用于在同一个表中批量插入数据，或批量更新表的数据。 注意:mysql默认批处理是关闭的，需要在url参数后面加上?rewriteBatchedStatement=true; 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>JDBC</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码检查规范CheckStyle和PMD的配置使用]]></title>
    <url>%2F2018%2F09%2F21%2F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E8%A7%84%E8%8C%83CheckStyle%E5%92%8CPMD%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[CheckStyle是SourceForge下的一个项目，提供了一个帮助JAVA开发人员遵守某些编码规范的工具。它能够自动化代码规范检查过程，从而使得开发人员从这项重要，但是枯燥的任务中解脱出来。PMD是一种开源分析Java代码错误的工具。与其他分析工具不同的是，PMD通过静态分析获知代码错误。也就是说，在不运行Java程序的情况下报告错误。PMD附带了许多可以直接使用的规则，利用这些规则可以找出Java源程序的许多问题。现在就来看看它们的安装配置和使用吧。 CheckStyle插件的安装与配置安装CheckStyle插件 CheckStyle插件的配置 当安装好插件，打开 IDEA的设置页面 settings -&gt; Other Settings 你会发现默认的 Checkstyle , 勾选就OK了,如上图。其实在还可以点击上面绿色加号添加自定义checkstyle文件，该文件放在项目的根目录。在里面可以设置你想要的格式。基本的配置就完毕了。现在 IDEA的控制面板会多一个 CheckStyle，你可以在这里方便的进行代码检查。可以点击面板的左上角下拉框 Rules 去动态切换不同的 checkstyle。 CheckStyle插件的使用完成安装与配置之后CheckStyle，便可以运行CheckStyle。根据CheckStyle扫描结果对应修改。 定制专属CheckStyle检查规则 CheckStyle不管是插件方式还是脚本方式，使用都是相当方便快捷的，而难点在于如何定制专属于我们项目的CheckStyle检查规则。 定制CheckStyle规则大致思路：通过对Google 提供的checkStyle检查规则修改完善，打造出属于自己的检查规则。谷歌配置文件规则 在配置文件中中主要由module 、property、message等节点构成： module节点 主要是指检查项，如MethodName （检查方法命名）module中有两个比较重要的节点，它们分别是Checker（checkStyle配置文件的根节点，必须存在）、TreeWalker（树遍历器），TreeWalker会自动去检查指定范围内的每一个java源文件，TreeWalker内部会定义很多module。 property 节点对应module 检查项中具体检查属性，如果使用默认值，property节点可以省略 message节点 checkStyle检查出来，是否打印出message消息，message节点可以省略 如何添加过滤能力？ 解决办法：在定制好的checkStyle.xml文件中，添加一个名为SuppressionFilter的moudle，在过滤规则文件suppressions.xml中添加相应的过滤规则。 PMD插件的安装和使用 自动安装：file –&gt; settings –&gt; plugins 搜索 pmd 用户可以选择在单个或者多个文件或文件夹上运行PMD：选中 文件或文件夹 –&gt; 右击 –&gt; Run PDM –&gt; 选择规则集 联系 Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于抽象类和接口]]></title>
    <url>%2F2018%2F09%2F20%2F%E5%85%B3%E4%BA%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[对于面向对象编程来说，抽象是它的一大特征之一。在Java中，可以通过两种形式来体现OOP的抽象：接口和抽象类。这两者有太多相似的地方，又有太多不同的地方。很多人在初学的时候会以为它们可以随意互换使用，但是实际则不然。下面我们一起来学习一下Java中的接口和抽象类： 什么是抽象方法和抽象类在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现(方法体)，包含抽象方法的一定是抽象类。抽象方法和抽象类的声明格式分别为： 抽象方法: abstract void fun(); 抽象类:abstract class ClassName {abstract void fun();} 关于抽象类 抽象类并不能被实例化，它是为了继承而存在的。 如果一个类继承于一个抽象类，那么它必须实现父类的抽象方法，除非它自己也是抽象类。 什么是接口在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对行为的抽象。 接口中可以含有变量，而方法会被隐式地指定为public abstract方法，它是一种极度抽象的类型，它比抽象类更加“抽象” 接口中的变量会被隐式地指定为public static final变量，但是一般情况下不在接口中定义变量。 抽象类和接口的区别1.语法层面上的区别 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法； 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 2.设计层面上的区别 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 接口存在的意义接口就是为了实现多继承的抽象类，是一种高度抽象的模板、标准或者说协议。规定了什么东西该是这样，如果你继承了我这接口，就必须这样。比如USB接口，就是小方口，两根电源线和两根数据线，不能多不能少。 什么时候用抽象类，什么时候用接口 如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。 如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。 联系 Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码重构的方式理解MVC模式]]></title>
    <url>%2F2018%2F09%2F20%2F%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E7%9A%84%E6%96%B9%E5%BC%8F%E7%90%86%E8%A7%A3MVC%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[MVC模式是基于WEB系统模块化框架的大思想，繁衍出的一个把视图和处理做低耦合分离的一种模式。核心就是尽可能让一个后台系统，在几乎不做任何修改的情况下，同时支持多种视图。但是它的缺点是由于它没有明确的定义，所以完全理解MVC并不是很容易。使用MVC需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。 接下来我将以代码重构的方式帮助我们更好地理解MVC设计模式。 关于MVC设计模式MVC模式（Model-View-Controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）： Model——业务功能编写（例如算法实现）、数据库设计以及数据存取处理等操作实现 Controller——负责转发请求并对请求进行处理 View——负责界面显示 在JSP/Servlet开发的软件系统中，这三个部分的实现如下所示： Web浏览器发送HTTP请求到服务端，被Controller(Servlet)获取并进行处理（例如参数解析、请求转发） Controller(Servlet)调用核心业务逻辑——Model部分，获得结果 Controller(Servlet)将逻辑处理结果交给View（JSP），动态输出HTML内容 动态生成的HTML内容返回到浏览器显示 MVC模式在Web开发中的好处是非常明显，它规避了JSP与Servlet各自的短板，Servlet只负责业务逻辑而不会通过out.append()动态生成HTML代码；JSP中也不会充斥着大量的业务代码。这大大提高了代码的可读性和可维护性。本博文相关github代码如下点击进入github 具体体现 在进行代码重构之前的Servlet代码: @SuppressWarnings(&quot;serial&quot;) public class ListServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { try { //设置编码 req.setCharacterEncoding(&quot;UTF-8&quot;); //获取页面的值 String command = req.getParameter(&quot;command&quot;); String description = req.getParameter(&quot;description&quot;); //向页面传接到的值 req.setAttribute(&quot;command&quot;, command); req.setAttribute(&quot;description&quot;, description); Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis&quot;, &quot;root&quot;, &quot;123456&quot;); StringBuilder sql = new StringBuilder(&quot;select ID, COMMAND, DESCRIPTION, CONTENT from MESSAGE where 1 = 1&quot;) ; List&lt;String&gt; paramList = new ArrayList&lt;&gt;();//缓冲,添加动态传参 if (command != null &amp;&amp; !&quot;&quot;.equals(command.trim())) { sql.append( &quot; and COMMAND = ?&quot;); paramList.add(command); } if (description != null &amp;&amp; !&quot;&quot;.equals(description.trim())) { sql.append( &quot; and DESCRIPTION like &apos;%&apos; ? &apos;%&apos;&quot;); paramList.add(description); } PreparedStatement statement = conn.prepareStatement(sql.toString()); for (int i = 0; i &lt; paramList.size(); i++) { //sql语句从1开始的，所以i+1 statement.setString(i+1, paramList.get(i)); } ResultSet rs = statement.executeQuery(); List&lt;Message&gt; messageList = new ArrayList&lt;&gt;(); while(rs.next()) { Message message = new Message(); messageList.add(message); message.setId(rs.getString(&quot;ID&quot;)); message.setCommand(rs.getString(&quot;COMMAND&quot;)); message.setDescription(rs.getString(&quot;DESCRIPTION&quot;)); message.setContent(rs.getString(&quot;CONTENT&quot;)); } //查询消息列表并传给页面 req.setAttribute(&quot;messageList&quot;, messageList); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } req.getRequestDispatcher(&quot;/WEB-INF/jsp/back/list.jsp&quot;).forward(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } 上述servlet代码不仅负责了业务逻辑代码，如获取页面的值，向页面传接收到的值，还包括了获取数据库驱动，获取数据库连接和相关的数据库操作代码。这样使得servlet的代码过于冗长，代码的可读性，可维护性差 下面是代码重构之后的servlet @SuppressWarnings(&quot;serial&quot;) public class ListServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //设置编码 req.setCharacterEncoding(&quot;UTF-8&quot;); //获取页面的值 String command = req.getParameter(&quot;command&quot;); String description = req.getParameter(&quot;description&quot;); //向页面传接到的值 req.setAttribute(&quot;command&quot;, command); req.setAttribute(&quot;description&quot;, description); ListService listService = new ListService(); //查询消息列表并传给页面 req.setAttribute(&quot;messageList&quot;, listService.queryMessageList(command, description)); req.getRequestDispatcher(&quot;/WEB-INF/jsp/back/list.jsp&quot;).forward(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } 下面的代码是重构之后的dao代码: public class MessageDao { public List&lt;Message&gt; queryMessageList(String command, String description){ List&lt;Message&gt; messageList = new ArrayList&lt;&gt;(); try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis&quot;, &quot;root&quot;, &quot;123456&quot;); StringBuilder sql = new StringBuilder(&quot;select ID, COMMAND, DESCRIPTION, CONTENT from MESSAGE where 1 = 1&quot;) ; List&lt;String&gt; paramList = new ArrayList&lt;String&gt;();//缓冲,添加动态传参 if (command != null &amp;&amp; !&quot;&quot;.equals(command.trim())) { sql.append( &quot; and COMMAND = ?&quot;); paramList.add(command); } if (description != null &amp;&amp; !&quot;&quot;.equals(description.trim())) { sql.append( &quot; and DESCRIPTION like &apos;%&apos; ? &apos;%&apos;&quot;); paramList.add(description); } PreparedStatement statement = conn.prepareStatement(sql.toString()); for (int i = 0; i &lt; paramList.size(); i++) { statement.setString(i+1, paramList.get(i)); } ResultSet rs = statement.executeQuery(); while(rs.next()) { Message message = new Message(); //先放和后放是一样的，因为容器里面放的都是引用，不是真正的对象本身，所以接下来对这个对象操作依然有效 messageList.add(message); message.setId(rs.getString(&quot;ID&quot;)); message.setCommand(rs.getString(&quot;COMMAND&quot;)); message.setDescription(rs.getString(&quot;DESCRIPTION&quot;)); message.setContent(rs.getString(&quot;CONTENT&quot;)); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } return messageList; } } 下面是重构之后的数据库连接代码 public class DBHelper { private static final String driver = &quot;com.mysql.jdbc.Driver&quot;; //因为这些变量都是，全局的不需要修改的，固定的写法，所以设置为静态的私有的 private static final String url=&quot;jdbc:mysql://localhost:3306/shopping?useUnicode=true&amp;characterEncoding=UTF-8&quot;; private static final String username=&quot;root&quot;; private static final String password=&quot;123456&quot;; private static Connection conn=null; //静态代码块负责加载驱动 static { try { Class.forName(driver); } catch(Exception ex) { ex.printStackTrace(); } } public static Connection getConnection() throws Exception//static关键字表示类方法，直接通过类名调用 { if(conn==null) { conn = DriverManager.getConnection(url, username, password); return conn; } return conn; } public static void main(String[] args) { try { Connection conn = DBHelper.getConnection(); if(conn!=null) { System.out.println(&quot;数据库连接正常&quot;); } else { System.out.println(&quot;数据库连接异常&quot;); } } catch(Exception ex) { ex.printStackTrace(); } } } 通过代码重构可以清楚的发现，使用MVC设计模式的项目的代码可读性更高，可维护性更高。但是其实MVC设计模式也有它的不足: 增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。 视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。 联系如果需要联系作者，请在主页点击右下角的微信图标，或者通过以下方式: Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合工程的搭建]]></title>
    <url>%2F2018%2F09%2F17%2FSSM%E6%95%B4%E5%90%88%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[当我们系统的学完了Spring、Spring MVC以及Mybatis之后就可以进行这三者的整合工作了，也就是SSM框架的整合，其实就是将这三个框架的配置文件提取出来放在一个项目中，然后便可以进行开发，是不是觉得挺简单的。这篇文章我们将在前篇文章Mybatis与Spring整合的基础上将Spring MVC的配置引入进来完成SSM框架的整合。 整合的思路 在Mybatis与Spring3整合的基础上再进行Spring MVC框架的整合。 Spring要管理Spring MVC编写的Handler(controller)、Mybatis的SqlSessionFactory、mapper、数据源。其实整合思路就是下面这三步: 第一步:整合dao(即mapper)，完成Spring与Mybatis的整合 第二步:整合service，Spring管理service接口，service中可以调用Spring容器中的dao(mapper)。 第三步:整合controller，Spring管理controller接口，在controller调用service。 pom.xml的需要导入的依赖&lt;!--添加mybatis-generator-core.jar依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.30&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;${log4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- 映入JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传组件包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; pom.xml的需要导入的配置&lt;properties&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt; &lt;!-- log4j日志文件管理包版本 --&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;!-- 强制将xml文件打到war包中 s--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; spring-mybatis.xml,spring-mvc.xml和web.xml spring-mybatis.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;dao&quot; /&gt; &lt;context:component-scan base-package=&quot;pojo&quot; /&gt; &lt;context:component-scan base-package=&quot;mapping&quot; /&gt; &lt;context:component-scan base-package=&quot;service&quot; /&gt; &lt;context:component-scan base-package=&quot;serviceimpl&quot; /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;${initialSize}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;${maxActive}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;${maxIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;${minIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;${maxWait}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapping/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; spring-mvc.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package=&quot;controller&quot; /&gt; &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;mappingJacksonHttpMessageConverter&quot; /&gt; &lt;!-- JSON转换器 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 默认编码 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot; /&gt; &lt;!-- 文件大小最大值 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760000&quot; /&gt; &lt;!-- 内存中的最大值 --&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring和mybatis的配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 防止Spring内存溢出监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Spring MVC servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 此处可以可以配置成*.do，对应struts的后缀习惯 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 然后，在src下创建各个包:mapper、po、controller、service，在web包下创建页面包jsp。经过上述步骤，我们便完成了Spring、Spring MVC与Mybatis的整合，是不是很简单?没错就是这么简单。 联系如果需要联系作者，请在主页点击右下角的微信图标，或者通过以下方式: Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA创建MyBatis逆向工程]]></title>
    <url>%2F2018%2F09%2F17%2FIDEA%E5%88%9B%E5%BB%BAMyBatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[过去我们在开发时都需要通过数据库中的表然后自己在po包下手动建立相对应的pojo类，并要创建相应的mapper.xml写出对表的所有操作，而使用插件mybatis-generator-core生成mybatis逆向工程就不用我们自己再编写pojo类与相应的mapper类和相应的xml文件，它可以自动对单表生成sql，包括:mapper.xml、mapper.java、表名.java(po类)。这是非常方便快捷的。下面我将为你们介绍如何使用插件生成mybatis的逆向工程，只需三步而已。 逆向工程的部署话不多说，直接上图，点击运行即可生成相应的entity类，dao接口和mapper.xml。相关代码文件请移步我的github点击进入我的github pom.xml的需要导入的依赖和配置 需要导入的jar包和依赖 &lt;!-- -添加mybatis-generator-core插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;/dependency&gt; 此外还需要右击项目新建一个Direcrory,命名为lib,将数据库驱动包放进去 需要更改的配置 &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; 逆向工程的配置文件generatorConfig.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;!-- 数据库驱动--&gt; &lt;classPathEntry location=&quot;lib/mysql-connector-java-5.0.5-bin.jar&quot;/&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/ssmtest&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;!--设置为 true 可以获取 tables 信息, 解决生成文件缺少 xxxByPrimaryKey 的问题 --&gt; &lt;property name=&quot;useInformationSchema&quot; value=&quot;true&quot;/&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置--&gt; &lt;javaModelGenerator targetPackage=&quot;pojo&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage=&quot;mapping&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;dao&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName=&quot;user_t&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 关键的属性: javaModelGenerator,生成PO类的位置 sqlMapGenerator,mapper映射文件生成的位置 javaClientGenerator,mapper接口生成的位置 table,其tableName属性对应数据库中相应表 配置相应的运行命令点击Edit Configuration，点击+号，在Command line中输入mybatis-generator:generate -e然后点击应用，选择运行，等一会逆向工程便成功地建立！ ###需要注意的地方1.多次运行生成逆向工程然后进行SpringJUnit集成测试时，报错Result Maps collection already contains value for … 原因及解决办法:多次使用逆向工程生成mapper接口和xml文件时，是增加，而不是覆盖。所以需要将已经生成的文件删除，重新运行逆向工程。解决问题的根本方法是:在配置文件中 2.使用数据库驱动为8.0.11时生成的DAO接口只生成insert方法,这是特别的坑点，希望大家不要被坑了。 解决的办法:如果使用的mysql驱动是6.x,8.x的，那就无法生成，使用5.x版本的就可以生成。即本博文中的5.0.5. 3.有的人可能会问为什么mapper文件夹会跑到resources目录下。实际上，这个逆向工程生成文件的位置是可以任意的，只要把生成的文件复制到自己的项目下就可以了。我为了后续的开发，把xnl,文件同一放在resource下，但我又懒得改路径，所以直接剪切mapper文件夹到resources目录下了。 联系如果需要联系作者，请在主页点击右下角的微信图标，或者通过以下方式: Github@codinglembre Zhihu@codinglembre Blog@codinglembre -]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis和Spring整合]]></title>
    <url>%2F2018%2F09%2F17%2FMyBatis%E5%92%8CSpring%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[MyBatis是一种开源的半自动的持久化框架，它通过抽象jdbc模板代码提供简单的api交互简化持久层实现。通过读取mybatis.xml，Mapper.xml，Mapper映射了相应的JavaBean，通过SqlSessionFactory的实例化出来的SqlSession，执行对应方法，根据方法名回到Mapper.xml中找到和方法名相对应的id(注释方式的话找到接口类里面注释id对应的方法)，根据sql语句，还有传入的参数，还有Bean，这几者的联系形成的映射，进行CURD操作，省去JDBC那些模板方法代码。Spring也是开源框架，简化了Java开发，其主要功能是依赖注入和面向切面工程。 mybatis和spring整合的思路 使用spring管理SqlSessionFactory 使用spring管理mapper对象和dao 使用spring和mybatis整合开发mapper代理及原始dao接口。自动开启事务，自动管理sqlsession 让spring管理数据源(即数据库连接池) 开始整合工作pom.xml的需要导入的依赖和配置 需要导入的依赖 &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.30&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;${log4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- 映入JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; 整合配置文件spring-MyBatis.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;dao&quot; /&gt; &lt;context:component-scan base-package=&quot;pojo&quot; /&gt; &lt;context:component-scan base-package=&quot;mapping&quot; /&gt; &lt;context:component-scan base-package=&quot;service&quot; /&gt; &lt;context:component-scan base-package=&quot;serviceimpl&quot; /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;${initialSize}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;${maxActive}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;${maxIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;${minIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;${maxWait}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapping/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 至此，MyBatis便和Spring整合成功。 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Markdown语法]]></title>
    <url>%2F2018%2F05%2F27%2F%E5%B8%B8%E7%94%A8Markdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[其实这周挺忙的，各种考试，实验，作业统统集中到一起（内心os:麻木到习以为常了QAQ），但是还是抽空搭建了自己的个人博客网站，第一篇博文也不知道该写什么好，就把昨天自学的Markdown语法写下来了。 关于Markdown，你需要了解的概念Markdown 是一种可以使用 普通文本编辑器编写的轻量级 标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的 语法很简单。常用的标记符号不超过十个。让我们开始学习MarkDown语法吧！ Markdown语法因为MarkDown并不是我的学习方向，我学Markdown只是为了更好的写博文。因此，对于实现的效果相同的语法，我只列出最容易记的那种。若需要系统的学习MarkDown语法，请百度官方文档或者打开点击打开链接链接。 1.段落，标题和区块代码①段落: 一个以上的空行则会划分出不同的段落,一般的段落不需要用空白或换行缩进。(标题和正文之间会自动添加阴影线以及段落) ②标题: 推荐使用ATX形式。即在行首插入1到六个#，对应到标题的1到六阶。 ③区块代码: 区块引用则使用 email 形式的 ‘&gt;’ 角括号。 2.强调 可以在需要强调的位置前后加 两个星号 来标记需要强调的区段。 3.列表(共有两种形式)①无序列表:使用星号， 加号，减号来进行标记,例如 +Candy. +Gum. 效果： Candy. Gum. ②有序列表:使用一般的数字接着一个英文句点,例如 Red Green 效果: Red Green 4.链接(不区分大小写，共有两种形式) ①行内形式: []里写 链接文字，()里写 链接地址, 此外还可以为链接指定title属性，title属性可加可不加 ②参考形式:文中的写法 [链接文字]接上[链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 5图片(类似于链接，分为两种形式) ①行内形式： ![图片Alt]接上(图片地址 “图片Title”) ②参考形式:在文档要插入图片的地方写 ![图片Alt]接上[标记],在文档的最后写上[标记]:图片地址 “Title” 6代码和代码段 ①段落文字中存在代码区段，可以用 反引号 在代码区段左右加一个 `来标记代码区段 ②代码区块已经被格式化,可以使用 tab或者空四个格 ③代码段可以使用 ‘’’代码段’’’ 来实现 需要注意的地方 在设置标题时，#后面务必加上个空格，否则会导致标题效果渲染失败 联系 If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email： Github@codinglembre Zhihu@codinglembre Blog@codinglembre]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>
