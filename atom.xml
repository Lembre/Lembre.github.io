<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>codingLembre&#39;s blog</title>
  
  <subtitle>I have a dream!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://codinglembre.top/"/>
  <updated>2018-10-15T03:34:58.444Z</updated>
  <id>http://codinglembre.top/</id>
  
  <author>
    <name>Lembre</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用查找算法</title>
    <link href="http://codinglembre.top/2018/10/12/%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://codinglembre.top/2018/10/12/常用查找算法/</id>
    <published>2018-10-12T02:35:42.000Z</published>
    <updated>2018-10-15T03:34:58.444Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于查找"><a href="#关于查找" class="headerlink" title="关于查找"></a>关于查找</h3><p>查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法，说是七种，<strong>其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法</strong></p><p>查找算法分类：</p><ul><li>1.静态查找和动态查找；<ul><li>静态或者动态都是针对查找表而言的，如本篇要介绍的顺序查找、二分查找、分块查找。</li><li>动态表指查找表中有删除和插入操作的表,如本篇要介绍的树表查找(二叉树查找、平衡查找树之2-3查找树、平衡查找树之红黑树、B树和B+树查找)、哈希表查找。</li></ul></li><li>无序查找和有序查找。<ul><li>无序查找：被查找数列有序无序均可；</li><li>有序查找：被查找数列必须为有序数列。<h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><h4 id="顺序查找实现思路-O-n"><a href="#顺序查找实现思路-O-n" class="headerlink" title="顺序查找实现思路(O(n))"></a>顺序查找实现思路(O(n))</h4><strong>顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功</strong>；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</li></ul></li></ul><p>复杂度分析：查找成功时的平均查找长度为:(假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;当查找不成功时，需要n+1次比较，时间复杂度为O(n);所以，顺序查找的时间复杂度为O(n)。<br>Demo:</p><pre><code>/**顺序查找平均时间复杂度 O（n）  * @param searchKey 要查找的值  * @param array 数组（从这个数组中查找）  * @return  查找结果（数组的下标位置）  */  public static int orderSearch(int searchKey,int[] array){  if(array==null||array.length&lt;1)      return -1;  for(int i=0;i&lt;array.length;i++){      if(array[i]==searchKey){          return i;      }  }  return -1;     }</code></pre><blockquote><p>总结:其实就是遍历数组</p></blockquote><h4 id="二分查找实现思路-log2n"><a href="#二分查找实现思路-log2n" class="headerlink" title="二分查找实现思路(log2n)"></a>二分查找实现思路(log2n)</h4><p>也称为是折半查找，<strong>属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</strong></p><p>复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；</p><p>需要注意：<strong>折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</strong><br>Demo:</p><pre><code>/**  * 二分查找又称折半查找，它是一种效率较高的查找方法。 [二分查找要求] ：1.必须采用顺序存储结构 2.必须按关键字大小有序排列。  *   * @param array  *            有序数组 *  * @param searchKey  *            查找元素 *  * @return searchKey的数组下标，没找到返回-1  */  public static int binarySearch(int[] array, int searchKey) {  int low = 0;  int high = array.length - 1;  while (low &lt;= high) {      int middle = (low + high) / 2;      if (searchKey == array[middle]) {          return middle;      } else if (searchKey &lt; array[middle]) {          high = middle - 1;      } else {          low = middle + 1;      }  }  return -1;  }</code></pre><p>递归Demo:</p><pre><code>//二分查找，递归版本int BinarySearch2(int a[], int value, int low, int high){int mid = low+(high-low)/2;if(a[mid]==value)    return mid;if(a[mid]&gt;value)    return BinarySearch2(a, value, low, mid-1);if(a[mid]&lt;value)    return BinarySearch2(a, value, mid+1, high);}</code></pre><blockquote><p>总结:是使用while if结构实现递归</p></blockquote><h4 id="分块查找实现思路"><a href="#分块查找实现思路" class="headerlink" title="分块查找实现思路"></a>分块查找实现思路</h4><p><strong>分块查找又称索引顺序查找，它是顺序查找的一种改进方法</strong><br><strong>算法思想：将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素</strong><br>具体步骤:<br>1.首先将查找表分成若干块，在每一块中数据元素的存放是任意的，但块与块之间必须是有序的（假设这种排序是按关键字值递增的，也就是说在第一块中任意一个数据元素的关键字都小于第二块中所有数据元素的关键字，第二块中任意一个数据元素的关键字都小于第三块中所有数据元素的关键字，依次类推）；<br>2.建立一个索引表，把每块中最大的关键字值按块的顺序存放在一个辅助数组中，这个索引表也按升序排列；<br>3.查找时先用给定的关键字值在索引表中查找，确定满足条件的数据元素存放在哪个块中，查找方法既可以是折半方法，也可以是顺序查找。<br>4.再到相应的块中顺序查找，便可以得到查找的结果。<br>Demo：</p><pre><code>/**  * 分块查找  * @param index  索引表，其中放的是各块的最大值  * @param st  顺序表，  * @param key  要查找的值  * @param m   顺序表中各块的长度相等，为m  */  public static int blockSearch(int[] index, int[] st, int key, int m) {  // 在序列st数组中，用分块查找方法查找关键字为key的记录  // 1.在index[ ] 中折半查找，确定要查找的key属于哪个块中  int i = binarySearch(index, key);  if (i &gt;= 0) {      int j = i &gt; 0 ? i * m : i;      int len = (i + 1) * m;      // 在确定的块中用顺序查找方法查找key      for (int k = j; k &lt; len; k++) {          if (key == st[k]) {              System.out.println(&quot;查询成功&quot;);              return k;          }      }  }  System.out.println(&quot;查找失败&quot;);  return -1;  }</code></pre><blockquote><p>总结:理解索引表index(每块中最大的关键字值按块的顺序存放在一个辅助数组中，这个索引表按升序排列)，当在索引表中找不到值时</p></blockquote><h3 id="树表查找"><a href="#树表查找" class="headerlink" title="树表查找"></a>树表查找</h3><h4 id="二叉树查找实现思路-O-logn"><a href="#二叉树查找实现思路-O-logn" class="headerlink" title="二叉树查找实现思路(O(logn))"></a>二叉树查找实现思路(O(logn))</h4><p>基本思想：<strong>二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 </strong><br>二叉查找树:也叫二叉搜索树，或称二叉排序树,或者是一棵空树，或者是具有下列性质的二叉树:</p><ul><li>1.若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>2.若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>3.<strong>任意节点的左、右子树也分别为二叉查找树。</strong> </li></ul><p><strong>二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。</strong><br>不同形态的二叉查找树如下图所示<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-20%20%E4%B8%8B%E5%8D%889.32.50.png" alt=""><br>复杂度分析：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。<br><strong>基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。</strong><br>Demo:</p><pre><code>//定义二叉树数据结构public class TreeNode {int value;TreeNode left;TreeNode right;public TreeNode(int value) {    this.value = value;}}public class TreeSearch {public TreeNode Solution(TreeNode root,int value) {    if (root == null) {        return null;    }    //定义当前节点    TreeNode current = root;    while(current != null) {        if (current.val &lt; value) {            //如果当前节点的值比value小，则从其右子树中开始找            current = current.right;        } else if (current.val &gt; value) {            //如果当前节点的值比value大，则从其左子树中开始找            current = current.left;        } else if (current.val == value) {            //找到则返回这个节点            return current;        }    }    return null;}}</code></pre><h4 id="平衡查找树之2-3查找树-2-3-Tree"><a href="#平衡查找树之2-3查找树-2-3-Tree" class="headerlink" title="平衡查找树之2-3查找树(2-3 Tree)"></a>平衡查找树之2-3查找树(2-3 Tree)</h4><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于查找&quot;&gt;&lt;a href=&quot;#关于查找&quot; class=&quot;headerlink&quot; title=&quot;关于查找&quot;&gt;&lt;/a&gt;关于查找&lt;/h3&gt;&lt;p&gt;查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性
      
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="算法" scheme="http://codinglembre.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法</title>
    <link href="http://codinglembre.top/2018/10/10/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://codinglembre.top/2018/10/10/常用排序算法/</id>
    <published>2018-10-10T09:37:51.000Z</published>
    <updated>2018-10-19T12:12:11.692Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个Java工程师，所以里面的算法都是用Java语言实现的，不过其实不管你用的是哪种语言，实现该算法的思路都是一样的，所以借鉴此篇文章的你即使用的不是Java，看完此片文章的实现思路及其实现代码后你也是可以用其他语言实现的～</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>查找和排序算法是算法的入门知识，其经典思想可以用于很多算法当中，但万变不离其宗，只要熟悉了思想，灵活运用也不是难事。那么常用的排序算法有哪些呢？本篇文章要介绍的排序算法，按照排序的效率分有以下10种:</p><ul><li>1.简单排序:冒泡排序、(直接)选择排序、(直接)插入排序。</li><li>2.高效排序:快速排序、堆排序、希尔排序。</li><li>3.基于分治递归思想的:归并排序。</li><li>4.线性排序:计数排序、桶排序、基数排序。</li></ul><p>按照排序的方式又可分为:</p><ul><li>1.插入排序:直接插入排序、希尔排序。</li><li>2.选择排序:直接选择排序、堆排序。</li><li>3.交换排序:冒泡排序、快速排序。</li><li>4.线性排序:计数排序、基数排序、桶排序;其中基数排序又叫桶排序;</li><li>5.递归排序:归并排序。</li></ul><p>对于这些排序，<strong>我们需要掌握比较各自的优劣、各种算法的思想及其使用场景，还有要会分析算法的时间和空间复杂度，必要时要熟练写出代码。我们可以知道排序算法要么简单有效，要么是利用简单排序的特点加以改进，要么是以空间换取时间在特定情况下的高效排序。</strong>但是这些排序方法都不是固定不变的，需要结合具体的需求和场景来选择甚至组合使用，才能达到高效稳定的目的。所以有句话叫做:<strong>没有最好的排序，只有最适合的排序。</strong></p><h3 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h3><h4 id="冒泡排序实现思想"><a href="#冒泡排序实现思想" class="headerlink" title="冒泡排序实现思想"></a>冒泡排序实现思想</h4><p>大体思想就是<strong>通过与相邻元素的比较和交换来把大的数交换到最后面(从小到大排序)。这个过程类似于水泡向上升一样，因此而得名。 </strong></p><p>对5,3,8,6,4这个无序序列进行冒泡排序。第一次冒泡:从前向后冒泡，5和3比较，5大所以将5和3交换，序列变成3，5，8，6，4;同理5和8比较，5比8小所以不交换;然后8和6比较，8大所以将8和6交换，序列变成3，5，6，8，4;然后8和4比较，进行8和4的交换，这样一次冒泡就完了，结果是将最大的数字8换到了最后面。对剩下的序列依次进行第二次冒泡、…、第n次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为O(n^2)。<br>Demo:</p><pre><code>public class BubbleSort {public static void bubbleSort(int[] arr) {//将要排序的数字放入一个数组中      //判断需要排序的数组是否为空，为空则不进行排序    if(arr == null || arr.length == 0)        return ;    //i控制外循环即总共需要将多少个数字进行排序，j控制内循环即每次循环都会将最大的数排到右边    for(int i=0; i&lt;arr.length-1; i++) {        for(int j=0; j&lt;arr.length-i-1; j++) {                //如果前面的数字大于后面的数字就将前面的数字和后面的数字进行交换，直接最大的数字被排到最右侧            if(arr[j] &gt; arr[j+1]) {                swap(arr, j+1, j);            }        }    }}//交换两个数字的位置public static void swap(int[] arr, int i, int j) {    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;}}</code></pre><p>总结:<br>1.设置外循环从0开始，内循环也从0开始<br>2.arr[j]和arr[j+1]两两比较（注意arr[i+1]决定了j&lt;arr.length-i-1的写法），否则越界。满足条件则执行交换操作而且内层循环的比较终点随着外循环i值改变</p><h4 id="选择排序实现思路"><a href="#选择排序实现思路" class="headerlink" title="选择排序实现思路"></a>选择排序实现思路</h4><p>选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最大的元素放到最右边。但是过程不同，<strong>冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。</strong><br>举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序。第一次选择排序:<strong>首先要循环遍历该数组，选择整体中5以外的最小数来和5交换</strong>，遍历该数组时发现3是最小的数字，那么就会拿3和5交换，一次遍历和排序后就变成了3,5,8,6,4，实现了将最小的数字放在最前面。对剩下的序列依次进行第二次选择和交换、…、第n次选择和交换，最终就会得到一个有序序列。<strong>其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。选择排序的时间复杂度为O(n^2)。</strong><br>Demo:</p><pre><code>public class SelectSort {public static void selectSort(int[] arr) {    if(arr == null || arr.length == 0)        return ;    //    int minIndex = 0;    for(int i=0; i&lt;arr.length-1; i++) { //只需要比较n-1次          //将数组中的第一个数arr[i]即arr[minIndex]作为基准，遍历其后面所有的数字，只要出现比这个数小的，那么就记下这个数的下标并赋给minIndex，遍历完后若该minIndex不等于i，说明找到了最小的值，就将这个数字下标为minIndex的值与基准数字交换之。        minIndex = i;        for(int j=i+1; j&lt;arr.length; j++) { //从i+1开始比较，因为minIndex默认为i了，i就没必要比了。这是在循环遍历最小数            if(arr[j] &lt; arr[minIndex]) {                minIndex = j;            }        }        if(minIndex != i) { //如果minIndex不为i，说明找到了更小的值，交换之。            swap(arr, i, minIndex);        }    }}public static void swap(int[] arr, int i, int j) {    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;}}</code></pre><p>总结:<br>1.设置基准下标minIndex，设置外循环从0开始，将当前i赋值给minIndex<br>2.设置内循环，将基准值对应得数组值与数组的遍历进行比较，满足条件，将下标赋值给基准<br>3.比较基准值与初始值即i是否相等，不想等，则根据这两个下标交换对应的值</p><h4 id="插入排序实现思路"><a href="#插入排序实现思路" class="headerlink" title="插入排序实现思路"></a>插入排序实现思路</h4><p>插入排序不是通过交换位置而是<strong>通过比较找到合适的位置插入元素来达到排序的目的的。</strong>相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。这个原理其实和插入排序是一样的。<br>举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序，<strong>首先假设第一个数的位置是正确的，想一下在拿到第一张牌的时候，没必要整理。</strong>然后第二张牌3要插到5前面，所以把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧。然后拿到第三张牌时8不用动，拿到第四张牌6时要插在8前面，此时8后移一位，拿到第五张牌4时，要插在5前面，从5开始都向后移一位。<strong>注意在插入一个数的时候要保证这个数前面的数已经有序。简单插入排序的时间复杂度也是O(n^2)。</strong><br>Demo：</p><pre><code>public class InsertSort {public static void insertSort(int[] arr) {    if(arr == null || arr.length == 0)        return ;    //这里首先要假设第一个数位置是正确的(arr[0]是第一张牌)；因为要往后移动数字，必须要假设第一个。然后将第二个数字arr[1]比作打扑克时拿到的第二张牌    //i依旧控制需要将多少个数字进行排序(n个数字，n-1次排序，为啥？比如只有两个数字，你肯定只需要进行1次排序啊)    for(int i=1; i&lt;arr.length; i++) {         int j = i;//第一次循环时将第二个数字的下标赋给j        int temp = arr[j]; //第一次循环时将第二个数字赋值给target(即保留待插入元素)        //第一次循环时如果第二个数字小于第一个数字，就将第一个数字后移(后面的循环中即将前面的数字都后移一位)        while(j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1]) {            arr[j] = arr[j-1];            //然后将第二个数字插入到第一个位置 (后面的循环中即将待插入数字插入到前面空出的地方)            arr[j - 1] = temp;            j --;//将j － 1，继续调整        }         }         }}</code></pre><p>总结:<br>1.设置外层循环从1开始,将i赋值给j，保存待插入的元素arr[j]然后判断是否满足wille循环条件<br>2.将保存的arr[j]与之前已经排好的数组进行比较，然后插入到一个适当的位置上，满足条件执行交换后，j–</p><h3 id="高效排序"><a href="#高效排序" class="headerlink" title="高效排序"></a>高效排序</h3><h4 id="快速排序-不稳定-o-nlogn"><a href="#快速排序-不稳定-o-nlogn" class="headerlink" title="快速排序(不稳定,o(nlogn))"></a>快速排序(不稳定,o(nlogn))</h4><p>快速排序一听名字就觉得很高端，在实际应用当中快速排序确实也是表现最好的排序算法。<strong>快速排序虽然高端，但其实其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是同时比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。</strong><br>基本思想是</p><ul><li>1先从数列中取出一个数作为基准数</li><li>2<strong>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边</strong></li><li>3再对左右区间重复第二步，直到各区间只有一个数</li></ul><p><strong>概括来说为 挖坑填数+分治法</strong><br><img src="https://i.imgur.com/3afIUp1.png" alt=""><br>下面是另一种思路:<br>举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。<br><strong>第一次排序:用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。</strong><br>首先设置i,j两个指针分别指向两端(即i指向5，j指向4)，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。<br>然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。</p><p><strong>一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。</strong></p><p>上面留下来了一个问题为什么一定要j指针先动呢？<strong>首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。</strong></p><p><strong>快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。</strong><br>Demo：</p><pre><code>public class QuickSort {//一次划分public static int partition(int[] arr, int left, int right) {    int pivotKey = arr[left];    int pivotPointer = left;    while(left &lt; right) {        while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey)            right --;        while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey)            left ++;        swap(arr, left, right); //把大的交换到右边，把小的交换到左边。    }    swap(arr, pivotPointer, left); //最后把pivot交换到中间    return left;}public static void quickSort(int[] arr, int left, int right) {    if(left &gt;= right)        return ;    int pivotPos = partition(arr, left, right);    //通过上面的partition方法，一次排序后就出现:中间右边的数都比中间的基准数要大、中间左边的数都比中间的基准数要小得规律。这样接下来分两次排序:将中间左边的数进行快速排序、将中间右边的数进行快速排序即可。    quickSort(arr, left, pivotPos-1);    quickSort(arr, pivotPos+1, right);}public static void sort(int[] arr) {    if(arr == null || arr.length == 0)        return ;    quickSort(arr, 0, arr.length-1);}//交换的是left、right下标对应的数组元素，而不是交换的left和right的值public static void swap(int[] arr, int left, int right) {    int temp = arr[left];    arr[left] = arr[right];    arr[right] = temp;}   }</code></pre><p>其实上面的代码还可以再优化，上面代码中基准数已经在pivotKey中保存了，所以不需要每次交换都设置一个temp变量，在交换左右指针的时候只需要先后覆盖就可以了。这样既能减少空间的使用还能降低赋值运算的次数。优化代码如下:</p><pre><code>public class QuickSort {/** * 划分 * @param arr * @param left * @param right * @return */public static int partition(int[] arr, int left, int right) {    int pivotKey = arr[left];    while(left &lt; right) {        while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey)            right --;        arr[left] = arr[right]; //把小的移动到左边        while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey)            left ++;        arr[right] = arr[left]; //把大的移动到右边    }    arr[left] = pivotKey; //最后把pivot赋值到中间    return left;}/** * 递归划分子序列 * @param arr * @param left * @param right */public static void quickSort(int[] arr, int left, int right) {    if(left &gt;= right)        return ;    int pivotPos = partition(arr, left, right);    quickSort(arr, left, pivotPos-1);    quickSort(arr, pivotPos+1, right);}public static void sort(int[] arr) {    if(arr == null || arr.length == 0)        return ;    quickSort(arr, 0, arr.length-1);}   }</code></pre><p><strong>总结快速排序的思想：冒泡+二分+递归分治，慢慢体会吧。</strong><br>个人总结：快速排序和前面三种简单排序不同，前面三种排序基本上只需要一个方法或者说一个”大步骤”即可以完成，<strong>而快速排序需要两大步骤才能完成，这很好地体现了面向过程编程的思想。</strong></p><ul><li><strong>注意代码中的下标，通过下标完成大小数交换，注意这种思想是对图片的一种优化表达。当结束white循环（里面有两个子循环的）后，即可得到基准数左边的数小于基准数而基准数右边的数大于基准数（ swap(arr, left, right);）。而 swap(arr, pivotPointer, left);则是交换基准数的位置（即定向一个新的指针指向！！）</strong></li><li><strong>上面根据基准数划分之后，左区间的right指针即为partition()方法得到的新指针left-1，而右区间的left指针也是为partition()方法得到的新指针left+1</strong>。<strong>这就能理解左递归quickSort(arr, left, pivotPos-1);和右递归quickSort(arr, pivotPos+1, right);</strong></li></ul><p>通过理解上面的内容之后，本博文中的例子代码操作对应的结果如下<br>1.while(while1 while2 )</p><ul><li>5(left) 3 8 6 4(right)</li><li>5 3 8(left) 6 4(right)</li><li>5 3 4(left) 6 8(right)=swap(arr, left, right)</li><li>3 4 5 6 8= swap(arr, pivotPointer, left) </li></ul><p>总结:<br>1.判断左右下标是否满足快速排序条件，若满足，执行partition方法;，并将得到的下标+1，-1进行左右递归<br>2.partition方法先设置基准值为arr[left]，并保存基准值下标left，即赋值给pivotPointer。左右下标满足条件时<br>3.将执行while下的两个子while循环，当不满足条件时，交换左右下标对应的数组值。所有大于等于和小于等于基准值的数组值都被放到了合适位置，最后将基准值和左指针left的值进行交换。此时新的基准值的左边全是&lt;=，右边全是&gt;=基准值的。</p><h4 id="堆排序实现思路-不稳定-O-nlogn"><a href="#堆排序实现思路-不稳定-O-nlogn" class="headerlink" title="堆排序实现思路(不稳定,O(nlogn))"></a>堆排序实现思路(不稳定,O(nlogn))</h4><p><strong>堆排序是借助堆（一种数据结构，即完全二叉树，每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。用公式表示就是大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]  ）来实现的选择排序，思想同简单的选择排序</strong>，以下以大顶堆为例。注意：<strong>如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。</strong></p><p>基本思想:<br><strong>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</strong></p><p>具体步骤:</p><ul><li><strong>将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></li><li><strong>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></li><li><strong>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></li></ul><p><strong>堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。</strong></p><p>首先，实现堆排序需要解决两个问题：</p><ul><li>如何由一个无序序列键成一个堆？</li><li>如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</li></ul><p>第一个问题，<strong>可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。</strong></p><p>第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。<br>从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子：<br>49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下图,这是一个小顶堆:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-11%20%E4%B8%8B%E5%8D%889.21.58.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-11%20%E4%B8%8B%E5%8D%889.21.33.png" alt=""><br>大顶堆Demo：</p><pre><code>public class HeapSort {/** * 堆筛选，除了start之外，start~end均满足大顶堆的定义。 * 调整之后start~end称为一个大顶堆。 * @param arr 待调整数组 * @param start 起始指针 * @param end 结束指针 */public static void heapAdjust(int[] arr, int start, int end) {    int temp = arr[start];    for(int i=2*start+1; i&lt;=end; i*=2) {        //左右孩子的节点分别为2*i,2*i+1        //选择出左右孩子较大的下标        if(i &lt; end &amp;&amp; arr[i] &lt; arr[i+1]) {            swap(arr, i, i+1);        }        if(temp &gt;= arr[i]) {            break; //已经为大顶堆，=保持稳定性。        }        arr[start] = arr[i]; //将子节点上移        start = i; //下一轮筛选    }    arr[start] = temp; //插入正确的位置}public static void heapSort(int[] arr) {    if(arr == null || arr.length == 0)        return ;    //建立大顶堆,从第一个非叶子结点从下至上，从右至左调整结构    for(int i=arr.length/2; i&gt;=0; i--) {        heapAdjust(arr, i, arr.length-1);    }    for(int i=arr.length-1; i&gt;=0; i--) {        swap(arr, 0, i);将堆顶元素与末尾元素进行交换        heapAdjust(arr, 0, i-1);//重新对堆进行调整    }}public static void swap(int[] arr, int i, int j) {    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;}}</code></pre><p><strong>本算法重点在于理解建立初始大顶堆堆的过程:从下往上，从右到左（对于内部的顶堆来说是从左往右）以及交换堆顶元素，然后输出第一个数，并调整建立新堆的过程</strong><br>具体过程:</p><ul><li><strong>构造初始堆是对所有的非叶节点都进行调整。:从最后一个非叶子结点开始每次调整都是从父节点、左孩子节点、右孩子节点三者中选择最大者跟父节点进行交换(交换之后可能造成被交换的孩子节点不满足堆的性质，因此每次交换之后要重新对被交换的孩子节点进行调整)。这就是heapAdjust中for循环存在的意义</strong></li><li>调整堆:堆顶元素交换到序列尾部<strong> （swap(arr, 0, i)</strong>）那么此时位于堆顶的元素不满堆的性质，则需调整继续调整。</li></ul><h4 id="希尔排序实现思路"><a href="#希尔排序实现思路" class="headerlink" title="希尔排序实现思路"></a>希尔排序实现思路</h4><p><strong>希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序</strong>。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。<br>希尔排序就利用了这个特点。基本思想是：<strong>先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-08%20%E4%B8%8B%E5%8D%887.55.30.png" alt=""><br><strong>希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。</strong>如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。</p><p>希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到O(n^1.3)。<br>Demo：</p><pre><code>public class ShellSort {//排序public static void shellSort(int[] arr) {    if(arr == null || arr.length == 0)        return ;    int d = arr.length / 2;    while(d &gt;= 1) {        shellInsert(arr, d); //调用下面的插入方法        d /= 2;    }}/** * 希尔排序的一趟插入 * @param arr 待排数组 * @param d 增量 */public static void shellInsert(int[] arr, int d) {    for(int i=d; i&lt;arr.length; i++) {        int j = i - d;        int temp = arr[i];    //记录要插入的数据          while (j&gt;=0 &amp;&amp; arr[j]&gt;temp) {  //从后向前，找到比其小的数的位置               arr[j+d] = arr[j];    //向后挪动              arr[j] = temp;            j -= d;          }        }}}</code></pre><p>总结:<br><strong>设置增量d（就是将数组分成d组，每组的元素个数未必相等），希尔增量序列建议为{n/2,(n/2)/2…1}当增量&gt;=1就执行shellInsert方法。将j设置为i-d,保存i对应的数组值到temp中，当满足条件时，执行while循环将新的值和temp对应的值交换。执行完shellInsert方法后，设置新的d /= 2;</strong><br><img src="https://i.imgur.com/Kb3JZix.png" alt=""></p><h4 id="归并排序实现思路-O-nlogn"><a href="#归并排序实现思路-O-nlogn" class="headerlink" title="归并排序实现思路(O(nlogn))"></a>归并排序实现思路(O(nlogn))</h4><p><strong>归并排序是另一种不同的排序方法，因为归并排序使用了递归分治的思想，所以理解起来比较容易</strong>。其基本思想是，先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列;然后把子序列看成两个有序的子子序列，然后合并这两个子子序列;然后…倒着来看，其实就是先两两合并，然后四四合并，最终形成一个有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。<br>Demo:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-08%20%E4%B8%8B%E5%8D%888.00.04.png" alt=""></p><pre><code>public class MergeSort {public static void mergeSort(int[] arr) {    mSort(arr, 0, arr.length-1);}/** * 递归分治 * @param arr 待排数组 * @param left 左指针 * @param right 右指针 */public static void mSort(int[] arr, int left, int right) {    if(left &gt;= right)        return ;    int mid = (left + right) / 2;    mSort(arr, left, mid); //递归排序左边    mSort(arr, mid+1, right); //递归排序右边    merge(arr, left, mid, right); //合并}/** * 合并两个有序数组 * @param arr 待合并数组 * @param left 左指针 * @param mid 中间指针 * @param right 右指针 */public static void merge(int[] arr, int left, int mid, int right) {    //[left, mid] [mid+1, right]    int[] temp = new int[right - left + 1]; //中间数组    int i = left;    int j = mid + 1;    int k = 0;    //执行完这个while循环，相当于将两个子序列合并后重新进行了一次排序并将排序结果记录在了临时数组temp[k]中。while走完后k的值等于数组的长度，i的值此时大于mid，j的值大于right    while(i &lt;= mid &amp;&amp; j &lt;= right) {        if(arr[i] &lt;= arr[j]) {            temp[k++] = arr[i++];        }        else {            temp[k++] = arr[j++];        }    }    while(i &lt;= mid) {        temp[k++] = arr[i++];    }    while(j &lt;= right) {        temp[k++] = arr[j++];    }    //将有序的临时数组temp[k]一个一个赋值到原数组arr[]中    for(int p=0; p&lt;temp.length; p++) {        arr[left + p] = temp[p];    }}}</code></pre><p><strong>归并排序是分治法的应用。将原数组分成左右两个子数组，并且一直左递归，直到不能再分成左右子数组然后调用merge方法进行排序，并且将得到的子数组赋值到原数组。然后右递归，最后合并得到的最终的左右子数组的出结果</strong></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个Java工程师，所以里面的算法都是用Java语言实现的，不过其实不管你用的是哪种语言，实现该算法的思路都是一样的，所以借鉴此篇文章的你即使用的不是Java，看完此片文章的实现思路及其实现代码后你也是可以用其他语言实现的～&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="算法" scheme="http://codinglembre.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记之单表查询与多表查询</title>
    <link href="http://codinglembre.top/2018/10/09/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
    <id>http://codinglembre.top/2018/10/09/MySQL学习笔记之单表查询与多表查询/</id>
    <published>2018-10-09T11:09:45.000Z</published>
    <updated>2018-10-09T12:40:35.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a>解决中文乱码问题</h3><p>1.查看MySQL数据库编码:<br>在命令行中输入SHOW VARIABLES LIKE ‘CHAR%’; 回车可看到如下内容:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%98%E5%90%97.png" alt=""><br>2.编码解释:</p><ul><li>character_set_client: mysql使用该编码来解读客户端发送过来的数据，例如该编码为utf，那么<strong>如果客户端发送过来的数据不是utf，就会出现乱码。</strong></li><li>character_set_results：mysql会把数据转换成该编码后，再发送给客户端，例如该编码为utf，那么<strong>如果客户端不使用utf来解读，那么就会出现乱码，其它编码只要支持中文即可</strong></li></ul><p>除了这两个编码格式外我们还需要考虑一个工具(用于编写sql语句的工具)的编码格式，即控制台(用命令行写sql语句)或者用于写sql语句的可视化工具，为什么要用”或”呢，因为二者就是一体，修改一个即一起修改了两个的编码格式。下面1.3节我在分析乱码原因后会告诉你<strong>如何保持client、results以及控制台与可视化工具这四者编码格式的一致，以解决中文乱码问题。</strong><br>3.控制台乱码问题<br>windows系统中:</p><ul><li><strong>插入或修改时出现乱码：因为控制台默认使用gbk</strong>，而character_set_client不是gbk的原因。</li><li>查询出的数据为乱码，因为character_set_results不是gbk而控制台默认使用gbk。</li><li>解决方法:通过在命令行中输入代码set character_set_client=gbk;和set character_set_results=gbk;来设置编码。</li></ul><p>通过将client和results的编码格式改成gbk后使得它们二者和控制台的编码格式一致，这样便可以实现中文乱码问题解决了编码的问题。</p><blockquote><p>注意：通过上述方式我们将client、results、控制台这三者编码方式设置一致，设置编码只对当前连接有效，当退出mysql后再次登陆mysql时又回到utf了。解决方法:找到my.ini配置文件，在配置文件中设置set default_character=gbk即可。</p></blockquote><h3 id="备份数据库与恢复数据库"><a href="#备份数据库与恢复数据库" class="headerlink" title="备份数据库与恢复数据库"></a>备份数据库与恢复数据库</h3><p>1.备份数据库<br>备份就是将数据库导出为sql脚本。在命令行中输入:mysqldump -u用户名 -p密码 数据库名&gt;导出文件路径</p><blockquote><p><strong>注意:1.末尾不要打分号。2.执行此语句前应该先退出mysql客户端。3.导出的内容不包括创建数据库的语句只包含数据库里面的内容。</strong></p></blockquote><p>2.恢复数据库<br>就是将导出的sql脚本插入到数据库中。有如下两种实现方式:</p><ul><li>第一种方式:1.登录mysql:mysql -u用户名 -p密码。2.创建数据库:create database 数据库名。3.输入命令:mysql -uroot -p密码 数据库名&lt;备份的数据路径并回车</li><li>第二种方式:1.删除数据库:drop database 数据库名。2.重新创建数据库:create database 数据库名。3.切换到数据库:use 数据库名。4.输入命令:source sql脚本路径并回车。</li></ul><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p><strong>约束是添加在列上用来约束列的。</strong><br>1.主键约束(primary key)<br><strong>特点:1.非空。2.唯一。3.可被引用。当表的某一列被指定为主键后，该列的值就不能为空，也不能有重复值出现。</strong></p><ul><li><p>创建表时指定主键的两种方式:</p><pre><code>1.create table emp(  empno int primary key,  ename varchar(50));2.create table emp(  empno int,  ename varchar(50),  primary key(empno) );</code></pre></li><li><p>修改表时指定主键的方式:</p><pre><code>alter table empadd primary key(empno);</code></pre></li><li><p>修改表时删除主键的方式:</p><pre><code>alter table empdrop primary key;</code></pre><p>2.主键自增长(auto_increment)</p><p>  create table student(<br>  id int primary key auto_increment,<br>  name varchar(50)<br>  );<br>注意:<strong>auto_increment必须添加在int类型后，指定主键自增长后，插入数据时便可以给该主键设置null值。限制:主键自增长在群集环境下不好使，所以大部分情况下我们使用UUID来作主键。</strong><br>3.非空约束(not null)<br><strong>因为某些列不能设置为null值，所以可以对列添加非空约束。</strong></p><p>  create table student(<br>  id int primary key auto_increment,<br>  name varchar(50) not null<br>  );<br>4.唯一约束(unique)<br><strong>数据库中某些列不能设置重复的值，所以可以对列添加唯一约束。</strong></p><p>  create table student(<br>  id int primary key auto_increment,<br>  name varchar(50) not null unique<br>  );<br>5.<strong>概念模型</strong></p></li><li><p><strong>在java中表现为对象模型</strong>：在java中是domain。例如：User、Student。</p></li><li><strong>在数据库中表现为关系模型：在数据库中表现为表。</strong></li></ul><p>当我们要完成一个软件系统时，需要<strong>把系统中的实体抽取出来，形成概念模型</strong>。例如部门、员工都是系统中的实体。概念模型中的实体最终会成为java中的类、数据库中的表。实体之间还存在着关系，关系有三种:</p><ul><li>1对多:例如员工和部门的关系</li><li>1对1:例如老公和老婆的关系</li><li>多对1:例如老师与学生的关系</li></ul><blockquote><p><strong>对象模型：可以双向关联，而且引用的是对象，而不是一个主键。关系模型：只能多方引用一方，而且引用的是主键，而不是一整行记录。</strong></p></blockquote><p>6.外键约束</p><ul><li>1.外键必须是另一表(或自己表)的主键的值(即外键要引用主键的值)。<strong>即外键可以是副表的主键，但是必须是主表的主键</strong></li><li>2.外键可以为空。<strong>即在主表中添加数据后，此时在副表中可以添加sno、cno为空的数据。</strong></li><li>3.外键可重复。(<strong>前提是这个外键不是副表的主键)</strong></li><li><p>4.一张表可以有多个外键。</p><p>  create table dept(<br>  deptno int primary key auto_increment,<br>  name varchar(50)<br>  );</p><p>  create table emp(<br>  empno int primary key auto_increment,<br>  name varchar(50),<br>  dno int,<br>  constraint fk_emp_dept  foreign key(dno)  references dept (deptno)<br>  );</p></li></ul><p>最后一行就是给emp表添加外键约束，添加外键约束后，在emp表中对dno列进行赋值时就应该考虑外键约束的三个条件了。(上图创建的两张表演示的也是数据库中1对多的关系。)<br>7.数据库中1对1的关系</p><pre><code>create table husband (hid int primary key auto_increment,hname varchar(50));insert into husband values(null,’刘备’);insert into husband values(null,’张飞’);insert into husband values(null,’关羽’);create table wife(wid int primary key auto_increment,wname varchar(50),constraint fk_wife_husband foreign key (wid)  references husband(hid));</code></pre><p><strong>特点:外键引用自身表(副表)的主键。</strong></p><p>8.数据库中多对多的关系<br><strong>在表中建立多对多关系需要使用中间表(关联表)，即需要三张表，在中间表中使用两个外键，分别引用其它两个表的主键。</strong></p><pre><code>create table student(sid int primary key auto_increment,sname varchar(50));create table teacher (tid int primary key auto_increment,name varchar(50));create table stu_tea(sid int,tid int,constraint fk_student foreign key(sid) references student(sid),constraint fk_teacher foreign key(tid) references teacher(tid));insert into student values(null,’刘德华’);insert into student values(null,’梁朝伟);insert into student values(null,’黄日华’);insert into student values(null,’苗侨伟’);insert into student values(null,’汤镇业’);insert into teacher values(null,’崔老师’);insert into teacher values(null,’刘老师’);insert into teacher values(null,’石老师’);insert into stu_tea values(1,1);insert into stu_tea values(2,1);insert into stu_tea values(3,1);insert into stu_tea values(4,1);insert into stu_tea values(5,1);insert into stu_tea values(1,2);insert into stu_tea values(2,2);insert into stu_tea values(3,2);insert into stu_tea values(3,3);insert into stu_tea values(4,3);insert into stu_tea values(5,3);select * from stu_tea;</code></pre><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>1.分类</p><ul><li>合并结果集(了解)</li><li>连接查询</li><li>子查询</li></ul><p>2.合并结果集<br><strong>要求两个结果集(注意这里强调的是结果集，而不是两张表)的列数、列类型完全相同。</strong>关键字union:去除重复行;关键字union all:不去除重复行。</p><pre><code>create table ab(a int, b,varchar(50));insert into ab values(1,’1’);insert into ab values(2,’2’);insert into ab values(3,’3’);create table cd(c int,d varchar(50));insert into cd values (3,’3’);insert into cd values (5,’5’);insert into cd values (5,’5’);</code></pre><p>合并操作为:</p><pre><code>select * from abunion (all)select * from cd;</code></pre><p>3.连接查询</p><ul><li>内连接</li><li>外连接</li></ul><blockquote><p><strong>外连接又包括左外连接、右外连接、全外连接(mysql不支持这个)</strong></p></blockquote><p>3.1内连接</p><ul><li>方言语法:select <em> from 表1 别名1，表2 别名2 where 别名1.xx＝别名2.xx;例如:select </em> from emp,dept where emp.deptno=dept.deptno;去除无用行后的笛卡尔积，where后的条件是主外键。</li><li>标准语法:select <em> from 表1 别名1 inner join 表2 别名2，on 别名1.xx＝别名2.xx;例如::select </em> from emp inner join dept on emp.deptno=dept.deptno; <strong>就是把方言版的逗号改为inner join ，把where改为on了。</strong></li><li>自然连接语法:select * from 表1 别名1 natural join 表2 别名2;<strong>自然连接特有的特点就是它能够自己找到两个表中相同的列 即自己填全where条件。</strong></li></ul><p>总结:<strong>内连接的特点:内连接查询出的所有记录都是满足条件的记录，不满足条件的记录不显示出来。</strong></p><p>3.2外连接<br><strong>特点:外连接有一主一次。</strong></p><ul><li><strong>左外连接左表为主</strong>，那么左表中所有的记录无论满足不满足条件，都打印出来。不满足条件的值用null填补。语法为:select * from emp left outer join dept on emp.deptno=dept.deptno;</li><li><strong>右外连接右表为主</strong>，那么右表中所有的记录无论满足不满足条件，都打印出来。不满足条件的值用null填补。语法为::select * from amp right outer join dept on emp.deptno=dept.deptno;</li><li><strong>全外连接：左右表都为主，左表和右表中的记录都要打印出来，不满足条件的值用null填补。</strong>使用union将左外连接和右外连接的结果集合并起来就是全外连接。</li></ul><p>4.子查询<br><strong>子查询通俗来讲，就是查询中有查询。</strong><br>Demo:</p><pre><code>/*查询本公司工资最高的员工的详细信息*/select * from ampwhere sal=max(sal);</code></pre><p><strong>此种写法错误，因为where条件中不能有聚合函数。所以想到要用子查询。</strong><br>思路:首先查出最高工资:select max(sal) from amp;然后查询该工资的员工:select <em> from amp where sal=刚刚的查询结果。所以合并起来为：select </em> from amp where sal=(select max(sal) from amp);</p><p>4.1子查询能出现的位置</p><ul><li>where后作为条件(上述例子)</li><li>from后作为二次查询(下面例子)</li></ul><blockquote><p>select e.empno,e.ename from (select * from amp where deptno=30) as e where 条件;</p></blockquote><p>4.2子查询的结果集</p><ul><li>单行单列:select * from 表1 where 列1 [=、&gt;、&lt;、&gt;=、&lt;=、!=] （select 列 from 表2 where 条件);</li><li>多行单列::select * from 表1 where 列1 [=、&gt;、&lt;、&gt;=、&lt;=、!=] ［any、all、in］（select 列 from 表2 where 条件;</li><li>单行多列:select * from 表1 where （列1，列2） in (select 列1，列2 from 表2 where 条件);</li><li>多行多列:该结果集用在from后作为二次查询。select * from 表1,(select …) 别名 where 条件;</li></ul><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;解决中文乱码问题&quot;&gt;&lt;a href=&quot;#解决中文乱码问题&quot; class=&quot;headerlink&quot; title=&quot;解决中文乱码问题&quot;&gt;&lt;/a&gt;解决中文乱码问题&lt;/h3&gt;&lt;p&gt;1.查看MySQL数据库编码:&lt;br&gt;在命令行中输入SHOW VARIABLES LIKE 
      
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="数据库" scheme="http://codinglembre.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java学习之Java中的集合框架与泛型</title>
    <link href="http://codinglembre.top/2018/10/08/Java%E5%AD%A6%E4%B9%A0%E4%B9%8BJava%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://codinglembre.top/2018/10/08/Java学习之Java中的集合框架/</id>
    <published>2018-10-08T09:22:39.000Z</published>
    <updated>2018-10-08T13:40:37.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集合类的概念和作用"><a href="#集合类的概念和作用" class="headerlink" title="集合类的概念和作用"></a>集合类的概念和作用</h3><p>Java中的集合类:<strong>是一种工具类，就像容器，储存任意数量具有共同属性的对象。</strong>它在Java中有以下作用:</p><ul><li>在类的内部，对数据进行组织</li><li>简单而快速搜索大数量的条目</li><li>有的集合接口提供了一系列排列有序的元素，并且可以在序列中间快速的插入或者删除有关元素。</li><li>有的集合接口提供了映射关系，可以通过关键字key去快速查找到对应的唯一对象，而这个关键字可以是任意类型。</li></ul><blockquote><p>注意:<strong>对象存入集合中都变成Object类型，取出时需要类型转换</strong></p></blockquote><h3 id="与数组的对比"><a href="#与数组的对比" class="headerlink" title="与数组的对比"></a>与数组的对比</h3><ul><li>数组的长度固定，集合长度可变</li><li><strong>数组只能通过下标访问元素，类型固定，而有的集合可以通过任意类型查找所映射的具体对象。</strong></li></ul><h3 id="Java集合框架体系结构"><a href="#Java集合框架体系结构" class="headerlink" title="Java集合框架体系结构"></a>Java集合框架体系结构</h3><p><img src="https://i.imgur.com/c0M886T.png" alt=""><br><img src="https://i.imgur.com/0ETbXWZ.png" alt=""></p><ul><li>Collection与Map是两个根接口。</li><li><p>Collection接口：<strong>内部存储的是一个个独立的对象。</strong>包含：</p><ul><li>List接口：序列，<strong>存储元素排列有序且可重复</strong>。实现类:ArrayList，数组序列。实现类：LinkedList，链表<strong>，保存的是一个个独立的对象</strong>。 </li><li>Queue接口：队列，存储元素排列有序且可重复。实现类：LinkedList，链表。</li><li>Set接口：集，<strong>存储元素无序且不可重复</strong>。实现类：HashSet，哈希集，<strong>保留的是对象的引用</strong>。</li></ul></li><li><p>Map接口:<strong>提供了一种映射关系，里面放的是Entry类型的对象实例。其中的元素是以键值对（key-value）的形式存储的，能够实现根据key快速查找value</strong></p><ul><li>HashMap实现类</li></ul></li></ul><h3 id="List常用API的使用"><a href="#List常用API的使用" class="headerlink" title="List常用API的使用"></a>List常用API的使用</h3><p>1.添加单个元素:</p><ul><li>第一种 add 方法：是向 List 中插入一条元素 例如：cosTo.add( s1 ); —-插入的元素。</li><li>第二种 add 方法：是向 List 指定位置插入一条元素 例如：cosTo.add( 2 , s2 ); —-位置 ，插入的元素。</li></ul><blockquote><p> <strong>第二种方法插入的位置不可越界，虽然可以指定位置，但不可超出现有的长度。List 长度起始位置是从0开始。</strong></p></blockquote><p>2.添加list元素</p><ul><li>addAll(List list) 就是将一个List里面的元素一股脑的全都加进去。<strong>一般定义一个数组，调用方法Arrays.asList(Object[] obs);可以将一个数组转换为一个List，然后可以将这个元素传进addAll()里面，当然还有addAll（index,List list）方法</strong></li></ul><p>3.遍历list中的元素</p><ul><li><p>普通for循环</p><pre><code>public void testGet(){     int size=coursesToSelect.size();     for(int i=0;i&lt;size;i++){         Course cr=(Course) coursesToSelect.get(i);        System.out.println(&quot;取出的课程：&quot;+cr.getId()+&quot;:&quot;+cr.getName()); } }</code></pre></li><li><p>迭代器，<strong>Iterator是一个接口,依赖于集合存在的</strong></p><pre><code>Iterator it=courseToSelect.iterator(); while(it.hasNext()){     Course cr=(Course) it.next(); System.out.println(&quot;课程:&quot; + cr.id + &quot;:&quot; + cr.name); }</code></pre></li><li><p>for each(增强for循环)，<strong>数组和继承了Iterable接口的类所生成的对象都可以用for/each循环</strong></p><pre><code>for(Object obj:coursesToSelect){//遍历集合中的每一个元素，作为每一个Object变量 Course cr=(Course) obj; System.out.println(&quot;课程:&quot; + cr.id + &quot;:&quot; + cr.name); }</code></pre><p>4.修改List的元素 </p><pre><code>public void testModify(){ coursesToSelect.set(4,new Course(&quot;7&quot;,&quot;毛概&quot;)); }</code></pre><p>5.删除list中的元素<br>List中有remove(index),remove(对象值)和removeAll(Arrays.asList(对象数组名))方法来删除容器中元素的值(用法和add类似)。</p></li></ul><blockquote><p><strong>第二种方法删除的位置不可越界，虽然可以指定位置，但不可超出现有的长度。List 长度起始位置是从0开始。</strong></p></blockquote><h3 id="Set常用API的使用"><a href="#Set常用API的使用" class="headerlink" title="Set常用API的使用"></a>Set常用API的使用</h3><p>和List类似。</p><blockquote><p>注意:<strong>Set集合是无序的，所以每次遍历的结果都是不一样的，并且它没有get()方法，只能用foreach和iterator</strong><br><strong>Set中，添加某个对象昂，无论添加多少次，最终只会保留一个该对象的引用，并且，保留的是第一次添加的那一个。</strong></p></blockquote><h3 id="Map常用API的使用"><a href="#Map常用API的使用" class="headerlink" title="Map常用API的使用"></a>Map常用API的使用</h3><p>Map增删改查：</p><ul><li>增：map的put(key,value)方法添加。 </li><li>查：1.<strong>利用keyset()方法获得Map中key的集合</strong>，再遍历这个Set的集合，利用Map的get(key)方法得到key对应的value值。<br><img src="https://i.imgur.com/wNq83VK.png" alt=""><br><strong>利用EntrySet方法获取May中Entry对象集：然后用foreach遍历集，再用Entry集的getkey()和getvalue()方法得到每一个key值和value值。</strong><br><img src="https://i.imgur.com/192xJf3.png" alt=""></li><li>删：remove(object key) </li><li>改：put(原有的key,新的value) 通过entrySet可以返回Map中的所有键值对 Set&lt;Entry&lt;String,Student&gt;&gt;entrySet = students.entrySet(); </li></ul><blockquote><p>注意:<strong>Map支持泛型，Map&lt;K,V&gt;</strong><br><strong>跟Collection中添加的元素的方式不同，Map使用put()添加一个映射。</strong><br><strong>Map接口提供了分别返回key值集合、value值集合以及Entry（键值对）集合的方法</strong><br><strong>Key是不可以重复的，Value是可以重复的。Key-value都可以为null，不过只能有一个key是null。当这个key为null说明它不指向任何对象</strong></p></blockquote><h3 id="集合与泛型"><a href="#集合与泛型" class="headerlink" title="集合与泛型"></a>集合与泛型</h3><p><strong>泛型&lt;&gt;;规定List定义的容器只能存储某种类型的元素。不用泛型的话是什么类型的元素都可以插入，因为插入集合是忽略其类型，把它看成为Object类型，取出时需要强行转换对应的类型。</strong></p><blockquote><p><strong>如果使用了泛型但是还是添加奇怪的对象比如一个字符串进去，则在编译时便会报错。</strong><br><strong>list不能直接添加基本类型（int,float等）的对象，如果要添加，需要使用其包装类</strong><br>list可以添加子类型的对象</p></blockquote><h3 id="集合框架高级"><a href="#集合框架高级" class="headerlink" title="集合框架高级"></a>集合框架高级</h3><p>1.关于List的contains()方法的具体实现<br><strong>主动遍历List中的每一个元素，并使用Objet类的equals方法，和传进来的引用依次做比较，一旦发现传进来的对象和某个元素指向的是同一块内存那么就返回true。</strong>但是这里有一个问题，就是比较的是引用，那么如果想要比较对象的”值”呢？，那么需要重写eauals()方法。</p><pre><code>public void equals (Object obj) { if(this == obj) // 指向同一个内存快 必然是相同的 return true; //为什么contains(course2) 返回的是false 原因就在在这里 只是比较了一下 引用的值是否相同 没有进一步的比较 内存块中的值 下就是对这里记性了改写 if (obj == null) // 如果obj为空 就直接没有戏了 return false; if(! (obj instanceof Course)) //如果两者的不属于同一类型则 也直接没戏了 return false; //经过以上的这么多的比较 终于可以判断二者的值是不是相同了 //首相要把objet型的obj转成 Course Course course = (Course) obj； if( this.name == null ) ｛ if(course.name == null ) return true; else return false; } else { if(this.name.equals(course.name)) return true; else return false; ) //如果还有别的属性接着写 }</code></pre><p>2.关于<strong>Set的contain</strong>方法的具体实现<br><strong>Set.contains(E e)的时候，先调用从Object继承而来的hashCode方法，然后在调用equals()方法，连个方法都返回真的时候，才认定Set包含某个元素。</strong></p><blockquote><p>总结:<strong>list 与 set 中contain()方法调用机制： list 中的contain()方法是拿到list中的每个对象来调用Object类中的equals()方法 Set 中的contain()方法是拿到list中的每个元素来先调用hashcode()方法来返回哈希码值，当哈希码的值相等时，再调用equals()方法，当比较的元素此时也相同时，才会返回true。因此调用Set中的contain()方法时，需要对hashcode()方法及equals()方法进行重写。</strong></p></blockquote><p>3.关于List中的indexOf()方法与lastIndexOf()方法的实现机制<br>indexOf()方法与lastIndexOf()方法实现原理： 1、遍历调用每个元素的equals()方法，如果返回true则将次元素的索引返回； 2、如果有多个相同元素，则只返回第一个元素的索引； 3、lastIndexOf()方法则从最后一个元素开始遍历；<br><img src="https://i.imgur.com/eTqxC0X.png" alt=""><br>4.<strong>Map中通过containsKey()方法和containsValue()方法来判断键和值是否存在 </strong>Map 中对对象进行了 Key 标记，通过 get（Key）可以取得对应的对象 Map 的containsValue（）方法的参数是 Object 对象，因为Map 的 Value 值是对象元素 Map 的containsKey（）方法取得 Map 映射的 Key 值 List中的contains()方法借Map中的containsValue()方法调用equals()方法来进行比较。所以要重写Hashcode和equals方法</p><p>5.工具类Arrays类和Collection类<br><strong>工具类Arrays类用于操作数组，工具类Collection类用于操作集合</strong></p><ul><li>对Integer类型的集合排序<br><img src="https://i.imgur.com/hhzFj8Z.png" alt=""></li><li>对String类型的集合排序<br><img src="https://i.imgur.com/uBFWmrf.png" alt=""></li></ul><blockquote><p><strong>collection.sort（）方法对元素进行排序，列表中的元素都必需实现 Comparable 接口，否则不能使用 sort（）方法排序 ，实现该接口表示：这个类的实例可以比较大小，可以进行自然排序</strong><br><strong>注意，这个是先拍数字，再大写字母，再小写字母</strong></p></blockquote><p>拓展: <strong>Java集合框架的成员:compareable(默认带有泛型的) 是默认比较规则， 实现comparator接口，且必须实现compareTo()方法 comparaTo()方法返回正数表示大，负数表示小，0表示相等。comparator是临时比较规则</strong>,比如，学生类实现了默认比较接口compareable，默认年龄比较，突然想按照身高拍，那么要实现comparator接口，且必须实现compare()方法 compara()方法返回正数表示大，负数表示小，0表示相等</p><blockquote><p>总结:<br>让没有默认比较规则的类进行比较的方法 </p></blockquote><ul><li>一、让该类实现Comparable接口： 1、在该类中加上implements Comparable&lt;类名&gt;。 2、实现.compareTo(类名 对象名)方法，若this较大则返回正值，若相等则返回0，若this较小则返回负值。（各种类都包含.compareTo()方法） 3、调用Collections.sort（对象名）进行排序。</li><li>二、让该类实Comparator接口： 1、新建一个类加上implements Comparator&lt;类名&gt; 2、实现.compare(类名 对象名1，类名，对象名2)方法，若this较大则返回正值，若相等则返回0，若this较小则返回负值。 3、调用Collections.sort（对象名，实现Comparator&lt;类名&gt;接口的对象名）方法。（因此要重建一个类来实现Comparator接口！！）</li></ul><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;集合类的概念和作用&quot;&gt;&lt;a href=&quot;#集合类的概念和作用&quot; class=&quot;headerlink&quot; title=&quot;集合类的概念和作用&quot;&gt;&lt;/a&gt;集合类的概念和作用&lt;/h3&gt;&lt;p&gt;Java中的集合类:&lt;strong&gt;是一种工具类，就像容器，储存任意数量具有共同属性
      
    
    </summary>
    
      <category term="Java" scheme="http://codinglembre.top/categories/Java/"/>
    
    
      <category term="JavaSE" scheme="http://codinglembre.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习之JSP</title>
    <link href="http://codinglembre.top/2018/10/04/JavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8BJSP/"/>
    <id>http://codinglembre.top/2018/10/04/JavaWeb学习之JSP/</id>
    <published>2018-10-03T16:44:50.000Z</published>
    <updated>2018-11-06T04:24:31.615Z</updated>
    
    <content type="html"><![CDATA[<p>JSP，即Java Server Pages，和Servlet一样，都是<strong>SUN公司定义的一种用于开发动态WEB资源的技术的标准，在服务器端执行的动态网页。</strong>JSP虽然像是在写HTML，但是JSP允许在页面中嵌套Java代码，或者利用某个标签表示Java代码（EL与jstl）。这就使得我们在<strong>写JSP时能够获取请求对象Request和响应对象Response等这样的web开发常用对象，实现与浏览器的交互。</strong></p><h3 id="JSP页面元素简介及page指令"><a href="#JSP页面元素简介及page指令" class="headerlink" title="JSP页面元素简介及page指令"></a>JSP页面元素简介及page指令</h3><p>page指令:通常位于jsp页面的顶端，同一个页面可以有多个page指令。<br><img src="https://i.imgur.com/TSgAZI7.png" alt=""></p><h3 id="JSP页面的生命周期"><a href="#JSP页面的生命周期" class="headerlink" title="JSP页面的生命周期"></a>JSP页面的生命周期</h3><p><img src="https://i.imgur.com/qwYKNVD.png" alt=""><br><img src="https://i.imgur.com/mhggkB5.png" alt=""></p><p><strong>每个客户端对应一个线程，这种多线程的处理方式，大大地降低了系统的资源需求，提高了系统的并发性，减少了响应时间。但是使用多线程编程就要注意线程带来的同步问题。(临界资源的共享和保护等等)</strong></p><h3 id="JSP内置域对象"><a href="#JSP内置域对象" class="headerlink" title="JSP内置域对象"></a>JSP内置域对象</h3><p>1.out对象:JspWriter的实例，是向客户端输出内容的常用的对象。<br>先了解一下什么是缓冲区:内存一块用于保存临时数据的区域<br><img src="https://i.imgur.com/zVk3D3O.png" alt=""><br>2.request和response对象<br>先了解一下Get和Post的区别:</p><ul><li>get：以明文的方式通过URL提交数据，数据在URL中可以看到。提交的数据最多不超过2KB。<strong>安全性低但效率比post方式高、适合提交数据量不大，安全性不高的数据。比如：搜索、查询等功能。</strong></li><li>post：<strong>将用户提交的信息封装在HTML、HEADER内。适合提交数据量大，安全性高的用户信息。比如：注册、修改、上传等功能。</strong><br><img src="https://i.imgur.com/c7sl04S.png" alt=""><br><img src="https://i.imgur.com/bPqdyGv.png" alt=""><br><strong>注意URL传递中文参数乱码的问题无法通过req.setCharacterEncoding解决，需要到Tomcat配置文件中设置修改tomcat中的server.xml 在端口号后，增加URIEncoding=”utf-8”;</strong><br><strong>response对象虽然重要，但是实际上JSP很少用他。*</strong><br><img src="https://i.imgur.com/pAgkss8.png" alt=""><br><strong>特别注意:PrintWriter向客户端输出字符串对象， 而且先于jspWriter，使用out.flush()来避免 PrintWriter response.getWriter()*</strong><br><img src="https://i.imgur.com/NVTxAW7.png" alt=""><br><strong>特别注意:对象是否保存！！</strong></li></ul><p>3.session:是<strong>客户端与服务器端建立的一个会话并保存在服务器中，和用户意义对应，session对象保存在服务器端的同时服务器还会给客户端发送一个带有JSESSIONID的Cookie。它实际是一个特定的时间概念</strong><br><img src="https://i.imgur.com/e0qWXdF.png" alt=""></p><p><strong>注意在之前讲过的session中的生命周期中，原有会话还在服务器端，只是再也没有客户端会携带它然后交于服务端进行校验</strong><br><img src="https://i.i8mgur.com/Gw0mfkA.png" alt=""></p><p>4.application（<strong>相当于Java中的全局变量，是ServletContext类的实例，服务器的关闭启动决定他的周期</strong>）<br><img src="https://i.imgur.com/5eNbRcK.png" alt=""><br><img src="https://i.imgur.com/Yf54HFW.png" alt=""><br>5.page对象（<strong>指向当前JSP页面本身，相当于this,，是Object类的实例）<br><img src="https://i.imgur.com/lTc2tZX.png" alt=""><br>6.pageContext和Config对象</strong>pageContext 用于获取其他对象，功能的集大成者<strong><br><img src="https://i.imgur.com/AILNWGT.png" alt=""><br>pageContext常用API如下:<br><img src="https://i.imgur.com/OpzsHxG.png" alt=""><br>Config对象及常用API如下:<br><img src="https://i.imgur.com/ISekqRE.png" alt=""><br>7.exception对象<br><img src="https://i.imgur.com/yeUeARD.png" alt=""></strong>但是需要在page指令中写属性errorpage=“出错跳转到的页面” 2.在跳转到的错误处理页面page指令中输入属性isErrorPage=“true”**</p><h3 id="JavaBeans"><a href="#JavaBeans" class="headerlink" title="JavaBeans"></a>JavaBeans</h3><p><strong>解决了代码重复编写，减少代码冗余，功能区分明确，提高了代码的维护性</strong><br>设计原则:</p><ul><li>公有类</li><li>属性私有</li><li>无参的构造方法</li><li>setter/getter方法</li></ul><h3 id="JSP动作元素"><a href="#JSP动作元素" class="headerlink" title="JSP动作元素"></a>JSP动作元素</h3><p>其实就是一个标签，可以有属性和可选内容:<br><img src="https://i.imgur.com/INmKtx0.png" alt=""></p><ul><li><p>userBean创建JavaBeans语法</p><pre><code>&lt;body&gt;&lt;jsp:useBean id=&quot;myUsers&quot; class=&quot;com.po.Users&quot; scope=&quot;page&quot;/&gt;用户名:&lt;%= myUsers.getUsername()%&gt;&lt;br&gt;密码：&lt;%= myUsers.getPassword()%&gt;&lt;br&gt;&lt;/body&gt;</code></pre></li><li><p>setProperty用法<br><img src="https://i.imgur.com/89YkdNo.png" alt=""></p><ul><li><p>1.根据表单自动匹配所有属性</p><pre><code>&lt;jsp:setProperty name=&quot;myUsers&quot; property=&quot;*&quot;/&gt;</code></pre></li><li><p>2.根据表单自动匹配部分属性</p><pre><code>&lt;jsp:setProperty name=&quot;myUsers&quot; property=&quot;username&quot;/&gt;</code></pre></li><li><p>3.跟表单无关，手工赋值给属性</p><pre><code>&lt;jsp:setProperty name=&quot;myUsers&quot; property=&quot;username&quot; value=&quot;admin&quot;/&gt;</code></pre></li><li><p>4.通过URL传参数来给属性赋值(需要在表单的action后面添加参数)</p><p>   &lt;jsp:setProperty name=”myUsers” property=”password” param=”myPass”/&gt;</p></li></ul></li></ul><form name="loginForm" action="dologin.jsp?myPass= 888888" method="post"><ul><li><p>getProperty用法(<strong>代替了传统表达式和内置对象来获取用户名和密码)</strong></p><pre><code>&lt;jsp:getProperty name=&quot;myUsers&quot; property=&quot;username&quot;/&gt;</code></pre></li></ul><h3 id="JSP四个作用域对象范围"><a href="#JSP四个作用域对象范围" class="headerlink" title="JSP四个作用域对象范围"></a>JSP四个作用域对象范围</h3><p><img src="https://i.imgur.com/HG1zJN6.png" alt=""></p><p><strong>page仅在当前页面有效，哪怕用全局对象pageContext在另一个页面也获取不到值</strong></p><h3 id="http协议的无状态性"><a href="#http协议的无状态性" class="headerlink" title="http协议的无状态性"></a>http协议的无状态性</h3><p><strong>同一个浏览器多次发送请求给服务器，服务器并不会知道这是同一个浏览器，即无法保存用户状态。</strong><br>由于这个特性，提供了两大保存用户转状态的机制：</p><ul><li>session</li><li><p>cookie: <strong>Web服务器保存在客户端的一系列文本信息。但是容易泄露用户信息</strong></p><ul><li>购物车</li><li>判断注册用户是否已经登录网站</li></ul></li></ul><p><img src="https://i.imgur.com/iXXXQVM.png" alt=""><br><img src="https://i.imgur.com/GD3k516.png" alt=""><br><strong>注意设置完cookie后，比如遍历cookie时，当存在对应的用户cookie时，用户勾选了不记住登录状态，那么就要cookie失效，即cookie.setMaxAge(0)（马上删除这个cookie）,最后别忘记response.addCookie(cookie),否则不起作用</strong><br><img src="https://i.imgur.com/MsHeI7S.png" alt=""><br>是否保存过这个用户的cookie（<strong>如果用户勾选了不保存cookie，那么已经删除，这里就不会遍历到关于用户名和密码的cookie</strong>）<br><strong>解决Cookie无法保存中文字符串的问题 </strong></p><pre><code>String username= URLEncode.encode(request.getParameter(&quot;username&quot;),&quot;utf-8&quot;)</code></pre><p><strong>解决Cookie无法读取中文字符串的问题 </strong></p><pre><code>username= URLEncode.decode(c.getValue(),&quot;utf-8&quot;)</code></pre><h3 id="session和cookie对比"><a href="#session和cookie对比" class="headerlink" title="session和cookie对比"></a>session和cookie对比</h3><p><img src="https://i.imgur.com/wzdFsDc.png" alt=""></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul></form>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSP，即Java Server Pages，和Servlet一样，都是&lt;strong&gt;SUN公司定义的一种用于开发动态WEB资源的技术的标准，在服务器端执行的动态网页。&lt;/strong&gt;JSP虽然像是在写HTML，但是JSP允许在页面中嵌套Java代码，或者利用某个标签表
      
    
    </summary>
    
      <category term="前端" scheme="http://codinglembre.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaWeb" scheme="http://codinglembre.top/tags/JavaWeb/"/>
    
      <category term="JSP" scheme="http://codinglembre.top/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb之HTML+CSS笔记</title>
    <link href="http://codinglembre.top/2018/10/03/JavaWeb%E4%B9%8BHTML%E7%AC%94%E8%AE%B0/"/>
    <id>http://codinglembre.top/2018/10/03/JavaWeb之HTML笔记/</id>
    <published>2018-10-03T03:42:44.000Z</published>
    <updated>2018-10-03T18:00:02.192Z</updated>
    
    <content type="html"><![CDATA[<p><strong>HTML是网页内容的载体。HTML是静态页面，浏览器就可以解析。而JSP是动态页面，需要服务器去解析。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等. </strong>CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。由于前端并不是我的主要学习方向，但是在学习到JavaWeb时会用到，但是如果不懂，那也是比较麻烦的，所以这里只做简单的学习。</p><a id="more"></a><h3 id="html文件基本结构"><a href="#html文件基本结构" class="headerlink" title="html文件基本结构"></a>html文件基本结构</h3><pre><code>&lt;html&gt;    &lt;head&gt;...&lt;/head&gt;    &lt;body&gt;...&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>html文件由根标签,头部标签,网页内容标签组成。</strong></p><h3 id="一般的标签以及语法"><a href="#一般的标签以及语法" class="headerlink" title="一般的标签以及语法"></a>一般的标签以及语法</h3><ul><li>标题标签：&lt;h1&gt;标题&lt;/h1&gt; </li><li>段落标签：&lt;p&gt;段落&lt;/p&gt; </li><li>图片标签：&lt;img src=”1.jpg”&gt;</li><li><strong>&lt;body&gt;标签，网页上显示的内容放在这里</strong></li><li>加入强调语气，使用&lt;strong&gt;和&lt;em&gt;标签</li><li><strong>使用&lt;span&gt;标签为文字设置单独样式，需要与&lt;style&gt;标签配合使用</strong></li><li>&lt;q&gt;标签，短文本引用</li><li>&lt;blockquote&gt;标签，长文本引用</li><li>为你的网页中添加一些空格:语法&amp;nbsp+;</li><li>&lt;hr&gt;标签，添加水平横线</li><li>想加入一行代码吗？使用&lt;code&gt;标签</li><li>使用&lt;pre&gt;标签为你的网页加入大段代码</li><li>ul-li是没有前后顺序的信息列表。</li><li>使用ol，在网页中展示有前后顺序的信息列表</li></ul><p><strong>标签与标签之间是可以嵌套的，但先后顺序必须保持一致</strong>，如：&lt;div&gt;里嵌套&lt;p&gt;，那么&lt;/p&gt;必须放在&lt;/div&gt;的前面。<br><strong>HTML标签不区分大小写，</strong>&lt;h1&gt;和&lt;H1&gt;是一样的，但建议小写，因为大部分程序员都以小写为准。</p><h3 id="重要标签以及属性"><a href="#重要标签以及属性" class="headerlink" title="重要标签以及属性"></a>重要标签以及属性</h3><ul><li><strong>在网页制作过程过中，可以把一些独立的逻辑部分划分出来，放在一个div标签中，这个标签的作用就相当于一个容器</strong></li><li>表格的四个标签：table、tbody、tr、th、td。<strong>table表格在没有添加css样式之前，在浏览器中显示是没有表格线的，th标签中的文本默认为粗体并且居中显示</strong></li><li><p>用css样式，为表格加入边框</p><p>  &lt;style type=”text/css”&gt;</p><pre><code>table tr td,th{border:1px solid #000;}</code></pre><p>  &lt;/style&gt;</p></li><li><p>caption标签，为表格添加标题和摘要,<strong>摘要summary标签的内容是不会在浏览器中显示出来的。它的作用是增加表格的可读性(语义化）</strong></p><p>  &lt;table summary=”本表格记录2012年到2013年库存记录，记录包括U盘和耳机库存量”&gt;</p><pre><code>&amp;lt;caption&gt;2012年到2013年库存记录&lt;/caption&gt;&amp;lt;tr&gt;      &amp;lt;th&gt;产品名称 &lt;/th&gt;      &amp;lt;th&gt;品牌 &lt;/th&gt;  &amp;lt;th&gt;库存量（个） &lt;/th&gt;</code></pre><p>  &lt;th&gt;入库时间 </p><pre><code>&amp;lt;/tr&gt;</code></pre><p>  &lt;/table&gt;</p></li><li><p>使用a标签可实现超链接，里面<strong>title属性的作用，鼠标滑过链接文字时会显示这个属性的文本内容</strong>，target=”_blank”设置超链接在新的浏览器窗口中打开。</p></li></ul><h3 id="表单标签以及属性，与用户交互"><a href="#表单标签以及属性，与用户交互" class="headerlink" title="表单标签以及属性，与用户交互"></a>表单标签以及属性，与用户交互</h3><p><strong>所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在 <form></form> 标签之间（否则用户输入的信息可提交不到服务器上哦！），特别重要</strong><br>1.文本输入框、密码输入框<br>语法:</p><pre><code>&lt;form&gt;   &lt;input type=&quot;text/password&quot; name=&quot;名称&quot; value=&quot;文本&quot; /&gt;&lt;/form&gt;</code></pre><p><strong>name：为文本框命名，以备后台程序ASP 、PHP引用</strong>。value：为文本输入框设置默认值。(一般起到提示作用)<br>2.文本域，支持多行文本输入</p><pre><code>&lt;textarea  rows=&quot;行数&quot; cols=&quot;列数&quot;&gt;文本&lt;/textarea&gt;</code></pre><p>3.使用单选框、复选框，让用户选择</p><pre><code>&lt;input   type=&quot;radio/checkbox&quot;   value=&quot;值&quot;    name=&quot;名称&quot;   checked=&quot;checked&quot;/&gt;</code></pre><p>4.使用下拉列表框，节省空间</p><pre><code>&lt;select&gt;  &lt;option value=&quot;看书&quot;&gt;看书&lt;/option&gt;  &lt;option value=&quot;旅游&quot;selected=&quot;selected&quot;&gt;旅游&lt;/option&gt;  &lt;option value=&quot;运动&quot;&gt;运动&lt;/option&gt;  &lt;option value=&quot;购物&quot;&gt;购物&lt;/option&gt;&lt;/select&gt;</code></pre><p><strong>selected=”selected”：设置selected=”selected”属性，则该选项就被默认选中</strong><br>5.使用下拉列表框进行多选，<strong>设置multiple=”multiple”属性，就可以实现多选功能</strong></p><pre><code>&lt;select multiple=&quot;multiple&quot;&gt;  &lt;option value=&quot;看书&quot;&gt;看书&lt;/option&gt;  &lt;option value=&quot;旅游&quot;&gt;旅游&lt;/option&gt;  &lt;option value=&quot;运动&quot;&gt;运动&lt;/option&gt;  &lt;option value=&quot;购物&quot;&gt;购物&lt;/option&gt;&lt;/select&gt;</code></pre><p>6.使用提交按钮，提交数据</p><pre><code>&lt;input   type=&quot;submit&quot;   value=&quot;提交&quot;&gt;</code></pre><p>7.<strong>使用重置按钮，重置表单信息为初始状态</strong></p><pre><code>&lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;</code></pre><p>8.<strong>form表单中的label标签，标签的 for 属性中的值应当与相关控件的 id 属性值一定要相同。</strong></p><pre><code>&lt;form&gt;      &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;      &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;male&quot; /&gt;&lt;/form&gt;</code></pre><h3 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h3><p><strong>CSS可以让不同网页位置的文字有着统一的字体、字号或者颜色等。css 样式由选择符和声明组成，而声明又由属性和值组成</strong>，如下图所示：</p><p><img src="http://img.mukewang.com/52fde5c30001b0fe03030117.jpg" alt=""></p><blockquote><p>最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号。</p></blockquote><p>1.<strong>内联式css样式，直接写在现有的HTML标签中</strong></p><pre><code>&lt;p style=&quot;color:red&quot;&gt;这里文字是红色。&lt;/p&gt;&lt;p style=&quot;color:red;font-size:12px&quot;&gt;这里文字是红色。&lt;/p&gt;</code></pre><p>2.<strong>嵌入式css样式，写在当前的文件中</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;span{    color:red;    }&lt;/style&gt;</code></pre><p>3.<strong>外部式css样式，写在单独的一个文件中</strong></p><pre><code>&lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</code></pre><ul><li>1.css样式文件名称以有意义的英文字母命名，如 main.css。</li><li>2.<strong>rel=”stylesheet” type=”text/css” 是固定写法不可修改。</strong></li><li>3.<strong>link标签位置一般写在head标签之内。</strong></li></ul><p><strong> 优先级:相同权值下，就近原则</strong></p><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><pre><code>选择器{    样式;}</code></pre><p>包括标签选择器，类选择器，ID选择器，子选择器，包含选择器，通用选择器<br>类选择器和ID选择器的区别:</p><pre><code>.stress{    color:red;}.bigsize{    font-size:25px;}#stressid{    color:red;}#bigsizeid{    font-size:25px;}</code></pre><h3 id="CSS继承，层叠和特殊性"><a href="#CSS继承，层叠和特殊性" class="headerlink" title="CSS继承，层叠和特殊性"></a>CSS继承，层叠和特殊性</h3><p>1.<strong>继承CSS的某些样式是具有继承性的，注意只是有些</strong>，比如</p><pre><code>p{color:red;}&lt;p&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt;</code></pre><p>2.特殊性，即<strong>CSS样式矛盾</strong>有的时候我们为同一个元素设置了不同的CSS样式代码，那么元素会启用哪一个CSS样式呢?这跟权值有关</p><blockquote><p><strong>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为10,继承也有权值但很低，有的文献提出它只有0.1</strong></p></blockquote><p>3.<strong>层叠，即CSS样式覆盖,规则为后面的样式会覆盖前面的样式。</strong></p><h3 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h3><p>符合内容的结构化（内容语义化），选择合适的标签（代码语义化）<br>4.<strong>设置最高权值,使用!important来解决。</strong>:</p><pre><code>p{color:red!important;}p{color:green;}&lt;p class=&quot;first&quot;&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt;</code></pre><h3 id="CSS排版之文字与段落"><a href="#CSS排版之文字与段落" class="headerlink" title="CSS排版之文字与段落"></a>CSS排版之文字与段落</h3><p>####文字排版<br>1.字体。<strong>不要设置不常用的字体，因为如果用户本地电脑上如果没有安装你设置的字体，就会显示浏览器默认的字体</strong></p><pre><code>body{font-family:&quot;宋体&quot;;}</code></pre><p>2.字号、颜色。</p><pre><code>body{font-size:12px;color:#666}</code></pre><p>3.粗体</p><pre><code>p span{font-weight:bold;}</code></pre><p>4.斜体</p><pre><code>p a{font-style:italic;}</code></pre><p>5.下划线</p><pre><code>p a{text-decoration:underline;}</code></pre><p>6.删除线</p><pre><code>.oldPrice{text-decoration:line-through;}</code></pre><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>1.缩进，<strong>中文文字中的段前习惯空两个文字的空白，这个特殊的样式可以用下面代码来实现：</strong></p><pre><code>p{text-indent:2em;}</code></pre><p>2.行间距（行高）</p><pre><code>p{line-height:1.5em;}</code></pre><p>3.中文字间距、字母间距(就是文字间距)</p><pre><code>h1{letter-spacing:50px;}...&lt;h1&gt;了不起的盖茨比&lt;/h1&gt;</code></pre><p>4.对齐，<strong> 想为块状元素中的文本、图片设置居中样式？注意要设置宽度和高度</strong></p><pre><code>h1{    width:100px;    height: 50px;       text-align:center;}&lt;h1&gt;了不起的盖茨比&lt;/h1&gt;</code></pre><h3 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h3><p>常用的块状元素有：</p><pre><code>&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;</code></pre><p>常用的内联元素有：</p><pre><code>&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;</code></pre><p>常用的内联块状元素有：</p><pre><code>&lt;img&gt;、&lt;input&gt;</code></pre><p>1.<strong>元素分类–块级元素</strong><br><strong>如何将内联元素a转换为块状元素？</strong></p><pre><code>a{display:block;}</code></pre><p><strong>块状元素也可以通过代码display:inline将元素设置为内联元素。</strong></p><pre><code>div{ display:inline; }&lt;div&gt;我要变成内联元素&lt;/div&gt;</code></pre><p>内联元素特点：</p><ul><li><strong>和其他元素都在一行上；</strong></li><li><strong>元素的高度、宽度及顶部和底部边距不可设置；</strong></li><li><strong>元素的宽度就是它包含的文字或图片的宽度，不可改变。</strong></li></ul><p>Deom:<br><img src="https://i.imgur.com/sZxpve6.png" alt=""></p><p>inline-block 元素特点：</p><ul><li><strong>和其他元素都在一行上；</strong></li><li><strong>元素的高度、宽度、行高以及顶和底边距都可设置。</strong></li></ul><h3 id="CSS盒模型和布局模型"><a href="#CSS盒模型和布局模型" class="headerlink" title="CSS盒模型和布局模型"></a>CSS盒模型和布局模型</h3><p>1.边框</p><pre><code>div{border:2px  solid  red;}</code></pre><p>2.<strong>单独设置上下左右边框</strong></p><pre><code>li{border-bottom:1px dotted #ccc;}</code></pre><p>3.盒模型–宽度和高度<br><strong>一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。</strong></p><p>4.盒模型–填充(padding)<br><strong>显示在左上角不是padding的效果，而是html代码默认的就是从显示器的左上角开始显示，而整个HTML文档只有一个div元素，当然就显示在左上角了</strong><br><img src="https://i.imgur.com/FseuQai.png" alt=""><br>5.盒模型–边界<br><img src="https://i.imgur.com/RAdqNxE.png" alt=""></p><h3 id="CSS布局模型"><a href="#CSS布局模型" class="headerlink" title="CSS布局模型"></a>CSS布局模型</h3><ul><li>流动模型（Flow）</li><li>浮动模型 (Float)</li><li>层模型（Layer）</li></ul><p>1.流动模型<br><strong>块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。</strong><br><img src="https://i.imgur.com/hzNIeXe.png" alt=""></p><p><strong>，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示</strong><br>2.浮动模型<br><strong>块状元素这么霸道都是独占一行，如果现在我们想让两个块状元素并排显示</strong><br><img src="https://i.imgur.com/0bsLYzA.png" alt=""><br>3.层模型<br><strong>每个图层能够精确定位操作，但在网页设计领域，由于网页大小的活动性，层布局没能受到热捧</strong><br>1.层模型–绝对定位<br>绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位<br><img src="https://i.imgur.com/0NO1Zur.png" alt=""><br>2.层模型–相对定位<br>，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动<br><img src="https://i.imgur.com/ZIMbD7g.png" alt=""><br>3.层模型–固定定位<br>fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响<br><img src="https://i.imgur.com/Xhdb6Xi.png" alt=""></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;HTML是网页内容的载体。HTML是静态页面，浏览器就可以解析。而JSP是动态页面，需要服务器去解析。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等. &lt;/strong&gt;CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。由于前端并不是我的主要学习方向，但是在学习到JavaWeb时会用到，但是如果不懂，那也是比较麻烦的，所以这里只做简单的学习。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://codinglembre.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaWeb" scheme="http://codinglembre.top/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC学习之快速入门</title>
    <link href="http://codinglembre.top/2018/10/03/SpringMVC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://codinglembre.top/2018/10/03/SpringMVC学习之快速入门/</id>
    <published>2018-10-02T17:22:18.000Z</published>
    <updated>2018-10-03T03:28:21.178Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-MVC框架"><a href="#Spring-MVC框架" class="headerlink" title="Spring MVC框架"></a>Spring MVC框架</h3><h4 id="Spring-MVC介绍"><a href="#Spring-MVC介绍" class="headerlink" title="Spring MVC介绍"></a>Spring MVC介绍</h4><p><strong>SpringMVC和Struts2都属于表现层的框架，它是Spring框架的一个模块，提供web层解决方案，我们可以从Spring的整体结构中看得出来:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%887.56.09.png" alt=""></p><h4 id="MVC在b-s系统的应用"><a href="#MVC在b-s系统的应用" class="headerlink" title="MVC在b/s系统的应用"></a>MVC在b/s系统的应用</h4><p><strong>mvc是一个设计模式，在b/s系统(即浏览器和服务器端，在客户机端不用装专门的软件，只要一个浏览器即可)</strong>的应用如图:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%887.58.00.png" alt=""><br>解释如下:</p><ul><li>1.用户发起request请求至控制器(Controller),控制接收用户请求的数据，委托给模型进行处理。</li><li>2.控制器通过模型(Model)处理数据并得到处理结果，模型通常是指业务逻辑(jsp、dao、service)。</li><li>3.模型处理结果返回给控制器。</li><li>4.控制器将模型数据在视图(View)中展示，web中模型无法将数据直接在视图上显示，需要通过控制器完成。如果在C/S应用中模型是可以将数据在视图中展示的。</li><li>5.控制器将视图response响应给用户，通过视图展示给用户要的数据或处理结果。</li></ul><h4 id="Spring-mvc架构"><a href="#Spring-mvc架构" class="headerlink" title="Spring mvc架构"></a>Spring mvc架构</h4><p>1.架构图<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%888.04.54.png" alt=""><br>2.架构流程</p><ul><li>1.用户发送请求至前端控制器DispatcherServlet</li><li>2.DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>3.处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li><li>4.DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</li><li>5.执行处理器(Controller，也叫后端控制器)。</li><li>6.Controller执行完成返回ModelAndView</li><li>7.HandlerAdapter将controller执行结果ModelAndView返回</li><li>8.DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>9.ViewReslover解析后返回具体View</li><li>10.DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</li><li>11.DispatcherServlet响应用户</li></ul><p>3.架构中涉及的组件说明</p><ul><li>1.DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。由框架实现</li><li>2.HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。由框架实现</li><li>3.Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</li><li>4.HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。</li><li>5.ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</li></ul><h3 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p><strong>实现商品列表的查询并在页面中显示。这里由于Spring mvc不涉及对数据库的操作，所以我们在程序中的数据就用静态数据生成。</strong></p><h4 id="第一步-前端控制器的配置"><a href="#第一步-前端控制器的配置" class="headerlink" title="第一步:前端控制器的配置"></a>第一步:前端控制器的配置</h4><p>在WEB-INF/web.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;     version=&quot;3.1&quot;&gt;&lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!--加载springmvc配置文件--&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;!--配置文件的地址        如果不配置contextConfigLocation，默认查找的配置文件名称是classpath下的:servlet名称+&quot;-servlet.xml&quot;        即springmvc-servlet.xml--&gt;        &lt;param-value&gt;springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;!--可以配置/：此工程所有的请求全部由springmvc解析，此种方式可以实现RESTful方式，需要特殊处理对静态文件的解析不能由springmvc解析    可以配置*.do或者*.action,所有请求的url扩展名为.do或.action由springmvc解析，此中方法常用    不可以配置/*,如果配置/*,返回jsp也由springmvc解析，这是不对的--&gt;    &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h4 id="第二步-Spring-MVC配置文件"><a href="#第二步-Spring-MVC配置文件" class="headerlink" title="第二步:Spring MVC配置文件"></a>第二步:Spring MVC配置文件</h4><p><strong>在web目录下创建Spring MVC的配置文件springmvc.xml，以后需要在里面配置Spring MVC架构三大组件(处理器映射器、适配器、视图解析器)，里面根标签的内容同Spring的配置文件:</strong></p><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd    http://www.springframework.org/schema/mvc    http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd    http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context-3.2.xsd    http://www.springframework.org/schema/aop    http://www.springframework.org/schema/aop/spring-aop-3.2.xsd    http://www.springframework.org/schema/tx    http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;&lt;/beans&gt;</code></pre><h4 id="第三步-配置处理器映射器"><a href="#第三步-配置处理器映射器" class="headerlink" title="第三步:配置处理器映射器"></a>第三步:配置处理器映射器</h4><p><strong>因为对于用户发起的request请求，前端控制器首先会请求HandlerMapping处理器映射器来查找Handler，所以我们首先配置它，在springmvc.xml中加入如下内容:</strong></p><pre><code>&lt;!--配置处理器映射器springmvc框架根据HandlerMapping接口判断是否是处理器映射器--&gt;&lt;!--根据bean的name进行查找Handler,将action的url配置在bean的name中--&gt;&lt;bean    class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;</code></pre><p><strong>BeanNameUrlHandlerMapping:表示将定义的Bean名字作为请求的url，需要将编写的controller在spring容器中进行配置，且指定bean的name为请求的url，且必须以.action结尾。</strong></p><h4 id="第四步-配置处理器适配器"><a href="#第四步-配置处理器适配器" class="headerlink" title="第四步:配置处理器适配器"></a>第四步:配置处理器适配器</h4><p>处理器映射器将查找到的Handler返回给DispatcherServlet后，DispatcherServlet会调用适配器执行Handler，通过适配器去扩展对不同Handler的执行。所以我们再配置它,在springmvc.xml中添加如下内容:</p><pre><code>&lt;!--配置处理器适配器springmvc框架根据HandlerAdapter接口判断是否是处理器适配器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;</code></pre><p>SimpleControllerHandlerAdapter:即简单控制器处理适配器，所有实现了org.springframework.web.servlet.mvc.Controller 接口的Bean作为Springmvc的后端控制器。</p><h4 id="第五步-后端控制器的编写"><a href="#第五步-后端控制器的编写" class="headerlink" title="第五步:后端控制器的编写"></a>第五步:后端控制器的编写</h4><p>DispatcherServlet通过处理器适配器找到后端控制器Handler，所以我们需要进行Handler的编写,在src包下新建ItemController.java，内容如下:</p><pre><code>package controller;public class ItemController1 implements Controller{@Overridepublic ModelAndView handleRequest(HttpServletRequest httpServletRequest,                                  HttpServletResponse httpServletResponse) throws Exception {    //使用静态的数据将商品信息显示在jsp页面    List&lt;Items&gt; itemsList = new ArrayList&lt;&gt;();    Items items_1 = new Items();    items_1.setName(&quot;联想笔记本&quot;);    items_1.setPrice(6000f);    items_1.setCreatetime(new Date());    items_1.setDetail(&quot;ThinkPad T430 联想笔记本电脑！&quot;);    Items items_2 = new Items();    items_2.setName(&quot;苹果手机&quot;);    items_2.setPrice(5000f);    items_2.setDetail(&quot;iphone6苹果手机！&quot;);    itemsList.add(items_1);    itemsList.add(items_2);    ModelAndView modelAndView=new ModelAndView();    modelAndView.addObject(&quot;itemsList&quot;,itemsList);    modelAndView.setViewName(&quot;/WEB-INF/jsp/itemsList.jsp&quot;);//指定用户访问的jsp页面地址    return modelAndView;}}</code></pre><p>数据我们采用静态数据的输入，当然我们还需要创建Items.java这个pojo对象，就是上一篇文章中我们用到的.java文件。</p><h4 id="第六步-后端控制器的配置"><a href="#第六步-后端控制器的配置" class="headerlink" title="第六步:后端控制器的配置"></a>第六步:后端控制器的配置</h4><pre><code>&lt;!--配置Handler由于使用了BeanNameUrlHandlerMapping处理映射器，所以name要配置为url--&gt;&lt;bean name=&quot;/itemList.action&quot; class=&quot;controller.ItemController1&quot;&gt;&lt;/bean&gt;</code></pre><p>name=”/itemsList.action”:前边配置的处理器映射器为BeanNameUrlHandlerMapping，如果请求的URL为“上下文/itemsList.action”将会成功映射到ItemController1控制器。</p><h4 id="配置视图解析器"><a href="#配置视图解析器" class="headerlink" title="配置视图解析器"></a>配置视图解析器</h4><p><strong>Handler执行完成后给处理器适配器返回一个ModelAndView对象，</strong>它是Spring MVC的一个对象，用于对Model和View进行封装。然后处理器适配器又将这个对象返回给DispatcherServlet,DispatcherServlet调用视图解析器进行视图解析，所以这里我们要配置视图解析器，在springmvc.xml中添加如下内容:<br>    <!--配置视图解析器    要求将jstl的包加到classpath--><br>    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"><br>    </bean><br>然后部署服务器，在浏览器中输入<a href="http://localhost:8080/SpringMvc/itemList.action后便可以看到如下页面" target="_blank" rel="noopener">http://localhost:8080/SpringMvc/itemList.action后便可以看到如下页面</a>:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%888.47.32.png" alt=""></p><p>扩展:对于前端控制器DispatcherServlet,我有必要多说几句，<strong>在spring-webmvc.jar包中有一个DispatcherServlet.properties文件</strong>，内容如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%886.51.45.png" alt=""><br>里面包含一些默认的组件例如处理器映射器、处理器适配器等，当程序启动时，DispatcherServlet会自动加载DispatcherServlet.properties配置文件，从而默认加载各个组件，所以如果我们在springmvc.xml中配置了处理器映射器和处理器适配器，那程序就以springmvc.xml中的配置信息为主。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring-MVC框架&quot;&gt;&lt;a href=&quot;#Spring-MVC框架&quot; class=&quot;headerlink&quot; title=&quot;Spring MVC框架&quot;&gt;&lt;/a&gt;Spring MVC框架&lt;/h3&gt;&lt;h4 id=&quot;Spring-MVC介绍&quot;&gt;&lt;a href=&quot;#S
      
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="SpringMVC" scheme="http://codinglembre.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习之快速入门</title>
    <link href="http://codinglembre.top/2018/10/03/Spring%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://codinglembre.top/2018/10/03/Spring学习之快速入门/</id>
    <published>2018-10-02T16:10:29.000Z</published>
    <updated>2018-11-13T13:06:16.377Z</updated>
    
    <content type="html"><![CDATA[<p>当客户端向服务器发出请求时，服务器把得到的请求发送给控制器Servlet，而在Servlet中需要创建Service对象来调用业务层相关功能(故说控制器层Servlet依赖于业务层Service),而在Service中又需要创建数据库层DAO对象来对数据库进行操作(故说业务层Service依赖于数据库层DAO)。</p><p>思考:针对上述过程，我们需要考虑这样几个问题。1.Servlet、Service以及Dao对象的创建时间、创建数量。2.<strong>Servlet、Service以及Dao之间的依赖关系。如何处理这些问题呢</strong>？<strong>Spring就是用来处理对象的创建、以及对象之间依赖关系的一个开发框架</strong>。它打破了我们传统开发的观念，我们不再需要像以前那样在具体的类中创建具体的对象，而是将<strong>对象的创建交给它去完成</strong>。它是我们所要学习的框架中最重要的框架，请务必好好学习。</p><a id="more"></a><h3 id="Spring框架中的专业术语"><a href="#Spring框架中的专业术语" class="headerlink" title="Spring框架中的专业术语"></a>Spring框架中的专业术语</h3><h4 id="组件／框架设计"><a href="#组件／框架设计" class="headerlink" title="组件／框架设计"></a>组件／框架设计</h4><ul><li>侵入式设计:对现有类的结构有影响，即需要实现或继承某些特定类。 如Struts框架。</li><li><strong>非侵入式设计:引入了框架，对现有的类结构没有影响。如Spring框架</strong>／Hibernate框架。</li></ul><h4 id="控制反转和依赖注入"><a href="#控制反转和依赖注入" class="headerlink" title="控制反转和依赖注入"></a>控制反转和依赖注入</h4><p>控制反转Inversion On Control，简称IOC。对象的创建交给外部容器自动完成，这个就叫做控制反转。(有控制反转就有控制正转，<strong>控制正转:对象的创建由我们自己创建</strong>)</p><p>依赖注入dependency injection,简称DI，用于处理对象间的依赖关系。</p><p><strong>二者区别:控制反转(IOC):解决对象创建的问题，(对象的创建交给别人)。依赖注入(DI):在创建完对象后，对象关系的处理就是依赖注入，(通过set方法依赖注入。)</strong></p><h4 id="面向切面编程AOP"><a href="#面向切面编程AOP" class="headerlink" title="面向切面编程AOP"></a>面向切面编程AOP</h4><p>面向切面编程。<strong>切面，简单来说可以理解为一个类，由很多重复代码形成的类。切面举例:事务、日志、权限。</strong> 关于AOP的详细讲解我推荐你们看这篇博客:<a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/" target="_blank" rel="noopener">Spring AOP实现原理与应用</a></p><h3 id="Spring框架概述"><a href="#Spring框架概述" class="headerlink" title="Spring框架概述"></a>Spring框架概述</h3><p><strong>Spring框架，可以解决对象创建以及对象之间依赖关系的一种框架。</strong>且可以和其它框架一起使用，例如spring与struts、spring和hibernate。(起到整合／粘合作用的一个框架)。<br>spring提供了一站式解决方案:<br>1）SpringCore:是Spring的核心功能：IOC容器，解决对象创建及依赖关系。<br>2）SpringWeb:Spring对web模块的支持。</p><blockquote><p>可以与struts整合，让struts的action创建交给spring。<br>Spring mvc模式，用springmvc整合了就不用struts了。</p></blockquote><p>3）Spring DAO:是Spring对Jdbc操作的支持。(Jdbc Template模块工具类)</p><p>4)Spring ORM:是Spring对ORM的支持。</p><blockquote><p>既可以与hibernate整合(使用原始的session)<br>也可以使用Spring对Hibernate操作的封装(对上面的session又进行了一层封装)</p></blockquote><p>5）Spring AOP:关于AOP的详细讲解我推荐你们看这篇博客:<a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/" target="_blank" rel="noopener">Spring AOP实现原理与应用</a></p><p>6）SpringEE:Spring对javaEE其它模块的支持</p><h3 id="Spring开发步骤"><a href="#Spring开发步骤" class="headerlink" title="Spring开发步骤"></a>Spring开发步骤</h3><p>1)导入jar包:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%882.01.02.png" alt=""><br>写在前面的话:当你运行程序出现org.springframework.beans.factory.BeanDefinitionStoreException的报错信息时，不要想了，出现这种报错的信息原因绝对是因为jdk版本和你导入的spring jar包不兼容的问题。<strong>由于spring3.x与jdk1.7兼容，而spring4.x与jdk1.8兼容</strong>，所以这里提供两种解决方案:<br>1.将jdk版本调为1.7，我用的开发工具为IDEA，它默认下的JDK使用1.8版本，所以我需要在三个地方将jdk的版本改过来(前提是你已经下载了jdk1.7版本)，修改IDEA配置中Project的jdk版本、Modules的jdk版本、SDKs的版本，如果你用到leTomcat还需要修改Tomcat配置的jdk版本。这样jdk1.7与spring3.x才兼容。<br>2.将spring3.x.jar换成spring4.x.jar包。这种方式比较繁琐，建议大家使用第一种方式。spring4.x与jdk1.8才兼容。<br>2)配置核心文件applicationContext.xml(文件名称随意):</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;    http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt;</code></pre><p>3)使用:<br>首先我们创建一个pojo对象User.java:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.48.12.png" alt=""><br>然后创建测试类使用这个User对象，以前我们要使用User对象时直接像这样User user=new User();new一个对象即可:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.50.26.png" alt=""><br>而当我们使用Spring后就应该这样使用User对象，首先在applicationContext.xml中添加<bean>标签，一个<bean>标签代表一个pojo对象:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.53.52.png" alt=""><br>其中各个属性的说明见注释。然后我们通过如下步骤获取该pojo对象:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.59.37.png" alt=""><br>运行测试类:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.59.42.png" alt=""><br>说明成功获取到User对象。<strong>上述是通过工厂类获取的IOC容器创建的User对象，下面我们看看使用Spring框架获取pojo对象的第二种方式直接得到IOC容器的对象:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.05.52.png" alt=""><br>运行程序，成功打印出user信息，说明我们通过IOC容器成功获取到user对象。</bean></bean></p><h3 id="lt-bean-gt-创建的细节"><a href="#lt-bean-gt-创建的细节" class="headerlink" title="&lt;bean&gt;创建的细节"></a>&lt;bean&gt;创建的细节</h3><p><strong>对上述代码进行改进，对于IOC容器对象，我们只需创建一次即可，所以将创建IOC对象的代码改为成员变量。</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.14.51.png" alt=""><br>代码中我们通过IOC对象创建了两个User对象，运行测试类得到打印结果:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.15.44.png" alt=""><br><strong>发现答应的这两个User对象id都一样，说明我们获取到的是同一个对象，也说明通过<bean>标签设置的pojo对象是单例的。</bean></strong>为什么呢？其实<bean>标签默认有一个scope=”singleton”的属性，代表该&lt;bean标签对象的pojo对象是单例的。我们可以将该属性值改为scope=”prototype”，如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.18.48.png" alt=""><br>然后再运行测试类,输出如下内容:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.19.43.png" alt=""><br>说明此时获取的两个User不再是同一个对象。</bean></p><p>那么由<strong>IOC容器管理的pojo对象应该在何时创建</strong>呢？我们来看看，首先在User.java中添加一个无参构造器:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.31.57.png" alt=""></p><p>然后修改测试类:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.32.37.png" alt=""><br>运行测试类:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.33.24.png" alt=""><br>从控制台中输出内容我们可以得知:<strong>当程序运行时，IOC容器首先创建，然后当我们需要得到IOC容器中的pojo对象时我们通过语句ac.getBean(“user”);得到，此时就会在IOC中创建由它管理的pojo对象</strong>。当我们删除ac.getBean(“user”);语句时，再次运行程序，得到如下内容:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.36.49.png" alt=""><br>这说明什么呢?说明IOC容器中没有创建pojo对象(因为一旦创建就会有”—User对象创建—“的语句输出)。综上情况，即只有当我们用到pojo对象时，IOC容器才会在自己内部创建它。此种情况为<bean>标签的属性为scope=”prototype”的结果，那么我们再来看看<strong>当属性为scope=”singleton”时的输出结果为</strong>:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.40.53.png" alt=""><br>打印台的内容说明该User对象在程序启动时就创建在IOC容器中了，不信我们把通过IOC容器得到User对象的代码注释掉再看输出结果:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.42.48.png" alt=""></bean></p><p>发现此时即使我们不通过ac.getBean(“user”);语句得到User对象，它也在程序启动时就创建了。</p><p><strong>总结:在<bean>标签中设置bean对象为单例时，该对象在系统启动时就会创建；设置为多例时，该对象在我们需要使用时才创建。</bean></strong></p><h4 id="标签中的其它属性说明"><a href="#标签中的其它属性说明" class="headerlink" title="标签中的其它属性说明"></a><bean>标签中的其它属性说明</bean></h4><ul><li>1.lazy-init:<strong>延迟初始化bean对象，默认值为false，即不延迟创建bean对象，在程序启动时就在IOC中创建bean对象</strong>；若其值为true则延迟创建bean对象，即在我们需要对象时才在IOC容器中创建该对象。此属性只对单例bean对象有效。</li><li>2.init-method:可以给该属性传递一个在pojo对象中创建的方法例如A方法的方法名A作为init-method的属性值，表示当该pojo对象在IOC容器中被创建后就立刻执行这个A方法。</li><li>3.destoy-method:同上，给该属性传递一个在pojo对象中创建的方法例如B方法的方法名B作为destoy-method的属性值，表示当IOC容器被销毁时(该pojo对象也会在IOC中销毁)会立刻调用这个B方法。当然我们通过ApplicationContext ac=new ClassPathXmlApplicationContext(“applicationContext.xml”);创建的IOC对象ac是没有destoy()方法的，我们需要这个创建IOC对象ClassPathXmlApplicationContext ac=new ClassPathXmlApplicationContext(“applicationContext.xml”);这样创建出来的IOC对象才有destoy()方法。</li></ul><h3 id="Spring-IOC容器"><a href="#Spring-IOC容器" class="headerlink" title="Spring IOC容器"></a>Spring IOC容器</h3><p><strong>Spring IOC容器，是Spring的核心内容，用于创建对象和处理对象间的依赖关系。</strong></p><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>利用IOC容器创建对象的方式有如下几种:1.调用无参数构造器。2.调用带参数构造器。3.工厂创建对象。包括工厂类的静态方法创建对象和工厂类的非静态方法创建对象4.<strong>反射。(IOC的原理就是通过反射来创建对象)</strong><br>1.调用无参数构造器,在配置文件中加入如下内容:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.31.43.png" alt=""><br>2.调用带参数构造器<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.31.50.png" alt=""></p><p><constructor-arg>标签中还有一个ref的属性，属性值代表引用配置文件(即IOC容器)中的相应对象。</constructor-arg></p><p>故<strong>还可以采用这种方法调用带参数构造器创建对象:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.31.58.png" alt=""><br>3.用工厂创建对象<br>首先创建一个工厂类:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.34.32.png" alt=""><br>调用工厂的实例方法创建对象:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.32.02.png" alt=""><br>调用工厂静态方法创建对象:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.32.05.png" alt=""></p><h4 id="处理对象的依赖关系"><a href="#处理对象的依赖关系" class="headerlink" title="处理对象的依赖关系"></a>处理对象的依赖关系</h4><p><strong>在IOC容器的配置文件中我们有如下给对象注入属性的方法:1.通过构造方法。2.通过set方法给属性注入值。3.p名称空间。4.自动装配。5.注解。</strong></p><p>1.通过构造方法<br>首先我们来看看如何通过构造方法来给对象的属性赋值,在配置文件中添加如下标签即可通过构造器给该User对象的属性赋值:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.21.03.png" alt=""></p><p>2.通过set方法给属性注入值。<br><strong>通过set方法给属性赋值,前提是在User对象中给它的属性添加了set方法:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.26.29.png" alt=""><br>接下来我们看个案例，<strong>以前我们开发时根据MVC模式都会像下面这样建立相应的Service.java、Servlet.java和dao.java:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.38.05.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.38.10.png" alt=""><br><strong>都需要我们自己在.java文件中添加A a=new A();来创建其所需要的依赖对象，而现在我们就将对象的创建交给IOC了，选择set给属性赋值的方式来给它们注入其所需依赖对象，修改它们的代码:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.44.48.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.44.53.png" alt=""><br>然后我们需要在application.xml中进行配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.48.51.png" alt=""><br>ref的属性值代表给该对象注入它所依赖的对象，即我们上述讲到的依赖注入(dependency injection),通过上述步骤我们便完成了将对象的创建交给IOC的操作。</p><p>上述三个对象的创建我们需要写三个<bean>标签才能完成，<strong>接下来我将介绍第二种方法通过内部bean的操作一次性完成它们的创建以及它们之间的依赖关系，修改配置文件中的内容</strong>:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%885.04.23.png" alt=""><br>通过上述内部<bean>标签的方式我们便可实现和set注入依赖相同的效果。我们来看看它们两者的相同和区别:</bean></bean></p><ul><li>相同:都可以创建Service对象，并处理了之间的依赖关系。</li><li><p>区别:set注入创建的Service对象可以给另一个Servlet对象调用，而内部bean将Service对象写在Servlet内部导致该Service对象只能被该Servlet使用，所以内部bean标签的使用场景在只需要一个Servlet对象的项目中。<br>3.通过p名称空间给对象的属性注入值<br><strong>此中方法只有在Spring3.0版本及以上版本才能用。首先在配置文件的<beans>根标签中加入属性:xmlns:p=”<a href="http://www.springframework.org/schema/p&quot;。" target="_blank" rel="noopener">http://www.springframework.org/schema/p&quot;。</a></beans></strong>然后我们便可以在配置文件中这样给对象的属性赋值:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%885.18.05.png" alt=""><br>当我们在配置文件中输入p:时，会出现两个属性1.p:userDao 和p:userDao-ref,这里有必要说明一下二者区别:</p></li><li><p>p:userDao:代表直接给UserService对象的userDao属性赋值</p></li><li>p:userDao-ref:代表引用的userDao对象</li></ul><p>例如使用p名称空间给传统的对象属性赋值时我们这样写:</p><pre><code>&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot; p:id=&quot;xxx&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot; p:name=&quot;xxx&quot;/&gt;</code></pre><p>4.通过自动装配<br>当我们在配置文件中用<bean>标签指明相应对象的同时就将这个对象放入到了IOC容器中(其中标签中的id属性唯一指示一个对象)，<strong>当我们给该bean标签添加了autowrite=”byName”的属性后，对于该标签对应的对象注入的属性，会去IOC容器中自动查找与属性同名的对象。</strong><br>例如如下代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%8812.12.14.png" alt=""><br>通过上述三个<bean>标签我们就将userDao、userService、userServlet三个对象添加到了IOC容器中。我们在UserService对象的bean标签中加上了autowrite=”byName”的属性，这样我们查看UserService.java的代码，它有一个UserDao对象名为userDao的属性，此时就会自动去IOC容器中寻找与userDao同名的对象(即在bean标签中寻找id为userDao的对象)，然后进行注入，此时我们若将<bean id="userDao" class="pojo.UserDao">的id=”userDao”属性值改为userDao1或者其它名字，则运行系统会出现空指针异常，道理上述已分析。UserServlet注入userService的属性道理同此。</bean></bean></bean></p><p>我们也可以将该属性定义到全局<beans>标签中，设置default-autowrite=”byName”的属性,这样就不用每个bean标签中都写上autowrite=”byName”属性了。</beans></p><p>上述是根据名称自动装配，其实autowrite的属性值还可以为byType即根据类型自动装配。对于<bean id="userService" class="pojo.UserService">，当添加了autowrity=”byType”的属性后，此时寻找它依赖的属性userDao的过程如下:查看UserService.java代码，它需要注入的属性类型为UserDao类型，所以就会自动去IOC容器中查找UserDao类型的对象并自动为UserService对象注入该属性，此时各bean标签的id属性值便可以随便写了如果根据类型自动装配，则要保证保证该类型的对象只有一个，否则会报错。该属性同样可以在全局beans标签中进行配置。</bean></p><p><strong>利用自动装配的优缺点:简化了配置，但不利用系统维护。所以一般不推荐此中用法，下面我们再来介绍第5中非常简单的配置。</strong></p><p>5.通过注解<br><strong>注解方式可以简化Spring的IOC容器的配置。</strong><br>使用步骤:</p><ul><li>1.先引入context名称空间</li><li>2.开启注解扫描</li><li>3.使用注解:通过注解的方式，把对象加入到IOC容器中</li></ul><p>首先在IOC配置文件中引入context名称空间,即在<beans>全局标签中添加xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;属性" target="_blank" rel="noopener">http://www.springframework.org/schema/context&quot;属性</a><br>然后在配置文件中添加如下标签：<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%8812.53.31.png" alt=""><br>base-package:表示该扫描器只扫描此包下所有类。</beans></p><p>最后我们便可以使用注解了，在pojo对象的.java文件中分别加入如下注解:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%8812.54.31.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%8812.54.43.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%8812.54.52.png" alt=""><br><strong>@Componet注解:代表将该对象放入到IOC容器中，括号里面的名字代表该对象在IOC容器中的唯一标识名字，名字任意取。该注解写在代码第一行。</strong></p><p><strong>@Resource注解:用于将该对象依赖的属性从IOC容器中找到并注入，括号里面的name属性值必须跟@Compenent注解里填入的名字相同。</strong></p><p><strong>通过注解方法便可去掉各.java文件中为属性创建设置的set方法。</strong></p><p>继续对上述注解方式进行配置优化，去掉括号中的内容:<br><img src="img src=&quot;http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%881.21.06.png&quot; alt=&quot;&quot;" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%881.21.10.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%881.21.15.png" alt=""></p><p>在测试类中运行依然可以正常运行。</p><p>说明:<strong>利用@Compenent注解的方式是通用的将对象加入到IOC容器中的方式，而有时候我们需要区别各层对象添加的方式，所以这里我们将Dao层对象添加到IOC容器的注解方式改为:@Repository表示持久层的组件;修改Service层对象添加到IOC容器的注解方式:@Service表示业务逻辑层的组件;修改Servlet层对象添加到IOC容器的注解方式为:@Controller表示控制层的组件。</strong></p><p>另外需要说明的是使用注解的方式将对象添加到IOC容器中和在xml文件中添加配置的方式是可以共存的。但通过@Resource不带括号的注解，必须要保证该类型只有一个变量，所以一般情况下我们还是优先使用@Resource(name=””)注解。</p><p>到此，Spring框架的学习我们已完成。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当客户端向服务器发出请求时，服务器把得到的请求发送给控制器Servlet，而在Servlet中需要创建Service对象来调用业务层相关功能(故说控制器层Servlet依赖于业务层Service),而在Service中又需要创建数据库层DAO对象来对数据库进行操作(故说业务层Service依赖于数据库层DAO)。&lt;/p&gt;
&lt;p&gt;思考:针对上述过程，我们需要考虑这样几个问题。1.Servlet、Service以及Dao对象的创建时间、创建数量。2.&lt;strong&gt;Servlet、Service以及Dao之间的依赖关系。如何处理这些问题呢&lt;/strong&gt;？&lt;strong&gt;Spring就是用来处理对象的创建、以及对象之间依赖关系的一个开发框架&lt;/strong&gt;。它打破了我们传统开发的观念，我们不再需要像以前那样在具体的类中创建具体的对象，而是将&lt;strong&gt;对象的创建交给它去完成&lt;/strong&gt;。它是我们所要学习的框架中最重要的框架，请务必好好学习。&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://codinglembre.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis学习之查询缓存</title>
    <link href="http://codinglembre.top/2018/10/02/MyBatis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/"/>
    <id>http://codinglembre.top/2018/10/02/MyBatis学习之查询缓存/</id>
    <published>2018-10-02T14:00:14.000Z</published>
    <updated>2018-11-13T11:59:48.890Z</updated>
    
    <content type="html"><![CDATA[<p>正如大多数持久层框架一样，MyBatis同样也提供了对查询数据的缓存支持。今后我们要学习的<strong>SpringMVC框架属于系统控制层，它也有它的缓存区域，对响应的jsp页面进行缓存；Spring属于系统业务层，它的缓存区域对业务数据进行缓存。</strong>而它们三者的缓存区域都存在于用户要访问数据库的中间，<strong>当用户向数据库中发送查询请求时，系统会先在它们三者的缓存区域看是否有满足用户要求的查询数据，若有则直接从缓存区域返回信息；若没有则从数据库中进行查询。</strong></p><a id="more"></a><h3 id="缓存的意义"><a href="#缓存的意义" class="headerlink" title="缓存的意义"></a>缓存的意义</h3><p><strong>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</strong></p><h3 id="MyBatis持久层缓存"><a href="#MyBatis持久层缓存" class="headerlink" title="MyBatis持久层缓存"></a>MyBatis持久层缓存</h3><p>MyBatis提供了一级缓存和二级缓存，概念图如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.15.43.png" alt=""><br>图中所示，<strong>MyBatis一级缓存是一个SqlSession级别，SqlSession只能访问自己的一级缓存的数据，二级缓存是跨SqlSession，是mapper级别的缓存，对于mapper级别的缓存不同的Sqlsession是可以共享的。</strong></p><h3 id="MyBatis一级缓存"><a href="#MyBatis一级缓存" class="headerlink" title="MyBatis一级缓存"></a>MyBatis一级缓存</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.19.30.png" alt=""><br><strong>对于图的解释:第一次发出一个查询sql，sql查询结果写入sqlsession的一级缓存中，缓存使用的数据结构是一个map&lt;key,value&gt;。</strong></p><ul><li>key：hashcode+sql+sql输入参数+输出参数（sql的唯一标识）</li><li>value：用户信息</li></ul><p>同一个sqlsession再次发出相同的sql，就从缓存中取,而不走数据库。如果两次中间出现commit操作（修改、添加、删除），本sqlsession中的一级缓存区域全部清空，下次再去缓存中查询不到所以要从数据库查询，从数据库查询到再写入缓存。即对于查询操作，每次查询都先从缓存中查询，如果缓存中查询到数据则将缓存数据直接返回，如果缓存中查询不到就从数据库查询。</p><h4 id="一级缓存配置"><a href="#一级缓存配置" class="headerlink" title="一级缓存配置"></a>一级缓存配置</h4><p><strong>mybatis默认支持一级缓存不需要配置</strong>。</p><p>注意:mybatis和spring整合后进行mapper代理开发，不支持一级缓存，mybatis和spring整合，spring按照mapper的模板去生成mapper代理对象，模板中在最后统一关闭sqlsession。</p><h4 id="一级缓存的测试"><a href="#一级缓存的测试" class="headerlink" title="一级缓存的测试"></a>一级缓存的测试</h4><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.25.22.png" alt=""><br>运行，在控制台看到输出:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.26.38.png" alt=""><br><strong>发现打印两次结果只有第一次向数据库中发送了查询请求，第二次是直接从缓存中返回的数据。接下来我们在中间加入更新数据的操作:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.29.29.png" alt=""><br>然后在控制台中看到打印过程:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.30.31.png" alt=""><br>可以发现向数据库发送了三次请求。</p><h3 id="MyBatis二级缓存"><a href="#MyBatis二级缓存" class="headerlink" title="MyBatis二级缓存"></a>MyBatis二级缓存</h3><h4 id="二级缓存原理"><a href="#二级缓存原理" class="headerlink" title="二级缓存原理"></a>二级缓存原理</h4><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.31.30.png" alt=""><br>二级缓存的范围是mapper级别（mapper同一个命名空间），mapper以命名空间为单位创建缓存数据结构，结构是map&lt;key、value&gt;。</p><p>过程:<strong>每次查询先看是否开启二级缓存，如果开启从二级缓存的数据结构中取缓存数据，如果从二级缓存没有取到，再从一级缓存中找，如果一级缓存也没有，从数据库查询</strong></p><h4 id="二级缓存的配置"><a href="#二级缓存的配置" class="headerlink" title="二级缓存的配置"></a>二级缓存的配置</h4><p>不像一级缓存那样mybatis自动开启一级缓存，mybatis是默认关闭二级缓存的，所以我们需要需要进行两个操作才能开启二级缓存:<br>1.在核心配置文件SqlMapperConfig.xml中加入</p><pre><code>&lt;!--开启二级缓存--&gt;&lt;setting name = &quot;cacheEnabled&quot; value = &quot;true&quot;&gt;</code></pre><p>属性值cacheEnabled表示对在此配置文件下的所有cache 进行全局性开/关设置，它的可选值为true｜false,默认值为true.</p><p>2.<strong>在你的Mapper映射文件中添加一行:<cache> ，表示此mapper开启二级缓存。</cache></strong><br>3.查询结果映射的pojo序列化：<br><strong>mybatis二级缓存需要将查询结果映射的pojo实现 java.io.serializable接口，如果不实现则抛出异常：</strong><br>org.apache.ibatis.cache.CacheException: Error serializing object. Cause: java.io.NotSerializableException: cn.itcast.mybatis.po.User</p><p>二级缓存可以将内存的数据写到磁盘，存在对象的序列化和反序列化，所以要实现java.io.serializable接口。</p><p>如果结果映射的pojo中还包括了pojo，都要实现java.io.serializable接口。</p><h4 id="二级缓存的禁用"><a href="#二级缓存的禁用" class="headerlink" title="二级缓存的禁用"></a>二级缓存的禁用</h4><p>对于变化频率较高的sql，需要禁用二级缓存：在statement中设置useCache=false可以禁用当前select语句的二级缓存，即每次查询都会发出sql去查询，默认情况是true，即该sql使用二级缓存。</p><pre><code>&lt;select id=&quot;findOrderListResultMap&quot; resultMap=&quot;ordersUserMap&quot; useCache=&quot;false&quot;&gt;</code></pre><h4 id="刷新缓存"><a href="#刷新缓存" class="headerlink" title="刷新缓存"></a>刷新缓存</h4><p>将二级缓存进行刷新操作有两种方式:</p><ul><li><strong>如果sqlsession操作commit操作，对二级缓存进行刷新（全局清空）。</strong></li><li>设置statement的flushCache是否刷新缓存，默认值是true。</li></ul><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.41.06.png" alt=""></p><p>分别将中间更新用户信息的代码注释:发现两次打印用户信息的操作只向数据库中发送一次查询请求;去掉注释:三次操作向数据库中发送三次请求。</p><h4 id="二级缓存的应用场景"><a href="#二级缓存的应用场景" class="headerlink" title="二级缓存的应用场景"></a>二级缓存的应用场景</h4><p><strong>对查询频率高，变化频率低的数据建议使用二级缓存。</strong></p><p>对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。</p><p>实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。</p><h4 id="二级缓存的局限性"><a href="#二级缓存的局限性" class="headerlink" title="二级缓存的局限性"></a>二级缓存的局限性</h4><p>mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。</p><h3 id="MyBatis和ehcache缓存框架整合"><a href="#MyBatis和ehcache缓存框架整合" class="headerlink" title="MyBatis和ehcache缓存框架整合"></a>MyBatis和ehcache缓存框架整合</h3><h4 id="分布缓存"><a href="#分布缓存" class="headerlink" title="分布缓存"></a>分布缓存</h4><p><strong>将缓存数据进行分布式管理</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.45.41.png" alt=""></p><h4 id="MyBatis和ehcache整合思路"><a href="#MyBatis和ehcache整合思路" class="headerlink" title="MyBatis和ehcache整合思路"></a>MyBatis和ehcache整合思路</h4><p>通过MyBatis和ehcache框架进行整合，就可以把缓存数据的管理托管给ehcache。</p><p>首先我们看看MyBatis自己的二级缓存，它在自己内部提供了一个cache接口，我们只要实现了cache接口就可以把缓存数据灵活的管理起来。</p><p>要将MyBatis和ehcache整合，我们首先需要下载ehcache的jar包:</p><ul><li>ehcache-core.jar</li><li>mybatis-ehcache.jar</li></ul><p>然后需要添加一个ehcache的配置文件ehcache.xml:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.59.32.png" alt=""><br>然后在mapper.xml中添加ehcache的配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%8812.00.18.png" alt=""></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正如大多数持久层框架一样，MyBatis同样也提供了对查询数据的缓存支持。今后我们要学习的&lt;strong&gt;SpringMVC框架属于系统控制层，它也有它的缓存区域，对响应的jsp页面进行缓存；Spring属于系统业务层，它的缓存区域对业务数据进行缓存。&lt;/strong&gt;而它们三者的缓存区域都存在于用户要访问数据库的中间，&lt;strong&gt;当用户向数据库中发送查询请求时，系统会先在它们三者的缓存区域看是否有满足用户要求的查询数据，若有则直接从缓存区域返回信息；若没有则从数据库中进行查询。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="MyBatis" scheme="http://codinglembre.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis学习之使用resultMap实现高级映射</title>
    <link href="http://codinglembre.top/2018/10/02/MyBatis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BD%BF%E7%94%A8result%E5%AE%9E%E7%8E%B0%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84/"/>
    <id>http://codinglembre.top/2018/10/02/MyBatis学习之使用result实现高级映射/</id>
    <published>2018-10-02T09:52:47.000Z</published>
    <updated>2018-11-13T11:57:09.200Z</updated>
    
    <content type="html"><![CDATA[<p>对于数据库中对表的增删改查操作，我们知道增删改都涉及的是单表，而<strong>只有查询操作既可以设计到单表操作又可以涉及到多表操作，所以对于输入映射parameterType而言是没有所谓的高级映射的</strong>，也就是说高级映射只针对于输出映射(因为高级映射设计到多张表)。</p><p>前五篇文章我们都只实现了单表中的字段与pojo的映射，<strong>而本篇文章我们将来讲解如何实现多表与pojo之间的高级映射,分别有一对一映射、一对多映射和多对多映射。</strong>首先我们来看看用resultType完成一对一映射。</p><h3 id="多表间的一对一查询"><a href="#多表间的一对一查询" class="headerlink" title="多表间的一对一查询"></a>多表间的一对一查询</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>查询订单信息关联查询用户信息。这里我们知道一个用户可以有多张订单，而一张订单只能属于一个用户，所以<strong>用户与订单间的关系是一对多而订单与用户间的关系是一对一。所以这里我们将订单表作为主查询表来关联用户表，从而实现一对一映射。</strong></p><h4 id="创建表和数据"><a href="#创建表和数据" class="headerlink" title="创建表和数据"></a>创建表和数据</h4><pre><code>create table orders( id int primary key auto_increment,  user_id int , number int,  createtime datetime, note varchar(50));用户表在第一篇文章中我们已经创建。</code></pre><p>建立oders表和user表对应的pojo对象Orders.java和User.java。</p><pre><code>public class Orders{private Integer id;private Integer userId;private String number;private Date createtime;private String note;｝</code></pre><p>并建立相关的get和set方法，User.java我们之前已建立。</p><h4 id="sql查询语句"><a href="#sql查询语句" class="headerlink" title="sql查询语句"></a>sql查询语句</h4><p>对于查询语句，我们需要知道:1.先确定主查询表:订单表。2.再确定关联查询表:用户信息表。通过orders关联查询用户使用user_id一个外键，<strong><em>只能关联查询出一条用户记录，我们使用内连接</em></strong>。查询语句为:</p><pre><code>SELECT orders.*,user.username,user.sex FROM orders,user WHERE orders.user_id = user.id</code></pre><h4 id="使用resultType实现一对一映射"><a href="#使用resultType实现一对一映射" class="headerlink" title="使用resultType实现一对一映射"></a>使用resultType实现一对一映射</h4><p>通过查询语句，查询到的结果同时包括user表和orders表两张表的列，那么我们将结果映射到哪个pojo对象中呢？若映射到User.java，那查询结果中对应的orders表的字段一定会遗失；若映射到Orders.java，那查询结果中对应的user表的字段同样也会遗失。<strong>所以这里需要我们针对查询的结果重新创建一个映射的pojo对象OrderCustom.java:</strong><br><img src="https://i.imgur.com/i3uwu6K.png" alt=""><br>这里我们让OrderCustom.java继承自Order.java，<strong>这样我们就只需在OrderCustom.java中添加user表中的字段即可</strong>。因为MyBatis主要的重点在sql语句，所以我们完成配置和pojo对象的建立后主要的点就放在了sql语句上，所以接下来要定义写sql语句的mapper.xml和对数据库进行操作的mapper.java接口了<br>OrdersMapperCustom.xml文件内容如下:<br><img src="https://i.imgur.com/A4DcmBr.png" alt=""><br><strong>因为我们只关心输出映射，所以在xml中写sql查询语句时没有写parameterType属性</strong>，而resultType的属性值我之所以没有写全OrderCustom类的全限定性名，是因为我们在SqlMapperConfig.xml中进行了别名的配置。相应的OrdersMapperCustom.java接口内容如下:<br><img src="https://i.imgur.com/7EccSos.png" alt=""><br>然后在测试类中测试:<br><img src="https://i.imgur.com/Y8mu3T8.png" alt=""><br>便可完成这两张表的关联与我们自定义的pojo对象的映射。接下来我们看看如何使用resultMap完成。</p><h3 id="使用resultMap实现一对一映射"><a href="#使用resultMap实现一对一映射" class="headerlink" title="使用resultMap实现一对一映射"></a>使用resultMap实现一对一映射</h3><p>思路:将关联查询的信息映射到pojo中，如下:只需在Orders类中创建一个User属性，将关联查询的信息映射到User属性中。<br>这样我们便可以将查询的结果映射到Orders.java类中，而不用自己再自定义一个pojo了。</p><p>修改OrdersMapperCustom.xml中的内容(添加并使用resultMap标签),<strong>注意association标签的用法</strong><br><img src="https://i.imgur.com/Jj3AJZw.png" alt=""><br>然后在OrdersMapperCutom.java中添加方法:<br><img src="https://i.imgur.com/7EccSos.png" alt=""><br>最后测试:<br><img src="https://i.imgur.com/BXSuSe0.png" alt=""><br>发现查询结果已全部映射到Orders.java类中。</p><h3 id="比较resultType和resultMap完成一对一映射"><a href="#比较resultType和resultMap完成一对一映射" class="headerlink" title="比较resultType和resultMap完成一对一映射"></a>比较resultType和resultMap完成一对一映射</h3><ul><li>resultType：<strong>要自定义pojo 保证sql查询列和pojo的属性对应，这种方法相对较简单，所以应用广泛。</strong></li><li>resultMap：<strong>使用association完成一对一映射需要配置一个resultMap标签，过程有点复杂，如果要实现延迟加载(后面会讲)就只能用resultMap实现 ，如果为了方便对关联信息进行解析，也可以用association将关联信息映射到pojo中方便解析。</strong></li></ul><h3 id="多表间的一对多查询"><a href="#多表间的一对多查询" class="headerlink" title="多表间的一对多查询"></a>多表间的一对多查询</h3><h4 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h4><p>查询所有订单信息及订单下的订单明细信息。分析:<strong>一个订单可以可以有多个订单明细，而一个订单明细只属于一个订单，所以订单与订单明细间的关系为一对多。</strong></p><p>创建表和数据</p><pre><code>create table orderdetail( id int primary key auto_increment,  orders_id int,  items_id int, items_num int);//创建订单明细</code></pre><p>创建和订单明细表对应的pojo对象:</p><pre><code>public class Orderdetail{    private Integer id;       private Integer ordersId;       private Integer itemsId;       private Integer itemsNum;}</code></pre><p>并创建相关的set和get方法。</p><h4 id="sql查询语句-1"><a href="#sql查询语句-1" class="headerlink" title="sql查询语句"></a>sql查询语句</h4><p>1.先确定主查询表:订单表。<br>2.再确定关联查询表:用户表加订单明细表。通过orderdetail关联查询订单使用orders_id一个外键，只能关联查询出一条订单记录，我们使用内连接。查询语句为:</p><pre><code>SELECT orders.*,user.username,user.sex ,orderdetail.id orderdetail_id,orderdetail.items_num,orderdetail.items_idFROM orders,user,orderdetail WHERE orders.user_id = user.id AND orders.id=orderdetail.orders_id</code></pre><h4 id="使用resultMap进行一对多映射"><a href="#使用resultMap进行一对多映射" class="headerlink" title="使用resultMap进行一对多映射"></a>使用resultMap进行一对多映射</h4><p>思路:<strong>resultMap 提供collection完成关联信息映射到集合对象中。在orders类中创建集合属性</strong>：<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%885.14.55.png" alt=""></p><p>然后修改OrdersMapperCustom.xml中的信息:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%885.32.43.png" alt=""><br>并在其中添加resultMap的定义:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%885.32.50.png" alt=""><br>最后进行测试:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%885.33.31.png" alt=""></p><h3 id="延迟加载-只能用resultMap"><a href="#延迟加载-只能用resultMap" class="headerlink" title="延迟加载(只能用resultMap)"></a>延迟加载(只能用resultMap)</h3><h4 id="使用延迟加载的意义"><a href="#使用延迟加载的意义" class="headerlink" title="使用延迟加载的意义"></a>使用延迟加载的意义</h4><p>在进行数据查询时，<strong>为了提高数据库查询性能，尽量使用单表查询，因为单表查询比多表关联查询速度要快。</strong><br><strong>如果查询单表就可以满足需求，一开始先查询单表，当需要关联信息时，再关联查询，当需要关联信息再查询这个叫延迟加载。</strong><br>mybatis中resultMap提供延迟加载功能，通过resultMap配置延迟加载,但需要在MyBatis的配置文件中进行相关配置，如下<br><img src="https://i.imgur.com/E3ZML6z.png" alt=""><br>然后在SqlMapperConfig.xml中添加如下配置信息:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%887.39.21.png" alt=""></p><h3 id="一对一延迟加载的实现"><a href="#一对一延迟加载的实现" class="headerlink" title="一对一延迟加载的实现"></a>一对一延迟加载的实现</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>需求:查询订单及用户的信息，一对一查询。</p><p>刚开始我们只查询订单信息。而当需要用户信息时调用Orders类中的getUser()方法执行延迟加载 ，向数据库发出sql。代码实现如下:<br>在OrderMapperCustom.xml文件中添加如下信息:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%887.41.51.png" alt=""><br>并定义resultMap标签:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%887.42.51.png" alt=""><br>最后是测试代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%887.44.14.png" alt=""></p><h4 id="一对多延迟加载的实现"><a href="#一对多延迟加载的实现" class="headerlink" title="一对多延迟加载的实现"></a>一对多延迟加载的实现</h4><p>一对多延迟加载的方法同一对一延迟加载，在collection标签中配置select内容。</p><h3 id="resultType、resultMap、延迟加载使用场景总结"><a href="#resultType、resultMap、延迟加载使用场景总结" class="headerlink" title="resultType、resultMap、延迟加载使用场景总结"></a>resultType、resultMap、延迟加载使用场景总结</h3><p>延迟加载:<br>延迟加载实现的方法多种多样，在只查询单表就可以满足需求，为了提高数据库查询性能使用延迟加载，再查询关联信息。</p><p>mybatis提供延迟加载的功能用于service层。</p><p>resultType:作用：将查询结果按照sql列名pojo属性名一致性映射到pojo中。</p><p>场合：常见一些明细记录的展示，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。</p><p>resultMap:使用association和collection完成一对一和一对多高级映射。</p><p>association:作用:将关联查询信息映射到一个pojo类中。</p><p>场合:为了方便获取关联信息可以使用association将关联订单映射为pojo，比如:查询订单及关联用户信息。</p><p>collection:作用:将关联查询信息映射到一个list集合中。</p><p>场合:为了方便获取关联信息可以使用collection将关联信息映射到list集合中，比如:查询用户权限范围模块和功能，可使用collection将模块和功能列表映射到list中</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于数据库中对表的增删改查操作，我们知道增删改都涉及的是单表，而&lt;strong&gt;只有查询操作既可以设计到单表操作又可以涉及到多表操作，所以对于输入映射parameterType而言是没有所谓的高级映射的&lt;/strong&gt;，也就是说高级映射只针对于输出映射(因为高级映射设计到
      
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="MyBatis" scheme="http://codinglembre.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis之动态sql的编写</title>
    <link href="http://codinglembre.top/2018/10/02/MyBatis%E4%B9%8B%E5%8A%A8%E6%80%81sql%E7%9A%84%E7%BC%96%E5%86%99/"/>
    <id>http://codinglembre.top/2018/10/02/MyBatis之动态sql的编写/</id>
    <published>2018-10-02T08:58:20.000Z</published>
    <updated>2018-10-12T15:44:21.992Z</updated>
    
    <content type="html"><![CDATA[<p>我们需要知道的是，使用mybatis重点是对sql的灵活解析和处理。在原先的UserMappser.xml中，我们这样查询表中满足条件的记录 :</p><pre><code>&lt;select id=&quot;findUserList&quot; parameterType=&quot;userQueryVo&quot; resultType=&quot;user&quot;&gt;       select id,username,birthday from user where username like &apos;${value}&apos;&lt;/select&gt;</code></pre><p>上述语句在表中查询满足username条件的记录，这样写查询语句有一个弊端，就是该语句只能通过username查询数据库。当我们在多条件中查询时，如果不需要username条件而是需要其它多个查询条件时，那UserMapper.xml文件中的这个查询条件就没用了。</p><p><strong>需求:将自定义查询条件查询用户列表和查询用户列表总记录数改为动态sql</strong>。需要使用if标签和where标签。</p><a id="more"></a><h3 id="if和where标签"><a href="#if和where标签" class="headerlink" title="if和where标签"></a>if和where标签</h3><p>使用if标签和where标签在UserMapper.xml中添加如下内容:<br>修改自定义查询条件查询用户列表代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%888.14.15.png" alt=""><br>修改自定义查询条件查询用户列表总记录数代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%888.19.54.png" alt=""><br>发现<where>和<if>在上述两个查询语句中重复的代码出现了两次，那这里我们是否可以把相同的sql片段拿出来单独写在一个sql片段中然后再在不同的查询语句中应用呢？答案是肯定的,看下面的sql片段。</if></where></p><h3 id="sql片段的抽取"><a href="#sql片段的抽取" class="headerlink" title="sql片段的抽取"></a>sql片段的抽取</h3><p><strong>通过sql片段可以将通用的sql语句抽取出来，单独定义，在其它的statement中可以引用sql片段。</strong>其中通用的sql语句，一般用在:where条件、查询列。</p><h4 id="定义sql片段"><a href="#定义sql片段" class="headerlink" title="定义sql片段"></a>定义sql片段</h4><p>在UserMapper.xml中添加<sql>标签代表sql片段:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%889.25.19.png" alt=""></sql></p><h4 id="使用sql片段"><a href="#使用sql片段" class="headerlink" title="使用sql片段"></a>使用sql片段</h4><p>使用<include>标签对上面定义的sql片段加以引用:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%889.27.20.png" alt=""></include></p><p>测试类代码不变，这样我们便完成了对sql片段的引用。</p><p>有时候我们希望查询语句是这样select id,username,birthday from user where username like ‘%codingXiaxw%’ and id in (1,2)，那我们又应该在sql片段中如何添加代码呢？这时候需要用到<foreach>标签。</foreach></p><h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><p><strong>在statement通过foreach遍历parameterType中的集合类型。首先我们需要在UserQueryVo中定义Listids属性:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%889.36.44.png" alt=""><br>并添加相应的get和set方法。</p><p>然后我们在UserMapper.xml中使用foreach修改where语句,使用foreache遍历list:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%889.38.18.png" alt=""><br>测试代码<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%889.39.11.png" alt=""></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们需要知道的是，使用mybatis重点是对sql的灵活解析和处理。在原先的UserMappser.xml中，我们这样查询表中满足条件的记录 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;select id=&amp;quot;findUserList&amp;quot; parameterType=&amp;quot;userQueryVo&amp;quot; resultType=&amp;quot;user&amp;quot;&amp;gt;
       select id,username,birthday from user where username like &amp;apos;${value}&amp;apos;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述语句在表中查询满足username条件的记录，这样写查询语句有一个弊端，就是该语句只能通过username查询数据库。当我们在多条件中查询时，如果不需要username条件而是需要其它多个查询条件时，那UserMapper.xml文件中的这个查询条件就没用了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求:将自定义查询条件查询用户列表和查询用户列表总记录数改为动态sql&lt;/strong&gt;。需要使用if标签和where标签。&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="MyBatis" scheme="http://codinglembre.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Java封装继承多态和OOP设计原则</title>
    <link href="http://codinglembre.top/2018/10/02/Java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    <id>http://codinglembre.top/2018/10/02/Java三大特性封装继承多态/</id>
    <published>2018-10-02T08:03:41.000Z</published>
    <updated>2018-11-05T02:55:37.744Z</updated>
    
    <content type="html"><![CDATA[<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="封装的定义"><a href="#封装的定义" class="headerlink" title="封装的定义"></a>封装的定义</h4><ul><li>首先是抽象，把事物抽象成一个类，其次才是封装，将事物拥有的属性和动作隐藏起来，只保留特定的方法与外界联系</li></ul><h4 id="为什么要封装"><a href="#为什么要封装" class="headerlink" title="为什么要封装"></a>为什么要封装</h4><ul><li><strong>实现了对属性和实现细节的封装，用户不用去关心内部的实现；使用者只能通过规定的方法访问数据，可以方便的加入存取控制语句，限制了不合理的操作；当内部逻辑发生变化时，外部访问不用修改。</strong></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Java的类可以分为三类：</p><pre><code>- 普通类：使用class定义，没有抽象方法- 抽象类：使用abstract class定义，可以有也可以没有抽象方法- 接口：使用inerface定义，只能有抽象方法</code></pre><h4 id="继承到底做了什么-扩展和覆盖"><a href="#继承到底做了什么-扩展和覆盖" class="headerlink" title="继承到底做了什么(扩展和覆盖)"></a>继承到底做了什么(扩展和覆盖)</h4><pre><code>- **子类继承除构造函数的一切东西。(私有属性能被继承的,但是子类无法访问父类的私有属性或方法,用反射的话，私有属性和方法都是可以访问的)**- **子类可以添加自己的方法和属性，即对父类进行扩展**- **子类可以重新定义父类的方法，即多态里面的覆盖，后面会详述**</code></pre><p>关于构造函数：</p><pre><code>- **构造函数不能被继承，子类可以通过super()显式调用父类的构造函数**- **创建子类时，编译器会自动调用父类的 无参构造函数**- **如果父类没有定义无参构造函数，子类必须在构造函数的第一行代码使用super()显示调用**</code></pre><h4 id="为什么要有继承"><a href="#为什么要有继承" class="headerlink" title="为什么要有继承"></a>为什么要有继承</h4><p><strong>代码重用是一点，最重要的还是所谓想上转型，即父类的引用变量可以指向子类对象</strong>，这是Java面向对象最重要特性多态的基础。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><pre><code>- **多态可以分为两种类型：编译时多态（方法的重载）和运行时多态（继承时方法的重写），编译时多态很好理解，后述内容针对运行时多态**- 运行时多态依赖于继承、重写和向上转型</code></pre><p>首先需要知道方法的唯一性标识即什么是相同/不同的方法：</p><pre><code>- 其中只有**方法名和参数**是唯一性标识，意即只要方法名和参数相同那他们就是相同的方法- **所谓参数相同，是指参数的个数，类型，顺序一致，其中任何一项不同都是不同的方法**</code></pre><p>何谓重载：</p><pre><code>- **重载是指一个类里面（包括父类的方法）存在方法名相同，但是参数不一样的方法，参数不一样可以是不同的参数个数、类型或顺序**- 如果仅仅是修饰符、返回值、throw的异常 不同，那这是2个相同的方法，编译都通不过，更不要说重载了</code></pre><p>何谓覆盖Override：</p><pre><code>- 覆盖描述存在继承关系时子类的一种行为- **子类中存在和父类相同的方法即为覆盖，何谓相同方法请牢记前面的描述，方法名和参数相同，包括参数个数、类型、顺序**</code></pre><p>覆盖/重写的规则：（两同两小一大原则）</p><pre><code>-子类不能覆盖父类private的方法，private对子类不可见，如果子类定义了一个和父类private方法相同的方法，实为新增方法- 重写方法的修饰符一定要大于被重写方法的修饰符(public &gt; protected &gt; default &gt; private)- 重写抛出的异常需与父类相同或是父类异常的子类，或者重写方法干脆不写throws重写方法的返回值必须与被重写方法一致，否则编译报错- 静态方法不能被重写为非静态方法，否则编译出错</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>java中变量不能重写，可以按如下口诀记忆：</p><pre><code>- **变量多态看左边** - **方法多态看右边**- 静态多态看左边。</code></pre><p><strong>多态的好处:降低代码的耦合度</strong></p><h3 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h3><p>面向对象设计原则是我们用于评价一个设计模式的使用效果的重要标准之一。</p><pre><code>- 单一职责原则    定义：**一个类只负责一个领域的相应职责 **  - 开闭原则  定义：软件实体应对扩展开放，而对修改关闭- 里氏替换原则  定义：所有引用基类的对象能够透明的使用其子类的对象- 依赖倒转原则  定义：抽象不应该依赖于细节，细节依赖于抽象- 接口隔离原则  定义：**使用多个专门的接口，而不是使用单一总接口**- 合成复用原则  定义：尽量使用对象组合，而不是继承来达到复合目的- 迪米特法则  定义：一个软件实体应当尽可能少的与其它实体发生相互作用</code></pre><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h3&gt;&lt;h4 id=&quot;封装的定义&quot;&gt;&lt;a href=&quot;#封装的定义&quot; class=&quot;headerlink&quot; title=&quot;封装的定义&quot;&gt;&lt;/a&gt;封装的定
      
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="JavaSE" scheme="http://codinglembre.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis学习之输入与输出映射</title>
    <link href="http://codinglembre.top/2018/10/02/MyBatis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E6%98%A0%E5%B0%84/"/>
    <id>http://codinglembre.top/2018/10/02/MyBatis学习之输入与输出映射/</id>
    <published>2018-10-02T06:51:50.000Z</published>
    <updated>2018-10-02T13:44:32.351Z</updated>
    
    <content type="html"><![CDATA[<p>在MyBatis中，我们通过parameterType完成输入映射(指<strong>将值映射到sql语句的占位符中，值的类型与dao层响应方法的参数类型一致</strong>)，通过resultType完成输出映射(<strong>从数据库中输出，通过dao层的方法查询到的数据输出到pojo对象中</strong>)。 注意输入与输出都是相对于数据库的。接下来我们先谈谈输入映射。</p><a id="more"></a><h3 id="输入映射parameterType"><a href="#输入映射parameterType" class="headerlink" title="输入映射parameterType"></a>输入映射parameterType</h3><p>通过parameterType传入简单类型或对象，我们之前讲过了，接下来我们要讲的是<strong>parameterType传递pojo包装对象。</strong>可以定义pojo包装类型扩展mapper接口输入参数的内容。</p><p>看下我们的需求:定义查询条件查询用户信息，需要向statement输入查询条件，查询条件可以有user信息、商品信息等等。<br>首先我们在domain包下创建UserCustom类并继承User：<br><img src="http://od2xrf8gr.bkt.clouddn.com/ssss.png" alt=""><br>UserCustom类用于对User属性进行扩展(例如User中只有用户信息，而我们可以在UserCustom中加入商品信息)，然后再创建User的包装类UserQueryVo.java:<br><img src="http://od2xrf8gr.bkt.clouddn.com/ssssss.png" alt=""><br>UserMapper.xml中添加如下配置信息:<br><img src="http://od2xrf8gr.bkt.clouddn.com/sjjj.png" alt=""><br>UserMapper.java中添加方法:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.41.10.png" alt=""><br>然后便可以进行测试:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.41.34.png" alt=""> </p><blockquote><p>可能出现的异常:如果在parameterType中指定了错误的属性名时会出现如下异常:</p></blockquote><pre><code>org.apache.ibatis.exceptions.PersistenceException: ### Error querying database.  Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;userCusto&apos; in &apos;class cn.itcast.mybatis.po.UserQueryVo&apos;### Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;userCusto&apos; in &apos;class cn.itcast.mybatis.po.UserQueryVo&apos;</code></pre><h3 id="输出映射-resultType和resultMap"><a href="#输出映射-resultType和resultMap" class="headerlink" title="输出映射(resultType和resultMap)"></a>输出映射(resultType和resultMap)</h3><p><strong>输出映射有resultType和resultMap,他们都是指定输出结果的类型(pojo、简单类型、hashmap…)，并将sql查询结果映射为java对象 。</strong></p><h4 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h4><p>借用上述parameter传递包装pojo对象的知识(不用parameter传递包装pojo对象的知识也行)，我们来谈谈用resultType输出简单类型。UserMapper.xml文件中添加如下配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.51.42.png" alt=""><br>然后在UserMapper.java中添加如下方法:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.52.30.png" alt=""><br>测试:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.53.12.png" alt=""><br><strong>使用resultType时我们应该注意:sql查询的列名要和resultType指定pojo的属性名相同，</strong>指定相同属性方可映射成功，如果sql查询的列名要和resultType指定pojo的属性名全部不相同(或是部分不相同)，则映射到pojo对象中的对应属性为null。例如有时候我们不需要查询select * from user where id = ?而是select username,address _address where id = ? <strong>此时我们给查询的address列名给了一个别名_address，这样我们通过查询表中address的数据然后在将它映射到User对象时，该对象的address属性就为null，即没将从表中查询到的address数据映射到user对象的address属性中</strong></p><h3 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h3><p>使用resultMap需要在UserMapper.xml中进行配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%887.06.02.png" alt=""><br>然后在UserMapper.xml中使用它:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%887.06.23.png" alt=""><br>UserMapper.java文件中:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%887.08.19.png" alt=""><br>测试类代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%887.08.51.png" alt=""></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在MyBatis中，我们通过parameterType完成输入映射(指&lt;strong&gt;将值映射到sql语句的占位符中，值的类型与dao层响应方法的参数类型一致&lt;/strong&gt;)，通过resultType完成输出映射(&lt;strong&gt;从数据库中输出，通过dao层的方法查询到的数据输出到pojo对象中&lt;/strong&gt;)。 注意输入与输出都是相对于数据库的。接下来我们先谈谈输入映射。&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="MyBatis" scheme="http://codinglembre.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis之优化MyBatis配置文件中的配置</title>
    <link href="http://codinglembre.top/2018/10/02/MyBatis%E4%B9%8B%E4%BC%98%E5%8C%96MyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://codinglembre.top/2018/10/02/MyBatis之优化MyBatis配置文件中的配置/</id>
    <published>2018-10-02T02:35:50.000Z</published>
    <updated>2018-11-13T01:29:56.552Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MyBatis配置文件属性了解"><a href="#MyBatis配置文件属性了解" class="headerlink" title="MyBatis配置文件属性了解"></a>MyBatis配置文件属性了解</h3><p>MyBatis配置文件很重要，首先我们来看看MyBatis配置文件中的内容和顺序:</p><pre><code>&lt;properties&gt;(属性)&lt;setting&gt;(全局配置参数)&lt;typeAliases&gt;(类型别名)&lt;typeHandlers&gt;(类型处理器)&lt;objectFactory&gt;(对象工厂)&lt;plugins&gt;(插件)&lt;environments&gt;(环境集合属性对象)    &lt;environment&gt;(环境子属性对象)        &lt;transactionManager&gt;(事务管理)        &lt;dataSource&gt;(数据源)&lt;mappers&gt;(映射器)</code></pre><h3 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a><properties>属性定义</properties></h3><p>可以把一些通用的属性值配置在属性文件中，加载到mybatis运行环境内。例如创建db.properties文件，然后在SqlMapperConfig.xml中进行配置。db.properties文件内容如下:</p><p><img src="http://od2xrf8gr.bkt.clouddn.com/db.pro.png" alt=""></p><p>然后在SqlMapperConfig.xml中进行配置:</p><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%885.59.18.png" alt=""></p><p>然后在<environments>标签中用${}符号做如下修改:</environments></p><p><img src="http://od2xrf8gr.bkt.clouddn.com/nima.png" alt=""></p><p>注意:Mybatis将按照下面的顺序来加载属性</p><ul><li>1.在properties标签之间定义的属性首先被读取。</li><li>2.然后会读取properties标签内部resource或url的属性，它会覆盖已读取的同名属性。</li><li>3.最后读取parameterType(即insert标签或是update标签或是…)传递的属性，它会覆盖已读取的同名属性。</li></ul><p><strong>所以我们建议使用properties标签时，不要在properties标签之间定义属性，只引用在.properties文件中定义的属性，并且.properties文件中定义的key值要有一些特殊的规则。</strong>例如我上述定义key值时前面都加了jdbc.的前缀</p><h3 id="lt-settings-gt-全局参数配置"><a href="#lt-settings-gt-全局参数配置" class="headerlink" title="&lt;settings&gt;全局参数配置"></a>&lt;settings&gt;全局参数配置</h3><p>mybatis运行时可以调整一些全局参数(相当于软件的运行参数)。根据使用需求进行参数配置。但是要注意:小心配置，配置参数会影响mybatis的执行。</p><p><strong>ibatis的全局配置参数中包括很多的性能参数(最大线程数、最大等待时间…)，通过调整这些性能参数使ibatis达到高性能的运行，而mybatis没有这些性能参数，由mybatis自动调节。</strong></p><h3 id="lt-typeAliases-gt-属性"><a href="#lt-typeAliases-gt-属性" class="headerlink" title="&lt;typeAliases&gt;属性"></a>&lt;typeAliases&gt;属性</h3><p>可以将parameterType、resultType中指定的类型通过别名引用。MyBatis提供了很多的别名如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%88%AB%E5%90%8D.png" alt=""><br>这里我们采用自定义的别名，在SqlMapperConfig.xml中进行如下配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/hahaha.png" alt=""><br>里面包括定义单个别名和批量别名定义(即一次性定义一个包下所有.java文件的别名)。</p><p><strong>定义别名后这样我们在parameterType和resultType中使用时就不用再繁琐的指定类的全限定类名了，像下面这样使用即可</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/dadada.png" alt=""></p><h3 id="lt-typeHandlers-gt-属性"><a href="#lt-typeHandlers-gt-属性" class="headerlink" title="&lt;typeHandlers&gt;属性"></a>&lt;typeHandlers&gt;属性</h3><p>类型处理器将java类型和jdbc类型进行映射，mybatis提供了很多类型处理器，一般情况下够用了。</p><h3 id="lt-mapper-gt-映射器属性"><a href="#lt-mapper-gt-映射器属性" class="headerlink" title="&lt;mapper&gt;映射器属性"></a>&lt;mapper&gt;映射器属性</h3><p>之前我们在配置文件中使用的<mapper>标签内容为:&lt;mapper resource=“mapper/UserMapper.xml”/&gt;，接下来我要讲的是另一种在配置文件中映射mapper动态代理的方法。在配置文件中这样配置<mapper class="“mapper.UserMapper”/"><strong>这样的要求需要保证UserMapper.xml文件和UserMapper.java在同一个包下且.xml文件和.java文件名要同名。</strong></mapper></mapper></p><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.12.42.png" alt=""></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MyBatis配置文件属性了解&quot;&gt;&lt;a href=&quot;#MyBatis配置文件属性了解&quot; class=&quot;headerlink&quot; title=&quot;MyBatis配置文件属性了解&quot;&gt;&lt;/a&gt;MyBatis配置文件属性了解&lt;/h3&gt;&lt;p&gt;MyBatis配置文件很重要，首先我
      
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="MyBatis" scheme="http://codinglembre.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis之Mapper动态代理开发</title>
    <link href="http://codinglembre.top/2018/10/02/MyBatis%E4%B9%8BMapper%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%BC%80%E5%8F%91/"/>
    <id>http://codinglembre.top/2018/10/02/MyBatis之Mapper动态代理开发/</id>
    <published>2018-10-02T01:58:00.000Z</published>
    <updated>2018-11-13T01:20:16.773Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SqlSession的使用范围"><a href="#SqlSession的使用范围" class="headerlink" title="SqlSession的使用范围"></a>SqlSession的使用范围</h3><p>1.SqlSessionFactoryBuilder<br>SqlSessionFactoryBuilder是以工具类的方式来使用:需要创建sqlSessionFactory时就new一个 SqlSessionFactoryBuilder</p><p>2.sqlSessionFactory<br>正常开发时，以单例方式管理sqlSessionFactory，整个系统运行过程中sqlSessionFactory只有一个实例，<strong>将来和Spring整合后由Spring以单例方式管理sqlSessionFactory</strong></p><p>3.SqlSession<br><strong>SqlSession是一个面向用户(程序员)的接口，程序员调用 SqlSession接口的方法进行操作数据库。</strong>那么我们会思考:SqlSession能否以单例方式使用？？？由于 SqlSession是线程不安全的，所以 SqlSession最佳应用范围在方法体内。也就是说在方法体内定义局部变量 SqlSession的对象来使用。</p><h3 id="MyBatis开发DAO的方式"><a href="#MyBatis开发DAO的方式" class="headerlink" title="MyBatis开发DAO的方式:"></a>MyBatis开发DAO的方式:</h3><p>我们先来看看MyBatis原始开发dao的开发方式，发现原始开发的问题，然后再来看看MyBatis使用mapper动态代理开发dao的方式(也是MyBatis目前使用的开发dao的方式)。</p><h4 id="原始dao的开发方式"><a href="#原始dao的开发方式" class="headerlink" title="原始dao的开发方式"></a>原始dao的开发方式</h4><p>程序员需要编写dao接口和dao实现类<br><a href="http://od2xrf8gr.bkt.clouddn.com/dao%E6%8E%A5%E5%8F%A3.png" target="_blank" rel="noopener"></a><br><a href="http://od2xrf8gr.bkt.clouddn.com/dao%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" target="_blank" rel="noopener"></a><br>然后就能在测试类中使用。测试类代码如下:<br><a href="http://od2xrf8gr.bkt.clouddn.com/%E6%B5%8B%E8%AF%95222.png" target="_blank" rel="noopener"></a></p><ul><li>1.<strong>dao的实现类中存在重复代码，整个mybatis操作的过程代码模板重复(都是先创建sqlSession、调用sqlSession的方法、关闭sqlSession)。</strong></li><li>2.<strong>dao的实现类中存在硬编码，调用sqlSession方法时将statement的id硬编码。</strong></li></ul><h4 id="mapper动态代理的方式"><a href="#mapper动态代理的方式" class="headerlink" title="mapper动态代理的方式"></a>mapper动态代理的方式</h4><p>程序员只需要写dao接口，dao接口实现对象由mybatis自动生成代理对象。因为本身dao在三层架构中就是一个通用的接口。<br>1.mapper开发规范：<br>要想让mybatis自动创建dao接口实现类的代理对象，必须要遵循一些规则:</p><ul><li><strong>mapper.xml中 namespace指定为mapper接口的全限定名。此步骤的目的:将mapper.xml和mapper.java关联。</strong></li><li>mapper.xml中<strong>statement的id就是mapper.java中的方法名。即对应相同</strong></li><li>mapper.xml中<strong>statement的parameterType和mapper.java中方法输入参数一致。即参数一致</strong></li><li><strong>mapper.xml中statement的resultType和mapper.java中方法的返回值类型一致。即返回值一致</strong></li></ul><p>2.mapper.xml(映射文件)</p><p><img src="http://od2xrf8gr.bkt.clouddn.com/namespace.png" alt=""></p><p>3.mapper.java接口</p><pre><code>public interface UserMapper{};</code></pre><p>4.将mapper.xml在SqlMapConfing.xml中进行注册</p><pre><code>&lt;mappers&gt;     &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><p>5.mapper接口返回单个对象和集合对象<br>在UserMapper.java中添加如下两个方法:</p><pre><code>User findUserById(int id) throws Exception ;List&lt;User&gt; findUserByName (String username) throws Exception;</code></pre><p><strong>对于UserMapper.xml，不管你查询的记录是单条还是多条，在statement(即UserMapper.xml)中的resultType都定义一致，都是单条记录映射的pojo类型</strong></p><p><strong>而对于UserMapper.java接口方法中的返回值，如果返回的是单个对象，返回值类型是pojo，生成的代理对象内部会自动通过selectOne获取记录，如果返回值类型是多条对象，生成的代理对象内部会自动通过selectList获取记录。</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/ceshissss.png" alt=""></p><p><strong>UserMapper userMapper = sqlsession.getMapper(UserMapper.class)</strong></p><h3 id="注意-mapper动态代理开发的问题"><a href="#注意-mapper动态代理开发的问题" class="headerlink" title="注意:mapper动态代理开发的问题"></a>注意:mapper动态代理开发的问题</h3><ul><li>返回值的问题:如果方法(即UserMapper.java接口中的方法)调用的statement中返回是多条记录，而mapper.java方法的返回值为pojo，此时代理对象通过selectOne调用，但由于返回的是多条记录所以会报错:Expected one result (for null ) to be returned by selectOne() but found 4;</li><li>输入参数的问题:使用mapper代理的方式开发，mapper接口方法的输入参数只有一个，可扩展性是否很差?答:可扩展性没有问题，因为dao层就是通用的，可以通过扩展pojo(定义pojo包装类型，后面第四篇文章–MyBatis输入输出映射会讲扩展pojo的知识)来将不同的参数(可以是pojo也可以是简单类型)传入进去</li></ul><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;SqlSession的使用范围&quot;&gt;&lt;a href=&quot;#SqlSession的使用范围&quot; class=&quot;headerlink&quot; title=&quot;SqlSession的使用范围&quot;&gt;&lt;/a&gt;SqlSession的使用范围&lt;/h3&gt;&lt;p&gt;1.SqlSessionFactor
      
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="MyBatis" scheme="http://codinglembre.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis学习之快速入门</title>
    <link href="http://codinglembre.top/2018/10/02/MyBatis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://codinglembre.top/2018/10/02/MyBatis学习之快速入门/</id>
    <published>2018-10-01T17:09:51.000Z</published>
    <updated>2018-11-07T00:39:11.989Z</updated>
    
    <content type="html"><![CDATA[<p>在学习框架之前，我们先弄明白为什么要学框架。首先个人认为<strong>简化开发并不是采用框架唯一的目的，更重要的是规范，不用框架时写出来的代码千奇百怪，各种凌乱，有框架的约束更容易制定规范，而简化的任务是基于框架再做一些有针对性的封装时该做的事。</strong> 而因为框架内部执行的复杂带来的性能损耗是要配合其他手段来优化的，比如连接池、缓存之类的，而这些手段是很容易通过框架间的整合融入进来的，如果你只用纯jdbc， 就比较困难，自己要做很多事情，还很难做好。框架整合封装完毕后，再来测试性能问题，单纯的执行一条SQL语句来判断效率是没有必要的，没什么实际价值，更多的应该是去看在并发的情况下、不同的业务场景、针对业务有效的优化后，再来看整个工程所有功能模块的平均效率，你才会做出合理的判断。项目代码<a href="https://github.com/Lembre/FirstMyBatis" target="_blank" rel="noopener"></a></p><a id="more"></a><h3 id="MyBatis框架的引入"><a href="#MyBatis框架的引入" class="headerlink" title="MyBatis框架的引入"></a>MyBatis框架的引入</h3><p>我们来看看传统的编程方式中使用jdbc的问题:</p><ul><li>数据库连接频繁的创建和关闭，缺点:浪费数据库的资源，影响操作效率。解决方法:<strong>使用数据库连接池如c3p0.</strong></li><li>sql语句是硬编码(不利用系统维护)，如果需求变更需要修改sql，这时候就需要修改java代码，然后需要重新编译，系统不易维护。解决方法:将sql语句统一配置在文件中。这样以后修改sql时就不需要修改java代码了。</li><li>我们通过preparedStatement对象向占位符设置参数，存在硬编码(参数位置、参数)问题，系统不易维护。解决方法:<strong>将sql中的占位符及对应的参数类型配置在配置文件中，能够自动输入的映射。</strong></li><li>遍历查询结果集存在硬编码(列名)。解决方法:<strong>自动进行sql查询结果向java对象的映射(输出映射)</strong></li></ul><h3 id="MyBatis的优点"><a href="#MyBatis的优点" class="headerlink" title="MyBatis的优点"></a>MyBatis的优点</h3><p><strong>MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身</strong>，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。<br>MyBatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。</p><h3 id="MyBatis架构"><a href="#MyBatis架构" class="headerlink" title="MyBatis架构"></a>MyBatis架构</h3><p>如下图:<br><img src="http://od2xrf8gr.bkt.clouddn.com/mybatis.png" alt=""></p><h3 id="MyBatis快速入门"><a href="#MyBatis快速入门" class="headerlink" title="MyBatis快速入门"></a>MyBatis快速入门</h3><ul><li>编写SqlMapConfig.xml</li><li>编写mapper.xml(每个字段定义一个statement)</li><li>编程通过配置文件创建SqlSessionFactory</li><li>通过SqlSessionFactory获取SqlSession对象。</li><li>通过SqlSession操作数据库。(如果执行添加、更新、删除需要调用SqlSession.commit())</li><li>SqlSesion使用完成要关闭。</li></ul><h4 id="准备开发环境"><a href="#准备开发环境" class="headerlink" title="准备开发环境"></a>准备开发环境</h4><p>1.创建测试项目，普通java项目或是web项目都可<br>2.导入jar包:mybatis-3.1.1.jar(低于这个版本的jar包需要导入很多依赖包)和mysql-connection-java<br>3.创建数据库和相应的表,SQL脚本如下:</p><pre><code>create database mybatis;use mybatis;create table user(  id int primary key auto_increment,  username varchar(50),   birthday date,  sex varchar(20),  address varchar(50));insert into user values(null,&apos;yzh&apos;,&apos;1996-09-14&apos;,&apos;male&apos;,null);insert into user values(null,&apos;pcl&apos;,&apos;1997-08-26&apos;,&apos;female&apos;,null);</code></pre><p>到此，环境配置就告一段落。</p><h4 id="使用MyBatis查询表中数据-通过id查询"><a href="#使用MyBatis查询表中数据-通过id查询" class="headerlink" title="使用MyBatis查询表中数据(通过id查询)"></a>使用MyBatis查询表中数据(通过id查询)</h4><p>1.添加Mybatis的配置文件SqlMapConfig.xml(名字可以随便起)</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!--和spring整合后，environments配置将废除--&gt;&lt;environments default=&quot;development&quot;&gt;&lt;environment id=&quot;development&quot;&gt;    &lt;!--使用JDBC事务管理--&gt;  &lt;transactionManager type=&quot;JDBC&quot;&gt;    &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;  &lt;/transactionManager&gt;    &lt;!--数据库连接池--&gt;  &lt;dataSource type=&quot;POOLED&quot;&gt;    &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;  &lt;/dataSource&gt;&lt;/environment&gt;&lt;/environments&gt;&lt;/configuration&gt;</code></pre><p>2.定义表所需要的实体类User.java<br>3.定义操作user表的sql映射文件User.xml<br>这里我们没将文件命名为userMapper.xml，后面我们会改。<br>文件内容如下:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;Message&quot;&gt;&lt;!--根据id查询用户信息--&gt;&lt;!--id为唯一标识#{}表示一个占位符，如果#{}传入的是简单类型的参数，那么他里面的名称随意，paramterType:输入参数的类型，通过占位符#{}接受paramterType传入的参数值resultType：输出结果参数--&gt;&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;entity.User&quot;&gt;    SELECT * from user WHERE id = #{id}&lt;/select&gt;&lt;/mapper&gt;</code></pre><p><strong>在User.xml中写SQL语句，在参数处使用占位符#{}，应该注意的是大括号{}中传入的数据应该与User.java中的属性对应，文件中各个属性的解释见图中注释处。</strong></p><p>4.在SqlMapConfig文件中注册User.xml文件<br><strong>在SqlMapConfig.xml中添加一个<mappers></mappers>字段，并在里面传入User.xml文件路径。</strong></p><p>5.接下来我们便可以借助上面MyBatis架构图来编写测试类了</p><pre><code>public class FirstMyBatis {private SqlSessionFactory sqlSqlSessFactory;//创建工厂@Beforepublic void init() throws IOException {    //配置文件    String resource = &quot;Configuration.xml&quot;;    //加载配置文件到输入流中    //InputStream inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);    InputStream inputStream = Resources.getResourceAsStream(resource);    //创建会话工厂    sqlSqlSessFactory = new SqlSessionFactoryBuilder().build(inputStream);}//根据id查找用户@Testpublic void testFindUserById(){    //通过sqlSqlSessFactory创建sqlSession    SqlSession sqlSession = sqlSqlSessFactory.openSession();    User user = null;    //通过sqlSession操作数据库    //第一个参数为statement的位置，等于namespace+statement的id    //第二个参数，传给占位符大的参数    user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1);    System.out.println(user);}}</code></pre><h4 id="使用MyBatis根据用户名模糊查询用户信息-通过name"><a href="#使用MyBatis根据用户名模糊查询用户信息-通过name" class="headerlink" title="使用MyBatis根据用户名模糊查询用户信息(通过name)"></a>使用MyBatis根据用户名模糊查询用户信息(通过name)</h4><p>1.需要在mapper.xml中添加以下字段:</p><pre><code>&lt;select id=&quot;findUserByNamr&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;entity.User&quot;&gt;    SELECT  * from user WHERE username like &apos;%${value}%&apos;&lt;/select&gt;</code></pre><p>此时，我们在传入参数的地方不再使用占位符#{}而是使用${}，二者区别如下:</p><ul><li>#{}:1.<strong>表示一个占位符，向占位符输入参数，mybatis自动进行java类型和jdbc类型的转换</strong>2.<strong>程序员不需要考虑参数的类型，比如：传入字符串，mybatis最终拼接好的sql就是参数两边加单引号</strong>。3.#{}接收pojo(Plain Old Java Object Java数据对象)数据，可以使用OGNL(就是el表达式)解析出pojo的属性值。</li><li>${}:1.<strong>表示sql的拼接，通过${}接收参数，将参数的内容不加任何修饰拼接在sql中。</strong>2.${}也可以接收pojo数据，可以使用OGNL解析出pojo的属性值。3.缺点:不能防止sql注入</li></ul><p>什么是sql注入，怎样防止？<br><strong>，如果是直接拼接的方式那么就非常容易被注入</strong>。比如：select <em> from tablename where user=’admin’ and pwd =’123’ 假设说这个是一个登录的sql语句，admin是用户文本框输入的，pwd是密码框输入的。如果密码文本框如果输入：’ or ‘1’=’1 那么拼接起sql就是select </em> from tablename where user=’admin’ and pwd =’’ or ‘1’=’1’ 那么就会跳过sql的条件就直接进入登录，但是如果是使用绑定变量的就不一样</p><p>Demo：</p><pre><code>//测试根据name查询用户（得到多条记录）@Testpublic void testFindUserByName(){    //通过sqlSqlSessFactory创建sqlSession    SqlSession sqlSession = sqlSqlSessFactory.openSession();    List&lt;User&gt; list = null;    list = sqlSession.selectList(&quot;test.findUserByName&quot;,&quot;y&quot;);    sqlSession.close();    System.out.println(list.get(0).getUsername());}</code></pre><p>注意，此时我们通过name查询出来的语句为多条，<strong>故此时我们应该选择调用sqlSession对象的selectList()方法返回多条记录，输出我们查询到的第一条记录即可。若使用selectOne()方法，当返回的记录为多条时就会发生异常。</strong></p><p>这样我们便完成了查询时将sql结果输出映射到Java对象中。那如何将Java对象输入映射到sql语句中，接下来我们就来讲通过MyBatis实现增、删、改数据库。</p><h3 id="使用MyBatis向表中插入一条记录"><a href="#使用MyBatis向表中插入一条记录" class="headerlink" title="使用MyBatis向表中插入一条记录"></a>使用MyBatis向表中插入一条记录</h3><pre><code>&lt;insert id=&quot;insertUser&quot; parameterType=&quot;entity.User&quot;&gt;    INSERT INTO user VALUES (#{id},#{username},#{birthday},#{sex},#{address})&lt;/insert&gt;</code></pre><p>测试类:</p><pre><code>@Testpublic void testInsertUser(){    SqlSession sqlSession = sqlSqlSessFactory.openSession();    User user = new User();    user.setUsername(&quot;codingLembre&quot;);    user.setAddress(&quot;GuangDong&quot;);    user.setBirthday(new Date());    user.setSex(&quot;1&quot;);    sqlSession.insert(&quot;test.insertUser&quot;,user);    sqlSession.commit();    sqlSession.close();}</code></pre><p>此时查看数据库，发现数据已经被插入</p><blockquote><p><strong>注意插入和查询不一样需要sqlSession.commit();否则没有效果</strong></p></blockquote><p>Demo:<br><img src="https://i.imgur.com/uNUVLFS.png" alt=""></p><h3 id="拓展-主键返回"><a href="#拓展-主键返回" class="headerlink" title="拓展:主键返回"></a>拓展:主键返回</h3><p>在测试类中，我们没有给User对象的id属性设置值，所以我们在测试类中尝试输出User对象的id时会输出id=0，但是该对象通过输入映射在数据库中是有对应的id值的(因为我们为该字段设置了自增长属性)。那么我们想输出该对象在记录中的id时，又该怎么做呢？只需在User.xml文件中的<insert></insert>标签中添加<selectkey>标签即可,属性解释见图:</selectkey></p><pre><code>&lt;!--主键返回,order属性比那时该字段在insert语句之后才执行,还要借助函数--&gt;&lt;insert id=&quot;insertUserByKey&quot; parameterType=&quot;entity.User&quot;&gt;    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt;        SELECT LAST_INSERT_ID()    &lt;/selectKey&gt;    INSERT INTO user VALUES (#{id},#{username},#{birthday},#{sex},#{address})&lt;/insert&gt;</code></pre><p>此时我们在测试类中便可输出该User对象插入在表中的记录id值了。</p><blockquote><p><strong>如果未设置主键返回，那么sout(id)得到的都是0；</strong></p></blockquote><p>这里我们<strong>由于在建表时设置了id字段为自增长，采用自增长的形式生成主键，所以我们在传入User对象的id属性时可以将该属性设置为null。</strong>那么当我们使用uuid生成主键时又该怎么做呢？</p><pre><code>&lt;insert id=&quot;insertUserByUUID&quot; parameterType=&quot;entity.User&quot;&gt;    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;int&quot;&gt;        SELECT uuid()    &lt;/selectKey&gt;    INSERT INTO user VALUES (#{id},#{username},#{birthday},#{sex},#{address})&lt;/insert&gt;</code></pre><p>属性值”before”的意思表示在执行插入操作时，会先调用uuid()函数生成uuid得到主键，然后将主键设置到User对象中，再将User对象插入到数据库。所以此时我们在测试类中也可以不对User的id属性进行设置值。但是无法演示功能，因为user表已经设置为自动增长。</p><h4 id="使用MyBatis实现删除表中数据"><a href="#使用MyBatis实现删除表中数据" class="headerlink" title="使用MyBatis实现删除表中数据"></a>使用MyBatis实现删除表中数据</h4><p>因为和上述的操作差不多，注意commit即可，不再演示。</p><h4 id="使用MyBatis实现更新表中数据"><a href="#使用MyBatis实现更新表中数据" class="headerlink" title="使用MyBatis实现更新表中数据"></a>使用MyBatis实现更新表中数据</h4><p>因为和上述的操作差不多，注意commit即可，不再演示。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习框架之前，我们先弄明白为什么要学框架。首先个人认为&lt;strong&gt;简化开发并不是采用框架唯一的目的，更重要的是规范，不用框架时写出来的代码千奇百怪，各种凌乱，有框架的约束更容易制定规范，而简化的任务是基于框架再做一些有针对性的封装时该做的事。&lt;/strong&gt; 而因为框架内部执行的复杂带来的性能损耗是要配合其他手段来优化的，比如连接池、缓存之类的，而这些手段是很容易通过框架间的整合融入进来的，如果你只用纯jdbc， 就比较困难，自己要做很多事情，还很难做好。框架整合封装完毕后，再来测试性能问题，单纯的执行一条SQL语句来判断效率是没有必要的，没什么实际价值，更多的应该是去看在并发的情况下、不同的业务场景、针对业务有效的优化后，再来看整个工程所有功能模块的平均效率，你才会做出合理的判断。项目代码&lt;a href=&quot;https://github.com/Lembre/FirstMyBatis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="MyBatis" scheme="http://codinglembre.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记之MySQL语法</title>
    <link href="http://codinglembre.top/2018/09/30/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BMySQL%E8%AF%AD%E6%B3%95/"/>
    <id>http://codinglembre.top/2018/09/30/MySQL学习笔记之MySQL语法/</id>
    <published>2018-09-30T03:27:08.000Z</published>
    <updated>2018-11-05T09:46:24.540Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h3><ul><li>DDL(Data Definition Language):数据定义语言，用来定义数据库对象：库、表、列等。功能：创建、删除、修改库和表结构。</li><li>DML(Data Manipulation Language):数据操作语言，用来定义数据库记录:增、删、改表记录。</li><li>DCL(Data Control Language):数据控制语言，用来定义访问权限和安全级别</li><li>DQL(Data Query Language):数据查询语言，用来查询记录。也是本章学习的重点。</li></ul><h3 id="SQL数据中的属性类型"><a href="#SQL数据中的属性类型" class="headerlink" title="SQL数据中的属性类型"></a>SQL数据中的属性类型</h3><ul><li>TINYINT:1字节，小整数值。</li><li>SMALLINT:2字节，大整数值。</li><li>MEDIUMINT:3字节，大整数值。</li><li>INT或INTEGER:4字节，整型,大整数值。</li><li>FLOAT:单精度浮点数值。</li><li>DOUBLE(5,2):双精度浮点型数值，参数表示该浮点型数值最多有5位，其中必须有2位小数。</li><li>DECIMAL(M,D):小数值,参数表示该数值最多有M位，其中必须有D位小数。</li><li>CHAR:字符型，<strong>固定长度字符串类型</strong>:char(255)。你存入一个a字符，虽然a只占一个字符，但是它会自动给你加254个空格凑成255个长度。即<strong>数据的长度不足指定长度，它会补足到指定长度。</strong></li><li>VARCHAR:<strong>可变长度字符串类型</strong>：varchar(65535),你存入的数据多长它就是多长。它会抽出几个字节来记录数据的长度。</li><li>TEXT(CLOB):mysql独有的数据类型，字符串类型。</li><li>BLOB:字节类型。</li><li>YEAR:年份值，格式为:YYYY</li><li>DATA:日期类型，格式为:yyyy-MM-dd。</li><li>TIME:时间类型，格式为:hh:mm:ss。</li><li>TIMESTAMP:时间戳类型，格式为上面二者的综合。</li><li>DATETIME:混合日期和时间值，格式为:YYYYMMDD HHMMSS.</li></ul><h3 id="SQL语句详解"><a href="#SQL语句详解" class="headerlink" title="SQL语句详解"></a>SQL语句详解</h3><h4 id="DDL-数据定义语言-语法"><a href="#DDL-数据定义语言-语法" class="headerlink" title="DDL(数据定义语言)语法"></a>DDL(数据定义语言)语法</h4><p>该语言用来<strong>对数据库和表结构</strong>进行操作。</p><p>对数据库的操作:</p><p>查看所有数据库:<strong><em>SHOW DATABASES;</em></strong></p><p>使用数据库:<strong>USE 数据库名</strong>;</p><p>创建数据库并指定编码:<strong>CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARACTER SET UTF8];</strong></p><p>删除数据库:<strong>DROP DATABASE 数据库名;</strong></p><p>修改数据库的编码:<strong>ALTER DATABASE 数据库名 CHARACTER SET UTF-8;</strong></p><p>对表结构的操作</p><p>创建表:</p><pre><code>CREATE TABLE (IF NOT EXISTS) 表名(列名 列类型，...，列名 列类型)；  </code></pre><p>查看当前数据库中所有表:<strong>SHOW TABLES;</strong></p><p>查看表结构:<strong>DESC 表名;</strong></p><p>删除表:<strong>DROP 表名;</strong></p><p>修改表:修改表有5个操作，但前缀都是一样的:<strong>ALTER TABLE 表名…</strong></p><pre><code>修改表之添加列:ALTER TABLE 表名 add (列名 列类型，...，列名 列类型);修改表之修改列类型:ALTER TABLE 表名 MODIFY 列名 列的新类型;修改表之列名称列类型一起修改:ALTER TABLE 表名 CHANGE 原列名 新列名 列名类型;修改表之删除列:ALTER TABLE 表名 DROP 列名;修改表之修改表名:ALTER TABLE 表名 RENAME TO 新表名</code></pre><h3 id="DML-数据操作语言-语法-增，删，改"><a href="#DML-数据操作语言-语法-增，删，改" class="headerlink" title="DML(数据操作语言)语法(增，删，改)"></a>DML(数据操作语言)语法(增，删，改)</h3><p>该语言用来<strong>对表记录操作(增、删、改)。</strong></p><h4 id="插入数据-一次插入就是插入一行"><a href="#插入数据-一次插入就是插入一行" class="headerlink" title="插入数据(一次插入就是插入一行)"></a>插入数据(一次插入就是插入一行)</h4><p><strong>insert into 表名 (列名1，列名2，列名3) values (列值1，列值2，列值3)</strong></p><p>说明:1.在数据库中所有的字符串类型，必须使用单引号。2.(列名1，列名2，列名3)可省略，表示按照表中的顺序插入。但不建议采取这种写法，因为降低了程序的可读性。3.<strong>在命令行插入记录不要写中文，否则会出现乱码</strong></p><h4 id="修改记录-不会修改一行"><a href="#修改记录-不会修改一行" class="headerlink" title="修改记录(不会修改一行)"></a>修改记录(不会修改一行)</h4><p>修改某列的全部值:update 表名 set 列名1=列值1(，列名2=列值2);</p><p>修改(某行或者多行记录的)列的指定值:update 表名 set 列名1=列值1 where 列名2=列值2 or 列名3=列值3;</p><p>运算符:=、!=、&lt;&gt;、&lt;、&gt;、&gt;=、&lt;=、between…and、in(…)、is null、not、or、and。</p><blockquote><p><strong>其中in(…)的用法表示集合。</strong>例如:update 表名 set 列名1=列值1 where 列名2=列值2 or 列名2=列值22用in(…)写成update 表名 set 列名1=列值1 where 列名2 in(列值2，列值3),具体效果如下图所示</p></blockquote><p><img src="https://i.imgur.com/ROVeEju.png" alt=""><br>执行命令并刷新数据库后:<br><img src="https://i.imgur.com/0zOSzBh.png" alt=""></p><h4 id="删除数据-删除整行"><a href="#删除数据-删除整行" class="headerlink" title="删除数据(删除整行)"></a>删除数据(删除整行)</h4><p>delete from 表名 (where 条件);<strong>不加where条件时会删除表中所有的记录，所以为了防止这种失误操作，很多数据库往往都会有备份。</strong></p><h3 id="DCL-数据控制语言-语法"><a href="#DCL-数据控制语言-语法" class="headerlink" title="DCL(数据控制语言)语法"></a>DCL(数据控制语言)语法</h3><p>该语言用来定义访问权限，理解即可，以后不会多用。需要记住的是，<strong>一个项目创建一个用户，一个项目对应的数据库只有一个。这个用户只能对这个数据库有权限，其它数据库该用户就操作不了。</strong></p><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>用户只能在指定ip地址上登录mysql:create user 用户名@IP地址 identified by ‘密码’；</p><p>用户可以在任意ip地址上登录:create user 用户名@‘％’ identified by ‘密码’；</p><h4 id="给用户授权"><a href="#给用户授权" class="headerlink" title="给用户授权"></a>给用户授权</h4><p>语法:<strong>grant 权限1，…，权限n on 数据库.* to 用户名@IP地址；其中权限1、2、n可以直接用all关键字代替。权限例如:create,alter,drop,insert,update,delete,select。</strong></p><h4 id="撤销授权"><a href="#撤销授权" class="headerlink" title="撤销授权"></a>撤销授权</h4><p>语法:revoke 权限1，…，权限n on 数据库.<em> from 用户名@ ip地址；撤销指定用户在指定数据库上的指定权限。撤销例如:revoke create,delete on mydb1.</em> form user@localhost;表示的意思是撤消user用户在数据库mydb1伤的create、alter权限。</p><h4 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h4><p>查看指定用户的权限:show grants for 用户名@ip地址；</p><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>drop user 用户名@ip地址；</p><h3 id="DQL-数据查询语言-语法-查"><a href="#DQL-数据查询语言-语法-查" class="headerlink" title="DQL(数据查询语言)语法(查)"></a>DQL(数据查询语言)语法(查)</h3><p>重点，该语言用来查询记录，不会修改数据库和表结构。</p><h4 id="基本查询-后缀都是统一为from-表名"><a href="#基本查询-后缀都是统一为from-表名" class="headerlink" title="基本查询(后缀都是统一为from 表名)"></a>基本查询(后缀都是统一为from 表名)</h4><ul><li>1.字段(列)控制<blockquote><p>1.查询所有列:select * from 表名;其中＊表示查询所有列，而不是所有行的意思。</p><p>2.查询指定列:select 列1，列2，列n from 表名；</p><p>3.完全重复的记录只显示一次:<strong>:select distinct $ from 表名；缺省值为all。</strong></p><p>4.列运算<br>  a.<strong>数量类型的列可以做加、减、乘、除</strong>:SELECT sal*5 from 表名；说明:1.<strong>遇到null加任何值都等于null的情况，需要用到ifnull()函数。2.将字符串做加减乘除运算，会把字符串当作0。</strong><br>  b.字符串累类型可以做连续运算(需要用到concat()函数):select concat(列名1，列名2) from 表名;其中列名的类型要为字符串。<strong>在mysql中不能使用+等运算符进行字符串的连接</strong><br>  c. <strong>给列名起别名:select 列名1 (as) 别名1,列名2 (as) 别名2 from 表名；</strong></p></blockquote></li><li><p>2.条件控制</p><blockquote><p>1.条件查询。在后面添加where指定条件:select * from 表名 where 列名＝指定值;</p><p>2.模糊查询：当你想查询所有姓张的记录。用到关键字like。eg:select * from 表名 where 列名 like ‘张<em>’;(**</em>代表匹配任意一个字符，％代表匹配0～n个任意字符)。**</p></blockquote></li><li><p>3.聚合函数</p><ul><li>1.count:select count(列名) from 表名；,纪录有效行数。</li><li>2.max:select max(列名) from 表名；,列中最大值。</li><li>3.min:select min(列名) from 表名；,列中最小值。</li><li>4.sum:select sum(列名) from 表名；,求列的总值，null 和字符串默认为0。<ul><li>5.avg:select avg(列名) from 表名;,一列的平均值。</li></ul></li></ul></li><li><p>4排序(所谓升序和降序都是从上往下排列)</p><p>  1.升序:select <em> form 表名 order by 列名 (ASC ); ()里面的内容为缺省值；<br>  2.降序:select </em> from 表名 order by 列名 DESC;<br>  3.使用多列作为排序条件:<strong> 当第一列排序条件相同时，根据第二列排序条件排序(当第二列依旧相同时可视情况根据第三例条件排序)</strong>。eg:select * from 表名 order by 列名1 ASC, 列名2 DESC;意思是当列名1的值相同时按照列名2的值降序排。</p></li><li><p>5.分组查询<br><strong>分组查询的信息都是组的信息，不能查到个人的信息，其中查询组的信息是通过聚合函数得到的</strong>。</p></li></ul><p>语法：select 分组列名，聚合函数1,聚合函数2 from 表名 group by 该分组列名；其中分组列名需要的条件是该列名中有重复的信息。</p><p>查询的结果只能为：作为分组条件的列和聚合函数；查处的信息都是组的信息。</p><p>分组查询前，还可以通过关键字where先把满足条件的人分出来，再分组。语法为:select 分组列，聚合函数 from 表名 where 条件 group by 分组列；</p><p>分组查询后，也可以通过关键字having把组信息中满足条件的组再细分出来。语法为：select 分组列，聚合函数 from 表名 where 条件 group by 分组列 having 聚合函数或列名(条件)；</p><p><strong>分组查询的应用有查看每个部门的平均工资等等,而使用order by无法做到多条统计信息同时显示</strong></p><p><img src="https://i.imgur.com/wis98px.png" alt=""></p><ul><li>6.LIMIT子句<strong>(mysql中独有的语法)</strong><br>LIMIT用来限定查询结果的起始行，以及总行数。</li></ul><p>例如：select * from 表名 limit 4，3；<strong>表示起始行为第5行，一共查询3行记录。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>学过的关键字：select,from,where,group by,having ,order by。当一条查询语句中都包含所有这些关键字时它们的优先级是select&gt;from&gt;where&gt;group by&gt;having&gt;order by</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;SQL语句分类&quot;&gt;&lt;a href=&quot;#SQL语句分类&quot; class=&quot;headerlink&quot; title=&quot;SQL语句分类&quot;&gt;&lt;/a&gt;SQL语句分类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DDL(Data Definition Language):数据定义语言，用来定义数据库
      
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="数据库" scheme="http://codinglembre.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>String，StringBuilder和StringBuffer的区别</title>
    <link href="http://codinglembre.top/2018/09/30/Java%E4%B8%ADString%EF%BC%8CStringBuilder%E5%92%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://codinglembre.top/2018/09/30/Java中String，StringBuilder和StringBuffer的区别/</id>
    <published>2018-09-30T03:13:23.000Z</published>
    <updated>2018-11-05T03:00:15.095Z</updated>
    
    <content type="html"><![CDATA[<p>现在很多互联网公司面试java的面试官都喜欢问这样一个问题，那么就来谈谈java中String、StringBuilder和StringBuffer的区别。</p><a id="more"></a><h3 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h3><ul><li>String字符串常量</li><li>StringBuffer字符串变量(线程安全）</li><li>StringBuilder字符串变量（非线程安全）</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>所谓常量，即该对象的值已经被赋予了，不能再更改。若非要更改，则只能再重新创建另一个对象，在这个新创建的对象上再进行赋值。因此，每次在对String类型的对象进行改变的时候其实都等同于生成了一个新的String对象，然后将指针指向新的String对象，所以经常改变内容的字符串最好不要用String，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM的GC就会开始工作，那速度是一定会相当慢的。</p><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>所谓变量，即是可以随时变化的量。如果对StringBuffer对象进行改变，每次结果都会对StringBuffer对象进行操作，而不是生成新的对象。所以一般字符串要经常变化的话我推荐使用StringBuffer。</p><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>StringBuilder和StringBuffer类功能基本相似，方法也差不多，主要区别在于<strong>StringBuffer类的方法是多线程安全的，而StringBuilder不是线程安全的</strong>，相比而言<strong>StringBuilder类会略微快一点。</strong></p><h3 id="运行速度"><a href="#运行速度" class="headerlink" title="运行速度"></a>运行速度</h3><ul><li>Java中对String对象进行的操作实际上是一个<strong>不断创建新的对象并且将旧的对象回收的一个过程</strong>，所以执行速度很慢。</li><li>而StringBuilder和StringBuffer的对象是变量，<strong>对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作</strong>，所以速度要比String快很多。</li></ul><p>但是，有时候我们会这样对字符串进行赋值:</p><pre><code>String str=&quot;abc&quot;+&quot;de&quot;;StringBuilder stringBuilder=new StringBuilder().append(&quot;abc&quot;).append(&quot;de&quot;);System.out.println(str);System.out.println(stringBuilder.toString());</code></pre><p>这样输出结果也是“abcde”和“abcde”，但是<strong>String的速度却比StringBuilder的反应速度要快很多</strong></p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>如果<strong>一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字</strong>，所以可以保证线程是安全的，但<strong>StringBuilder的方法则没有该关键字，所以不能保证线程安全</strong>，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p><h3 id="使用须知"><a href="#使用须知" class="headerlink" title="使用须知"></a>使用须知</h3><ul><li><p>String：适用于少量的字符串操作的情况</p></li><li><p>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</p></li><li><p>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>现在很多互联网公司面试java的面试官都喜欢问这样一个问题</p><blockquote><p>请你谈谈StringBuffer和StringBuilder的区别。</p></blockquote><p>大多数人肯定会直接说前者是线程安全的而后者是非线程安全的。其实这个时候才是面试官真正想问的，他会顺着你的回答又问你，那请你谈谈什么是线程…balabalabala。哈哈，要想顺利通过面试，所以对知识的了解还是全面点吧～！</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在很多互联网公司面试java的面试官都喜欢问这样一个问题，那么就来谈谈java中String、StringBuilder和StringBuffer的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://codinglembre.top/categories/Java/"/>
    
    
      <category term="JavaSE" scheme="http://codinglembre.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习之监听器</title>
    <link href="http://codinglembre.top/2018/09/30/JavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>http://codinglembre.top/2018/09/30/JavaWeb学习之监听器/</id>
    <published>2018-09-30T01:50:52.000Z</published>
    <updated>2018-11-06T02:29:02.998Z</updated>
    
    <content type="html"><![CDATA[<p>监听器(Listener)其实就是一个<strong>实现特定接口的普通java程序</strong>，监听器是一个<strong>专门用于对其他对象身上(三大域对象)发生的事件或状态改变进行监听和相应处理的对象，它可以监听客户端请求和服务端的操作</strong>，当被监视的对象发生情况时，立即采取相应的行动。这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法立即被执行。</p><p>上述概念设计到3个名词概念:</p><ul><li>事件源:即谁产生的事件</li><li>事件对象:即产生了什么事件</li><li>监听器:监听事件源的动作</li></ul><p>由于事件源可以产生多个动作(即产生多个事件)，而<strong>监听器中的每一个方法监听一个动作，故每个监听器中都有很多方法。</strong></p><a id="more"></a><h3 id="JavaWeb中的监听器的概念"><a href="#JavaWeb中的监听器的概念" class="headerlink" title="JavaWeb中的监听器的概念"></a>JavaWeb中的监听器的概念</h3><p>JavaWeb中的监听器是Servlet规范中定义的一种特殊类，它用于监听web应用程序中的ServletContext、HttpSession和 ServletRequest这三大域对象的创建、销毁事件以及监听这些域对象中的属性发生修改的事件。<br><img src="https://i.imgur.com/9Em7yhT.png" alt=""><br><img src="https://i.imgur.com/45msGDS.png" alt=""></p><p>其中，<strong>Java中的ServletContext对象对应JSP的application对象（上下文对象，由容器创建和初始化），HTTPSession对象对应JSP的session对象（保存上下文对象的机制，放在服务器端，通过sessionID区分的，服务器关闭和结束时销毁），ServletRequest对象（容器创建时创建的对象，来进行封装请求对象，同时还会创建ServletResponse对象）对应JSP中的request对象。</strong></p><p><strong>总而言之，就是监听这三个对象的创建销毁和属性的变化</strong></p><h3 id="JavaWeb中监听器的分类"><a href="#JavaWeb中监听器的分类" class="headerlink" title="JavaWeb中监听器的分类"></a>JavaWeb中监听器的分类</h3><p>在Servlet规范中定义了多种类型的监听器(一共8个监听器)，它们用于监听的事件源分别为ServletContext，HttpSession和ServletRequest这三个域对象。Servlet规范针对这三个对象上的操作，又把多种类型的监听器划分为三种类型：</p><ul><li><p>域对象的生命周期监听:<strong>监听域对象自身的创建和销毁</strong>。这个监听器需要实现相应的监听器接口:ServletContextListener(<strong>定时器和全局属性对象</strong>)、HttpSessionListener(<strong>统计在线人数和记录访问日志</strong>)、ServletRequestListener(<strong>读取参数和记录访问历史</strong>)。<br>关于的ServletContext的Demo:<br>在配置文件web.xml配置:</p><p>  <context-param></context-param></p><pre><code>&lt;param-name&gt;initParam&lt;/param-name&gt;&lt;param-value&gt;codingLembre&lt;/param-value&gt;</code></pre><p>  <br>然后可以在<strong>实现ServletContextListener接口的类中可以获取到相应的配置</strong>:</p><pre><code>public void contextInitialized(ServletContextEvent sce) {sce.getServletContext().getInitParameter(&quot;initParam&quot;);</code></pre></li><li><p>域对象的属性监听:<strong>监听域对象中属性的增加和删除。</strong>这个监听器需要实现的监听器接口为:ServletContextAttributeListener、HttpSessionAttributeListener、ServletRequestAttributeListener</p></li><li>感知监听(<strong>监听绑定到HTTPSession域中的某个对象的状态的事件监听器</strong>):监听绑定到HttpSession域中的某个JavaBean对象的状态的监听器。这个监听器需要实现的监听器接口:HttpSessionBindingListener、HttpSessionActiveationListener</li></ul><h3 id="第一类-域对象的生命周期监听"><a href="#第一类-域对象的生命周期监听" class="headerlink" title="第一类:域对象的生命周期监听"></a>第一类:域对象的生命周期监听</h3><p>事件源为:三大域<br>事件对象为:创建与销毁<br>监听器为:实现了ServletContextListener、HttpSessionListener、ServletRequestListener这三个接口的监听器</p><h4 id="ServletContext的生命周期监听"><a href="#ServletContext的生命周期监听" class="headerlink" title="ServletContext的生命周期监听"></a>ServletContext的生命周期监听</h4><pre><code>public class AListener implements ServletContextListener{public void contextInitialized(ServletContextEvent sce){  //在项目启动时调用}public void contextDestroyed(ServletContextEvent sce){  //在项目关闭时调用}}</code></pre><p>需要在web.xml文件中进行配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/alistern.png" alt=""></p><h4 id="HttpSession的生命周期监听"><a href="#HttpSession的生命周期监听" class="headerlink" title="HttpSession的生命周期监听"></a>HttpSession的生命周期监听</h4><pre><code>public class AListener implements HttpSessionListener{public void sessionCreated(HttpSessionEvent sce){  //在会话产生时调用}public void sessionDestroyed(HttpSessionEvent sce){  //在会话关闭时调用}}</code></pre><p>需要在web.xml文件中进行配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/alistern.png" alt=""></p><h4 id="ServletRequest的生命周期"><a href="#ServletRequest的生命周期" class="headerlink" title="ServletRequest的生命周期"></a>ServletRequest的生命周期</h4><pre><code>public class AListener implements ServletRequestListener{public void requestInitialized(ServletRequestEvent sce){  //在请求产生时调用}public void requestDestroyed(ServletRequestEvent sce){  //在请求关闭时调用}}</code></pre><p>需要在web.xml文件中进行配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/alistern.png" alt=""></p><h4 id="对各个监听器接口的方法中出现的类介绍"><a href="#对各个监听器接口的方法中出现的类介绍" class="headerlink" title="对各个监听器接口的方法中出现的类介绍"></a>对各个监听器接口的方法中出现的类介绍</h4><p>ServletContextEvent类:<strong><em>类中有一个方法getServletContext(),该方法返回ServletContext对象。</em></strong><br>HttpSessionEvent类:类中有一个方法<strong><em>getSession()，该方法返回一个HttpSession对象。</em></strong><br>ServletRequestEvent类:类中有两个方法，<strong><em>getServletContext()用于返回一个ServletContext对象，getServletRequest()用于返回一个ServletRequest对象。</em></strong></p><h3 id="第二类-域对象的属性监听"><a href="#第二类-域对象的属性监听" class="headerlink" title="第二类:域对象的属性监听"></a>第二类:域对象的属性监听</h3><p>事件源:三大域<br>事件对象:属性的增加与删除<br>监听器:实现了ServletContextAttributeListener、HttpSessionAttributeListener、ServletRequestAttributeListener接口的监听器</p><h4 id="ServletContext的属性监听"><a href="#ServletContext的属性监听" class="headerlink" title="ServletContext的属性监听"></a>ServletContext的属性监听</h4><pre><code>public class AListener implements ServletContextAttributeListener{public void attributeAdded(ServletcontextAttribute scab){  //给ServletContext对象添加属性时调用}public void attributeRemoved(ServletContextAttributeEvent scab){//给ServletContext对象删除属性时调用}public void attributeReplaced(ServletContextAttributeEvent scab){//给ServletContext对象替换属性值时调用}}</code></pre><p>同样需要在web.xml文件中对AListener进行配置。</p><h4 id="HttpSession的属性监听"><a href="#HttpSession的属性监听" class="headerlink" title="HttpSession的属性监听"></a>HttpSession的属性监听</h4><pre><code>public class AListener implements HttpSessionAttributeListener{public void attributeAdded(HttpSessionAttribute scab){  //给HttpSession对象添加属性时调用}public void attributeRemoved(HttpSessionAttributeEvent scab){//给HttpSession对象删除属性时调用}    public void attributeReplaced(HttpSessionAttributeEvent scab){//给HttpSession对象替换属性值时调用}}</code></pre><p>同样需要在web.xml中对AListener进行配置。</p><h4 id="ServletRequest的属性监听"><a href="#ServletRequest的属性监听" class="headerlink" title="ServletRequest的属性监听"></a>ServletRequest的属性监听</h4><pre><code>public class AListener implements ServletRequestAttributeListener{public void attributeAdded(ServletRequestAttribute scab){  //给ServletRequest对象添加属性时调用}public void attributeRemoved(ServletRequestAttributeEvent scab){//给ServletRequest对象删除属性时调用}public void attributeReplaced(ServletRequestAttributeEvent scab){//给ServletRequest对象替换属性值时调用}}</code></pre><h4 id="对各个监听器接口的方法中出现的类介绍-1"><a href="#对各个监听器接口的方法中出现的类介绍-1" class="headerlink" title="对各个监听器接口的方法中出现的类介绍"></a>对各个监听器接口的方法中出现的类介绍</h4><p>ServletContextAttributeEvent类:该类对象有三个方法，<strong>getSevletContext()用于返回一个ServletContext，getName()用于返回属性名，getValue()用于返回属性值。</strong></p><p>HttpSessionBindingEvent类:该类对象有两个方法，<strong>getName()用于获取属性名，getValue()用于获取属性值。</strong></p><p>ServletRequestAttributeEvent类:该类对象有两个方法，<strong>getName()用于获取属性名，getValue()用于获取属性值。</strong></p><h3 id="感知监听器"><a href="#感知监听器" class="headerlink" title="感知监听器"></a>感知监听器</h3><p>在此之前先了解一下<strong>Session对象的几种状态机制</strong></p><ul><li>绑定:Session对象持久化到存储设备中</li><li>解除绑定:Session对象从存储设备中回复</li><li>钝化机制:session过多，session在服务器内存中的开销将十分巨大，直接影响Web服务器的性能。此时，服务器自动将不常用的session将被序列化到系统文件或数据库中，使用时再由服务器自动反序列化到服务器内存中。这个机制由SessionManager管理，它的管理机制:<br><img src="https://i.imgur.com/CRoZZlF.png" alt=""><br><img src="https://i.imgur.com/xpTMe4F.png" alt=""></li></ul><p><strong>保存在Session域中的对象可以有多种状态：绑定(session.setAttribute(“bean”,Object))到Session中,随Session对象持久化到一个存储设备中；从Session域中解除(session.removeAttribute(“bean”))绑定,随Session对象从一个存储设备中恢复。</strong></p><p>Servlet 规范中定义了两个特殊的监听器接口<strong>”HttpSessionBindingListener和HttpSessionActivationListener”来帮助JavaBean 对象了解自己在Session域中的这些状态，实现这两个接口的类不需要 web.xml 文件中进行注册。</strong><br><img src="https://i.imgur.com/ZDuyKUI.png" alt=""></p><h4 id="HttpSessionBindingListener接口"><a href="#HttpSessionBindingListener接口" class="headerlink" title="HttpSessionBindingListener接口"></a>HttpSessionBindingListener接口</h4><p>实现了HttpSessionBindingListener接口的JavaBean对象可以感知自己被绑定到Session中和 Session中删除的事件。</p><p>当对象被绑定到HttpSession对象中时，web服务器调用该对象的void valueBound(HttpSessionBindingEvent event)方法。</p><p>当对象从HttpSession对象中解除绑定时，web服务器调用该对象的void valueUnbound(HttpSessionBindingEvent event)方法。</p><pre><code>public class JavaBeanDemo1 implements HttpSessionBindingListener { private String name; @Override public void valueBound(HttpSessionBindingEvent event) {     System.out.println(name+&quot;被加到session中了&quot;); } @Override public void valueUnbound(HttpSessionBindingEvent event) {     System.out.println(name+&quot;被session踢出来了&quot;); } public String getName() {     return name; } public void setName(String name) {     this.name = name; } public JavaBeanDemo1(String name) {     this.name = name; }}</code></pre><p>上述的JavaBeanDemo1这个javabean实现了HttpSessionBindingListener接口，那么这个JavaBean对象可以感知自己被绑定到Session中和从Session中删除的这两个操作。</p><h3 id="HttpSessionActivationListener接口"><a href="#HttpSessionActivationListener接口" class="headerlink" title="HttpSessionActivationListener接口"></a>HttpSessionActivationListener接口</h3><p><strong>实现了HttpSessionActivationListener接口的JavaBean对象可以感知自己被活化(反序列化)和钝化(序列化)的事件。</strong></p><p>当绑定到HttpSession对象中的javabean对象将要随HttpSession对象被钝化(序列化)之前，web服务器调用该javabean对象的void sessionWillPassivate(HttpSessionEvent event) 方法。这样javabean对象就可以知道自己将要和HttpSession对象一起被序列化(钝化)到硬盘中。</p><p>当绑定到HttpSession对象中的javabean对象将要随HttpSession对象被活化(反序列化)之后，web服务器调用该javabean对象的void sessionDidActive(HttpSessionEvent event)方法。这样javabean对象就可以知道自己将要和 HttpSession对象一起被反序列化(活化)回到内存中。(javabean随着HttpSession对象一起被活化的前提是该javabean对象除了实现该接口外还应该实现Serialize接口)。</p><pre><code>public class JavaBeanDemo2 implements HttpSessionActivationListener,    Serializable {private static final long serialVersionUID = 7589841135210272124L;private String name;@Overridepublic void sessionWillPassivate(HttpSessionEvent se) {    System.out.println(name+&quot;和session一起被序列化(钝化)到硬盘了，session的id是：&quot;+se.getSession().getId());} @Overridepublic void sessionDidActivate(HttpSessionEvent se) {    System.out.println(name+&quot;和session一起从硬盘反序列化(活化)回到内存了，session的id是：&quot;+se.getSession().getId());}public String getName() {    return name;}public void setName(String name) {           this.name = name;}public JavaBeanDemo2(String name) {    this.name = name;}</code></pre><p>   }</p><p>***如果某个类(ja888vabean对象)实现了HttpSessionActiveationListener接口后，当对象随着session被钝化和活化时，下面两个方法就会被调用</p><pre><code>public void sessionWillPassivate(HttpSessionEvent se):当对象感知被活化时调用本方法。  public void sessionDidActivate(HttpSessionEvent se):当对象感知被钝化时调用本方法。</code></pre><h3 id="Servlet3-0新特性，注解监听器"><a href="#Servlet3-0新特性，注解监听器" class="headerlink" title="Servlet3.0新特性，注解监听器"></a>Servlet3.0新特性，注解监听器</h3><p><strong>使用@WebListener，该注解用于将类声明为监听器，但是没有定义顺序的标识</strong><br><img src="https://i.imgur.com/oN7iBId.png" alt=""></p><p>这是使用注解和两个监听器实现的实时统计在线人数及IP信息<a href="https://github.com/Lembre/SessionManager" target="_blank" rel="noopener">github源代码</a></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>监听器的启动加载顺序和在web.xml中的注册顺序有关</strong>，当同时存在监听器，过滤器和Servlet时，加载顺序为:<br><img src="https://i.imgur.com/e5cGadN.png" alt=""></p><h3 id="监听域对象属性变化的实际应用"><a href="#监听域对象属性变化的实际应用" class="headerlink" title="监听域对象属性变化的实际应用"></a>监听域对象属性变化的实际应用</h3><p>待更新</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;监听器(Listener)其实就是一个&lt;strong&gt;实现特定接口的普通java程序&lt;/strong&gt;，监听器是一个&lt;strong&gt;专门用于对其他对象身上(三大域对象)发生的事件或状态改变进行监听和相应处理的对象，它可以监听客户端请求和服务端的操作&lt;/strong&gt;，当被监视的对象发生情况时，立即采取相应的行动。这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法立即被执行。&lt;/p&gt;
&lt;p&gt;上述概念设计到3个名词概念:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件源:即谁产生的事件&lt;/li&gt;
&lt;li&gt;事件对象:即产生了什么事件&lt;/li&gt;
&lt;li&gt;监听器:监听事件源的动作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于事件源可以产生多个动作(即产生多个事件)，而&lt;strong&gt;监听器中的每一个方法监听一个动作，故每个监听器中都有很多方法。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="JavaWeb" scheme="http://codinglembre.top/tags/JavaWeb/"/>
    
      <category term="Servlet" scheme="http://codinglembre.top/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习之AJAX</title>
    <link href="http://codinglembre.top/2018/09/29/JavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8BAJAX/"/>
    <id>http://codinglembre.top/2018/09/29/JavaWeb学习之AJAX/</id>
    <published>2018-09-29T09:23:38.000Z</published>
    <updated>2018-10-08T14:24:26.001Z</updated>
    
    <content type="html"><![CDATA[<p><strong>客户端向服务器发送请求，若服务器每次响应过来的结果都要重新加载整个界面的话这样会给服务器带来很大的压力。Ajax 不是某种编程语言，是一种在无需重新加载整个网页的情况下能够更新部分网页的技术</strong>。</p><a id="more"></a><h3 id="AJAX概念"><a href="#AJAX概念" class="headerlink" title="AJAX概念"></a>AJAX概念</h3><ul><li>1.<strong>asynchronous javascript and xml，翻译过来就是异步的javascript和xml。</strong></li><li>2.<strong>XMLhttpRequest对象来实现这一功能，也需要javascript来操作DOM实现局部的信息更新。</strong></li><li>3.<strong>服务器给客户端的响应一般是整个页面，一个html完整页面但在ajax中因为是局部刷新，那么服务器就不用再响应整个页面而只是响应局部。</strong></li></ul><p>Ajax三步骤： </p><ul><li>1、运用HTML和CSS实现页面，表达信息； </li><li>2、运用XMLHttpRequest和web服务器进行数据的异步交换； </li><li>3、运用JavaScript操作DOM，实现动态局部刷新；</li></ul><p><strong>XHR对象是一个javascript对象，它可以在用户没有感觉的情况下，就像背后运行的一根小线程一般，悄悄的和服务器进行数据交互<br>AJAX就是通过它做到无刷新效果的</strong><br>XHR对象的作用是和服务器进行交互，所以既会发消息给服务器，也能接受服务器返回的响应。<br>当服务器响应回来的时候，调用怎么处理呢？<br>通过 xmlhttp.onreadystatechange=checkResult 就可以指定用checkResult 函数进行处理</p><h3 id="服务器向客户端返回的数据类型"><a href="#服务器向客户端返回的数据类型" class="headerlink" title="服务器向客户端返回的数据类型"></a>服务器向客户端返回的数据类型</h3><p>一般客户端向服务器发送请求，服务器返回的数据类型有三种:</p><ul><li>text类型:返回的数据是纯文本。</li><li>xml类型:返回的数据是xml格式，它是提供js和java交互的数据格式</li><li>json类型:它也是提供js和java交互的数据格式，在ajax中最受欢迎。</li></ul><h3 id="理解同步交互和异步交互"><a href="#理解同步交互和异步交互" class="headerlink" title="理解同步交互和异步交互"></a>理解同步交互和异步交互</h3><ul><li>同步交互:<ul><li>发一个请求，就要等待服务器的响应结束，然后才能发送第二个请求</li><li>刷新的是整个页面</li></ul></li><li>异步交互:<ul><li>发一个请求，无需等待服务器的响应，然后就可以发第二个请求。</li><li>可以使用js来接受服务器的响应，然后使用js来局部刷新界面。</li></ul></li></ul><p>附上uml图解释这两者的区别:<br><img src="src=&quot;http://od2xrf8gr.bkt.clouddn.com/ajax.png&quot;" alt=""></p><h3 id="ajax的优缺点"><a href="#ajax的优缺点" class="headerlink" title="ajax的优缺点"></a>ajax的优缺点</h3><ul><li>优点:<ul><li>异步交互，增强了用户的体验。</li><li>性能:因为服务器无需再响应整个页面，只需要响应部分内容，所以服务器的压力减轻了</li></ul></li><li><p>缺点:</p><ul><li>ajax不能应用在所有场景</li><li>ajax无端的增多了对服务器的访问次数，给服务器带来了压力(比较上述优点，在减少了服务器压力的同时又给服务器带来了压力，不知你理不理解哈哈)</li><li><h3 id="得到XMLHttpRequest"><a href="#得到XMLHttpRequest" class="headerlink" title="得到XMLHttpRequest"></a>得到XMLHttpRequest</h3><p>大多数浏览器都只是得到该对象的方法为:var xmlHttp=new XMLHttpRequest();<br>IE6.0得到的方法为:var xmlHttp = new ActiveXObject(“Msxml2.XMLHTTP”);<br>IE5.0以及更早版本的IE:var xmlHttp=new ActiveXObject(“Microsoft.XMLHTTP”);<br>在&lt;script&gt;中编写创建XMLHttpRequest对象的函数:</p><p>function createXMLHttpRequest(){<br>  try{</p><pre><code>return new XMLHttpRequest();</code></pre><p>  }catch(e){</p><pre><code>try{    return new ActiveXObject(“Msxml2.XMLHTTP”);}catch(e){    try{        return new ActiveXObject(“Microsoft.XMLHTTP”);    }catch(e){        alert(“哥们，你用的是什么浏览器啊”);        throw e;    }}</code></pre><p>  }<br>}</p></li></ul></li></ul><p>或者不用这么麻烦，直接:<br><img src="https://i.imgur.com/2aIpV8k.png" alt=""></p><h3 id="XMLHttpRequest发送请求"><a href="#XMLHttpRequest发送请求" class="headerlink" title="XMLHttpRequest发送请求"></a>XMLHttpRequest发送请求</h3><p>XMLHttpRequest发送请求： </p><ul><li>open(method,url,async) method：规定HTTP发送请求的方式是get还是post,不区分大小写，一般来说用大写 url：请求地址(相对地址或绝对地址) async:同步/异步(false/true)，默认是异步也就是true，可以不用填写 - request.send(“name=xxxx&amp;set=xxx”); <strong>这是在设置访问的页面</strong>8</li><li><strong>send(string):发送到服务器（该参数可以填或者不填—–get方法不填或填null，post:一般要填） ，这是在执行访问</strong></li></ul><p>例如： request.open(“POST”,”create.php”,true); request.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded “)//设置HTTP头信息–一定要写在open()和send()之间 </p><h3 id="XMLHttpRequest取得响应"><a href="#XMLHttpRequest取得响应" class="headerlink" title="XMLHttpRequest取得响应"></a>XMLHttpRequest取得响应</h3><p>监听readyState,响应成功可以做一些事情，比如获取服务器响应的内容在页面上做一些呈现<br>例如:</p><pre><code>&lt;span&gt;输入账号 :&lt;/span&gt;&lt;input id=&quot;name&quot; name=&quot;name&quot; onkeyup=&quot;check()&quot; type=&quot;text&quot;&gt; &lt;span id=&quot;checkResult&quot;&gt;&lt;/span&gt;&lt;script&gt;var xmlhttp;function check(){  var name = document.getElementById(&quot;name&quot;).value;  var url = &quot;http://how2j.cn/study/checkName.jsp?name=&quot;+name;  xmlhttp =new XMLHttpRequest();  xmlhttp.onreadystatechange=checkResult; //响应函数  xmlhttp.open(&quot;GET&quot;,url,true);   //设置访问的页面  xmlhttp.send(null);  //执行访问}function checkResult(){  if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)    document.getElementById(&apos;checkResult&apos;).innerHTML=xmlhttp.responseText;}&lt;/script&gt;</code></pre><p>或者另一种写法:</p><pre><code> xmlhttp.onreadystatechange=function(){    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200){    //做一些事情（即响应）    document.getElementById(&apos;checkResult&apos;).innerHTML=xmlhttp.responseText;}</code></pre><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>给xmlHttp对象注册onreadystatechange监听器，这个方法用于接收从服务器发送过来的响应数据。 在该方法中需要做以下步骤:</p><ul><li>获取xmlHttp对象的状态，xmlHttp对象一共有5个状态:<ul><li>0状态:表示xmlHttp对象刚创建，还没有调用open()方法。</li><li>1状态：请求开始，调用了open方法，但还没有调用send方法</li><li>调用完了send方法</li><li>服务器已经开始响应，但不表示响应结束了</li><li>服务器响应结束(通常我们只关心这个状态)</li></ul></li></ul><p>该状态通过调用xmlHttp.readyState得到。</p><ul><li>得到服务器响应的状态码:通过调用xmlHttp.status得到，例如200，404，500。</li><li><p>得到服务器响应的内容，由于服务器返回的类型不同，所以得到的内容类型也不同，以下3种类型采用3种方法得到:</p><ul><li>var content=xmlHttp.responseText;//服务器返回的文本为text。</li><li>var content=xmlHttp.responseXML;//服务器响应的文本为xml内容。xmlHttp会自动对xml文本进行解析，得到的content为document对象。</li><li><p>var content=eval(“(“+xmlHttp.responsetext+”)”);//服务器返回的文本为json数据。<br>完成第四步我们需要写的完整代码为:</p><p>//xmlHttp的5种状态都会调用本方法<br>xmlHttp.onreadystatechange=function(){<br>if(xmlHttp.readState==4&amp;&amp;xmlHttp.status==200){//双重判断:判断是否为4状态，而且还要判断是否为200<br>  //获取服务器的响应内容<br>  var content=xmlHttp.responseText;//或var content= xmlHttp.responseXML;<br>}<br>}</p></li></ul></li></ul><h3 id="案例-省市联动"><a href="#案例-省市联动" class="headerlink" title="案例:省市联动"></a>案例:省市联动</h3><p>说明，该案例就是在网页上显示两个下拉列表，一个列表用于显示中国所有的省份，一个列表用于显示相应省份下的城市，当然这些数据是存在数据库中的，为了方便展示，我只在数据库中列举了两个省份和部分城市。<br><img src="http://od2xrf8gr.bkt.clouddn.com/province.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/city.png" alt=""><br>servlet包下的CityServlet.java与ProvinceServlet.java，用于向客户端发送响应数据代码如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/cityservlet.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/provinceservlet.png" alt=""><br>dao包下的ProvinceDao.java代码如下:用于与数据库连接:<br><img src="http://od2xrf8gr.bkt.clouddn.com/provincedao.png" alt=""></p><p>最终要的界面代码关于ajax的操作,代码如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/ajax1.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/ajax2.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/ajax3.png" alt=""><br>数据库中的表有两张，一张是省份表province,一张是城市表city,如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/city2.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/province2.png" alt=""><br>结果如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/jiemian.png" alt=""><br>当选择了相应的省份时，ajax会立即向服务器发送请求，然后服务器返回该省份下所有的城市，ajax将这些城市动态的显示在”请选择城市”列表中。达到部分刷新界面的效果。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;客户端向服务器发送请求，若服务器每次响应过来的结果都要重新加载整个界面的话这样会给服务器带来很大的压力。Ajax 不是某种编程语言，是一种在无需重新加载整个网页的情况下能够更新部分网页的技术&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://codinglembre.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaWeb" scheme="http://codinglembre.top/tags/JavaWeb/"/>
    
      <category term="AJAX" scheme="http://codinglembre.top/tags/AJAX/"/>
    
  </entry>
  
</feed>
