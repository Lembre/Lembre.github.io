<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>codingLembre&#39;s blog</title>
  
  <subtitle>I have a dream!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://codinglembre.top/"/>
  <updated>2018-09-20T17:21:42.744Z</updated>
  <id>http://codinglembre.top/</id>
  
  <author>
    <name>Lembre</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码检查规范CheckStyle和PMD的配置使用</title>
    <link href="http://codinglembre.top/2018/09/21/%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E8%A7%84%E8%8C%83CheckStyle%E5%92%8CPMD%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/"/>
    <id>http://codinglembre.top/2018/09/21/代码检查规范CheckStyle和PMD的配置使用/</id>
    <published>2018-09-20T16:22:26.000Z</published>
    <updated>2018-09-20T17:21:42.744Z</updated>
    
    <content type="html"><![CDATA[<p>CheckStyle是SourceForge下的一个项目，提供了一个帮助JAVA开发人员遵守某些编码规范的工具。它能够自动化代码规范检查过程，从而使得开发人员从这项重要，但是枯燥的任务中解脱出来。PMD是一种开源分析Java代码错误的工具。与其他分析工具不同的是，PMD通过静态分析获知代码错误。也就是说，在不运行Java程序的情况下报告错误。PMD附带了许多可以直接使用的规则，利用这些规则可以找出Java源程序的许多问题。现在就来看看它们的安装配置和使用吧。</p><a id="more"></a><h2 id="CheckStyle插件的安装与配置"><a href="#CheckStyle插件的安装与配置" class="headerlink" title="CheckStyle插件的安装与配置"></a>CheckStyle插件的安装与配置</h2><h3 id="安装CheckStyle插件"><a href="#安装CheckStyle插件" class="headerlink" title="安装CheckStyle插件"></a>安装CheckStyle插件</h3><p><img src="https://i.imgur.com/OaN4xrT.png" alt=""></p><h3 id="CheckStyle插件的配置"><a href="#CheckStyle插件的配置" class="headerlink" title="CheckStyle插件的配置"></a>CheckStyle插件的配置</h3><p><img src="https://i.imgur.com/Umsxf89.png" alt=""></p><p>当安装好插件，打开 IDEA的设置页面 settings -&gt; Other Settings 你会发现默认的 Checkstyle , 勾选就OK了,如上图。其实在还可以点击上面绿色加号添加自定义checkstyle文件，该文件放在项目的根目录。在里面可以设置你想要的格式。基本的配置就完毕了。现在 IDEA的控制面板会多一个 CheckStyle，你可以在这里方便的进行代码检查。可以点击面板的左上角下拉框 Rules 去动态切换不同的 checkstyle。</p><p><img src="https://i.imgur.com/oGRxvuU.png" alt=""></p><h3 id="CheckStyle插件的使用"><a href="#CheckStyle插件的使用" class="headerlink" title="CheckStyle插件的使用"></a>CheckStyle插件的使用</h3><p>完成安装与配置之后CheckStyle，便可以运行CheckStyle。根据CheckStyle扫描结果对应修改。</p><p><img src="https://i.imgur.com/O6DomA6.png" alt=""></p><h3 id="定制专属CheckStyle检查规则"><a href="#定制专属CheckStyle检查规则" class="headerlink" title="定制专属CheckStyle检查规则"></a>定制专属CheckStyle检查规则</h3><p> CheckStyle不管是插件方式还是脚本方式，使用都是相当方便快捷的，而难点在于如何定制专属于我们项目的CheckStyle检查规则。</p><blockquote><p>定制CheckStyle规则大致思路：通过对Google 提供的checkStyle检查规则修改完善，打造出属于自己的检查规则。<a href="https://github.com/checkstyle/checkstyle/blob/master/src/main/resources/google_checks.xml" target="_blank" rel="noopener">谷歌配置文件规则</a></p></blockquote><p>在配置文件中中主要由module 、property、message等节点构成：</p><ul><li>module节点 主要是指检查项，如MethodName （检查方法命名）module中有两个比较重要的节点，它们分别是Checker（checkStyle配置文件的根节点，必须存在）、TreeWalker（树遍历器），TreeWalker会自动去检查指定范围内的每一个java源文件，TreeWalker内部会定义很多module。</li><li>property 节点对应module 检查项中具体检查属性，如果使用默认值，property节点可以省略</li><li>message节点 checkStyle检查出来，是否打印出message消息，message节点可以省略</li></ul><p>如何添加过滤能力？</p><blockquote><p>解决办法：在定制好的checkStyle.xml文件中，添加一个名为SuppressionFilter的moudle，在过滤规则文件suppressions.xml中添加相应的过滤规则。</p></blockquote><h2 id="PMD插件的安装和使用"><a href="#PMD插件的安装和使用" class="headerlink" title="PMD插件的安装和使用"></a>PMD插件的安装和使用</h2><ol><li><p>自动安装：file –&gt; settings –&gt; plugins  搜索  pmd</p></li><li><p>用户可以选择在单个或者多个文件或文件夹上运行PMD：选中 文件或文件夹 –&gt; 右击 –&gt; Run PDM –&gt; 选择规则集</p></li></ol><p><img src="https://i.imgur.com/Osowhq8.png" alt=""></p><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CheckStyle是SourceForge下的一个项目，提供了一个帮助JAVA开发人员遵守某些编码规范的工具。它能够自动化代码规范检查过程，从而使得开发人员从这项重要，但是枯燥的任务中解脱出来。PMD是一种开源分析Java代码错误的工具。与其他分析工具不同的是，PMD通过静态分析获知代码错误。也就是说，在不运行Java程序的情况下报告错误。PMD附带了许多可以直接使用的规则，利用这些规则可以找出Java源程序的许多问题。现在就来看看它们的安装配置和使用吧。&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="http://codinglembre.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于抽象类和接口</title>
    <link href="http://codinglembre.top/2018/09/20/%E5%85%B3%E4%BA%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://codinglembre.top/2018/09/20/关于抽象类和接口/</id>
    <published>2018-09-20T08:04:00.000Z</published>
    <updated>2018-09-20T12:25:45.337Z</updated>
    
    <content type="html"><![CDATA[<p>对于面向对象编程来说，抽象是它的一大特征之一。在Java中，可以通过两种形式来体现OOP的抽象：接口和抽象类。这两者有太多相似的地方，又有太多不同的地方。很多人在初学的时候会以为它们可以随意互换使用，但是实际则不然。下面我们一起来学习一下Java中的接口和抽象类：</p><a id="more"></a><h2 id="什么是抽象方法和抽象类"><a href="#什么是抽象方法和抽象类" class="headerlink" title="什么是抽象方法和抽象类"></a>什么是抽象方法和抽象类</h2><p>在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法和抽象类的声明格式分别为：</p><blockquote><p>抽象方法: abstract void fun();</p><p>抽象类:abstract class ClassName {abstract void fun();}</p></blockquote><p>关于抽象类</p><ul><li>抽象类是为了继承而存在的，它并不能被实例化</li><li>如果一个类继承于一个抽象类，那么它必须实现父类的抽象方法，除非它自己也是抽象类。</li></ul><p>　　</p><h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><p>在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对行为的抽象。</p><ul><li>接口中可以含有变量，而方法会被隐式地指定为public abstract方法，它是一种极度抽象的类型，它比抽象类更加“抽象”</li><li>接口中的变量会被隐式地指定为public static final变量，但是一般情况下不在接口中定义变量。</li></ul><p>##抽象类和接口的区别</p><p>1.语法层面上的区别</p><ul><li><p>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</p></li><li><p>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</p></li></ul><p>2.设计层面上的区别</p><ul><li>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</li><li>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</li></ul><h2 id="什么时候用抽象类，什么时候用接口"><a href="#什么时候用抽象类，什么时候用接口" class="headerlink" title="什么时候用抽象类，什么时候用接口"></a>什么时候用抽象类，什么时候用接口</h2><ul><li>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。</li><li>如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</li><li>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</li></ul><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于面向对象编程来说，抽象是它的一大特征之一。在Java中，可以通过两种形式来体现OOP的抽象：接口和抽象类。这两者有太多相似的地方，又有太多不同的地方。很多人在初学的时候会以为它们可以随意互换使用，但是实际则不然。下面我们一起来学习一下Java中的接口和抽象类：&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="http://codinglembre.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>代码重构的方式理解MVC模式</title>
    <link href="http://codinglembre.top/2018/09/20/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E7%9A%84%E6%96%B9%E5%BC%8F%E7%90%86%E8%A7%A3MVC%E6%A8%A1%E5%BC%8F/"/>
    <id>http://codinglembre.top/2018/09/20/代码重构的方式理解MVC模式/</id>
    <published>2018-09-20T06:56:00.000Z</published>
    <updated>2018-09-20T11:26:08.058Z</updated>
    
    <content type="html"><![CDATA[<p>MVC模式是基于WEB系统模块化框架的大思想，繁衍出的一个把视图和处理做低耦合分离的一种模式。<br>核心就是尽可能让一个后台系统，在几乎不做任何修改的情况下，同时支持多种视图。但是它的缺点是由于它没有明确的定义，所以完全理解MVC并不是很容易。使用MVC需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。 接下来我将以代码重构的方式帮助我们更好地理解MVC设计模式<br>。<br><a id="more"></a></p><h2 id="关于MVC设计模式"><a href="#关于MVC设计模式" class="headerlink" title="关于MVC设计模式"></a>关于MVC设计模式</h2><p>MVC模式（Model-View-Controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）：</p><ul><li>Model——业务功能编写（例如算法实现）、数据库设计以及数据存取处理等操作实现</li><li>Controller——负责转发请求并对请求进行处理</li><li>View——负责界面显示</li></ul><p>在JSP/Servlet开发的软件系统中，这三个部分的实现如下所示：</p><p><img src="https://i.imgur.com/JKevvci.png" alt="">   </p><ol><li>Web浏览器发送HTTP请求到服务端，被Controller(Servlet)获取并进行处理（例如参数解析、请求转发）</li><li>Controller(Servlet)调用核心业务逻辑——Model部分，获得结果</li><li>Controller(Servlet)将逻辑处理结果交给View（JSP），动态输出HTML内容</li><li>动态生成的HTML内容返回到浏览器显示</li></ol><p>MVC模式在Web开发中的好处是非常明显，它规避了JSP与Servlet各自的短板，Servlet只负责业务逻辑而不会通过out.append()动态生成HTML代码；JSP中也不会充斥着大量的业务代码。这大大提高了代码的可读性和可维护性。</p><h2 id="具体体现"><a href="#具体体现" class="headerlink" title="具体体现"></a>具体体现</h2><blockquote><p>在进行代码重构之前的Servlet代码:</p></blockquote><pre><code>@SuppressWarnings(&quot;serial&quot;)public class ListServlet extends HttpServlet {@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    try {        //设置编码        req.setCharacterEncoding(&quot;UTF-8&quot;);        //获取页面的值        String command = req.getParameter(&quot;command&quot;);        String description = req.getParameter(&quot;description&quot;);        //向页面传接到的值        req.setAttribute(&quot;command&quot;, command);        req.setAttribute(&quot;description&quot;, description);        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis&quot;, &quot;root&quot;, &quot;123456&quot;);        StringBuilder sql = new StringBuilder(&quot;select ID, COMMAND, DESCRIPTION, CONTENT from MESSAGE where 1 = 1&quot;) ;        List&lt;String&gt; paramList = new ArrayList&lt;&gt;();//缓冲,添加动态传参        if (command != null &amp;&amp; !&quot;&quot;.equals(command.trim()))        {            sql.append( &quot; and COMMAND = ?&quot;);            paramList.add(command);        }        if (description != null &amp;&amp; !&quot;&quot;.equals(description.trim()))        {            sql.append( &quot; and DESCRIPTION like &apos;%&apos; ? &apos;%&apos;&quot;);            paramList.add(description);        }        PreparedStatement statement = conn.prepareStatement(sql.toString());        for (int i = 0; i &lt; paramList.size(); i++) {            //sql语句从1开始的，所以i+1            statement.setString(i+1, paramList.get(i));        }        ResultSet rs = statement.executeQuery();        List&lt;Message&gt; messageList = new ArrayList&lt;&gt;();        while(rs.next())        {            Message message = new Message();            messageList.add(message);            message.setId(rs.getString(&quot;ID&quot;));            message.setCommand(rs.getString(&quot;COMMAND&quot;));            message.setDescription(rs.getString(&quot;DESCRIPTION&quot;));            message.setContent(rs.getString(&quot;CONTENT&quot;));        }        //查询消息列表并传给页面        req.setAttribute(&quot;messageList&quot;, messageList);    } catch (ClassNotFoundException e) {        e.printStackTrace();    } catch (SQLException e) {        e.printStackTrace();    }    req.getRequestDispatcher(&quot;/WEB-INF/jsp/back/list.jsp&quot;).forward(req, resp);}@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    this.doGet(req, resp);}}</code></pre><p>上述servlet代码不仅负责了业务逻辑代码，如获取页面的值，向页面传接收到的值，还包括了获取数据库驱动，获取数据库连接和相关的数据库操作代码。这样使得servlet的代码过于冗长，代码的可读性，可维护性差</p><blockquote><p>下面是代码重构之后的servlet</p></blockquote><pre><code>@SuppressWarnings(&quot;serial&quot;)public class ListServlet extends HttpServlet {@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    //设置编码    req.setCharacterEncoding(&quot;UTF-8&quot;);    //获取页面的值    String command = req.getParameter(&quot;command&quot;);    String description = req.getParameter(&quot;description&quot;);    //向页面传接到的值    req.setAttribute(&quot;command&quot;, command);    req.setAttribute(&quot;description&quot;, description);    ListService listService = new ListService();    //查询消息列表并传给页面    req.setAttribute(&quot;messageList&quot;, listService.queryMessageList(command, description));    req.getRequestDispatcher(&quot;/WEB-INF/jsp/back/list.jsp&quot;).forward(req, resp);}@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    this.doGet(req, resp);}}</code></pre><blockquote><p>下面的代码是重构之后的dao代码:</p></blockquote><pre><code>public class MessageDao {public List&lt;Message&gt; queryMessageList(String command, String description){    List&lt;Message&gt; messageList = new ArrayList&lt;&gt;();    try {        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis&quot;, &quot;root&quot;, &quot;123456&quot;);        StringBuilder sql = new StringBuilder(&quot;select ID, COMMAND, DESCRIPTION, CONTENT from MESSAGE where 1 = 1&quot;) ;        List&lt;String&gt; paramList = new ArrayList&lt;String&gt;();//缓冲,添加动态传参        if (command != null &amp;&amp; !&quot;&quot;.equals(command.trim()))        {            sql.append( &quot; and COMMAND = ?&quot;);            paramList.add(command);        }        if (description != null &amp;&amp; !&quot;&quot;.equals(description.trim()))        {            sql.append( &quot; and DESCRIPTION like &apos;%&apos; ? &apos;%&apos;&quot;);            paramList.add(description);        }        PreparedStatement statement = conn.prepareStatement(sql.toString());        for (int i = 0; i &lt; paramList.size(); i++) {            statement.setString(i+1, paramList.get(i));        }        ResultSet rs = statement.executeQuery();        while(rs.next())        {            Message message = new Message();            //先放和后放是一样的，因为容器里面放的都是引用，不是真正的对象本身，所以接下来对这个对象操作依然有效            messageList.add(message);            message.setId(rs.getString(&quot;ID&quot;));            message.setCommand(rs.getString(&quot;COMMAND&quot;));            message.setDescription(rs.getString(&quot;DESCRIPTION&quot;));            message.setContent(rs.getString(&quot;CONTENT&quot;));        }    } catch (ClassNotFoundException e) {        e.printStackTrace();    } catch (SQLException e) {        e.printStackTrace();    }    return messageList;}}</code></pre><blockquote><p>下面是重构之后的数据库连接代码</p></blockquote><pre><code>public class DBHelper {private static final String driver = &quot;com.mysql.jdbc.Driver&quot;;//因为这些变量都是，全局的不需要修改的，固定的写法，所以设置为静态的私有的private static final String url=&quot;jdbc:mysql://localhost:3306/shopping?useUnicode=true&amp;characterEncoding=UTF-8&quot;;private static final String username=&quot;root&quot;;private static final String password=&quot;123456&quot;;private static Connection conn=null;//静态代码块负责加载驱动static{    try    {        Class.forName(driver);    }    catch(Exception ex)    {        ex.printStackTrace();    }}public static Connection getConnection() throws Exception//static关键字表示类方法，直接通过类名调用{    if(conn==null)    {        conn = DriverManager.getConnection(url, username, password);        return conn;    }    return conn;}public static void main(String[] args) {    try    {        Connection conn = DBHelper.getConnection();        if(conn!=null)        {            System.out.println(&quot;数据库连接正常&quot;);        }        else        {            System.out.println(&quot;数据库连接异常&quot;);        }    }    catch(Exception ex)    {        ex.printStackTrace();    }}}</code></pre><p>通过代码重构可以清楚的发现，使用MVC设计模式的项目的代码可读性更高，可维护性更高。但是其实MVC设计模式也有它的不足:</p><ol><li>增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 </li><li>视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。 </li><li>视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</li></ol><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>如果需要联系作者，请在主页点击右下角的微信图标，或者通过以下方式:</p><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MVC模式是基于WEB系统模块化框架的大思想，繁衍出的一个把视图和处理做低耦合分离的一种模式。&lt;br&gt;核心就是尽可能让一个后台系统，在几乎不做任何修改的情况下，同时支持多种视图。但是它的缺点是由于它没有明确的定义，所以完全理解MVC并不是很容易。使用MVC需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。 接下来我将以代码重构的方式帮助我们更好地理解MVC设计模式&lt;br&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="JavaWeb" scheme="http://codinglembre.top/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>SSM整合工程的搭建</title>
    <link href="http://codinglembre.top/2018/09/17/SSM%E6%95%B4%E5%90%88%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://codinglembre.top/2018/09/17/SSM整合工程的搭建/</id>
    <published>2018-09-17T07:52:23.000Z</published>
    <updated>2018-09-20T11:26:53.134Z</updated>
    
    <content type="html"><![CDATA[<p>当我们系统的学完了Spring、Spring MVC以及Mybatis之后就可以进行这三者的整合工作了，也就是SSM框架的整合，其实就是将这三个框架的配置文件提取出来放在一个项目中，然后便可以进行开发，是不是觉得挺简单的。这篇文章我们将在前篇文章Mybatis与Spring整合的基础上将Spring MVC的配置引入进来完成SSM框架的整合。</p><h2 id="整合的思路"><a href="#整合的思路" class="headerlink" title="整合的思路"></a>整合的思路</h2><ol><li>在Mybatis与Spring3整合的基础上再进行Spring MVC框架的整合。</li><li>Spring要管理Spring MVC编写的Handler(controller)、Mybatis的SqlSessionFactory、mapper、数据源。其实整合思路就是下面这三步:<ul><li>第一步:整合dao(即mapper)，完成Spring与Mybatis的整合</li><li>第二步:整合service，Spring管理service接口，service中可以调用Spring容器中的dao(mapper)。</li><li>第三步:整合controller，Spring管理controller接口，在controller调用service。</li></ul></li></ol><h2 id="pom-xml的需要导入的依赖"><a href="#pom-xml的需要导入的依赖" class="headerlink" title="pom.xml的需要导入的依赖"></a>pom.xml的需要导入的依赖</h2><pre><code>&lt;!--添加mybatis-generator-core.jar依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;    &lt;version&gt;1.3.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.11&lt;/version&gt;    &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- spring核心包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis核心包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;${mybatis.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis/spring包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 导入java ee jar 包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax&lt;/groupId&gt;    &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;    &lt;version&gt;7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 导入Mysql数据库链接jar包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.30&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;    &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;    &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- JSTL标签类 --&gt;&lt;dependency&gt;    &lt;groupId&gt;jstl&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 日志文件管理包 --&gt;&lt;!-- log start --&gt;&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;${log4j.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 格式化对象，方便输出日志 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.1.41&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;    &lt;version&gt;${slf4j.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;    &lt;version&gt;${slf4j.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- log end --&gt;&lt;!-- 映入JSON --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;    &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;    &lt;version&gt;1.9.13&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 上传组件包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-codec&lt;/groupId&gt;    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;    &lt;version&gt;1.9&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="pom-xml的需要导入的配置"><a href="#pom-xml的需要导入的配置" class="headerlink" title="pom.xml的需要导入的配置"></a>pom.xml的需要导入的配置</h2><pre><code>&lt;properties&gt;    &lt;!-- spring版本号 --&gt;    &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt;    &lt;!-- mybatis版本号 --&gt;    &lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt;    &lt;!-- log4j日志文件管理包版本 --&gt;    &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt;    &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;&lt;/properties&gt; &lt;build&gt;    &lt;!--  强制将xml文件打到war包中 s--&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;    &lt;pluginManagement&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.6&lt;/version&gt;                &lt;configuration&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/pluginManagement&gt;&lt;/build&gt;</code></pre><h2 id="spring-mybatis-xml-spring-mvc-xml和web-xml"><a href="#spring-mybatis-xml-spring-mvc-xml和web-xml" class="headerlink" title="spring-mybatis.xml,spring-mvc.xml和web.xml"></a>spring-mybatis.xml,spring-mvc.xml和web.xml</h2><blockquote><p>spring-mybatis.xml</p></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;   xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd                    http://www.springframework.org/schema/context                    http://www.springframework.org/schema/context/spring-context-3.1.xsd                    http://www.springframework.org/schema/mvc                    http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt;&lt;!-- 自动扫描 --&gt;&lt;context:component-scan base-package=&quot;dao&quot; /&gt;&lt;context:component-scan base-package=&quot;pojo&quot; /&gt;&lt;context:component-scan base-package=&quot;mapping&quot; /&gt;&lt;context:component-scan base-package=&quot;service&quot; /&gt;&lt;context:component-scan base-package=&quot;serviceimpl&quot; /&gt;&lt;!-- 引入配置文件 --&gt;&lt;bean id=&quot;propertyConfigurer&quot;      class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;    &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;      destroy-method=&quot;close&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&gt;    &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt;    &lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&gt;    &lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&gt;    &lt;!-- 初始化连接大小 --&gt;    &lt;property name=&quot;initialSize&quot; value=&quot;${initialSize}&quot;&gt;&lt;/property&gt;    &lt;!-- 连接池最大数量 --&gt;    &lt;property name=&quot;maxActive&quot; value=&quot;${maxActive}&quot;&gt;&lt;/property&gt;    &lt;!-- 连接池最大空闲 --&gt;    &lt;property name=&quot;maxIdle&quot; value=&quot;${maxIdle}&quot;&gt;&lt;/property&gt;    &lt;!-- 连接池最小空闲 --&gt;    &lt;property name=&quot;minIdle&quot; value=&quot;${minIdle}&quot;&gt;&lt;/property&gt;    &lt;!-- 获取连接最大等待时间 --&gt;    &lt;property name=&quot;maxWait&quot; value=&quot;${maxWait}&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;!-- 自动扫描mapping.xml文件 --&gt;    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapping/*.xml&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;dao&quot; /&gt;    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;&lt;bean id=&quot;transactionManager&quot;      class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><blockquote><p>spring-mvc.xml</p></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;   xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd                    http://www.springframework.org/schema/context                    http://www.springframework.org/schema/context/spring-context-3.1.xsd                    http://www.springframework.org/schema/mvc                    http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt;&lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt;&lt;context:component-scan base-package=&quot;controller&quot; /&gt;&lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt;&lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot;      class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;    &lt;property name=&quot;supportedMediaTypes&quot;&gt;        &lt;list&gt;            &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt;&lt;bean        class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt;    &lt;property name=&quot;messageConverters&quot;&gt;        &lt;list&gt;            &lt;ref bean=&quot;mappingJacksonHttpMessageConverter&quot; /&gt;    &lt;!-- JSON转换器 --&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;    &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt;&lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt;&lt;bean id=&quot;multipartResolver&quot;      class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;!-- 默认编码 --&gt;    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot; /&gt;    &lt;!-- 文件大小最大值 --&gt;    &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760000&quot; /&gt;    &lt;!-- 内存中的最大值 --&gt;    &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot; /&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><blockquote><p>web.xml</p></blockquote><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;     version=&quot;3.1&quot;&gt;&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;!-- Spring和mybatis的配置文件 --&gt;&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 编码过滤器 --&gt;&lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;async-supported&gt;true&lt;/async-supported&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- Spring监听器 --&gt;&lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 防止Spring内存溢出监听器 --&gt;&lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- Spring MVC servlet --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;    &lt;!-- 此处可以可以配置成*.do，对应struts的后缀习惯 --&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;welcome-file-list&gt;    &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;&lt;/web-app&gt;</code></pre><p>然后，在src下创建各个包:mapper、po、controller、service，在web包下创建页面包jsp。经过上述步骤，我们便完成了Spring、Spring MVC与Mybatis的整合，是不是很简单?没错就是这么简单。</p><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>如果需要联系作者，请在主页点击右下角的微信图标，或者通过以下方式:</p><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们系统的学完了Spring、Spring MVC以及Mybatis之后就可以进行这三者的整合工作了，也就是SSM框架的整合，其实就是将这三个框架的配置文件提取出来放在一个项目中，然后便可以进行开发，是不是觉得挺简单的。这篇文章我们将在前篇文章Mybatis与Spring
      
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="SSM" scheme="http://codinglembre.top/tags/SSM/"/>
    
      <category term="框架" scheme="http://codinglembre.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>IDEA创建MyBatis逆向工程</title>
    <link href="http://codinglembre.top/2018/09/17/IDEA%E5%88%9B%E5%BB%BAMyBatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <id>http://codinglembre.top/2018/09/17/IDEA创建MyBatis逆向工程/</id>
    <published>2018-09-17T04:36:10.000Z</published>
    <updated>2018-09-20T11:26:31.508Z</updated>
    
    <content type="html"><![CDATA[<p>过去我们在开发时都需要通过数据库中的表然后自己在po包下手动建立相对应的pojo类，并要创建相应的mapper.xml写出对表的所有操作，而使用插件mybatis-generator-core生成mybatis逆向工程就不用我们自己再编写pojo类与相应的mapper类和相应的xml文件，它可以自动对单表生成sql，包括:mapper.xml、mapper.java、表名.java(po类)。这是非常方便快捷的。下面我将为你们介绍如何使用插件生成mybatis的逆向工程，只需三步而已。</p><a id="more"></a><h2 id="逆向工程的部署"><a href="#逆向工程的部署" class="headerlink" title="逆向工程的部署"></a>逆向工程的部署</h2><h3 id="pom-xml的需要导入的依赖和配置"><a href="#pom-xml的需要导入的依赖和配置" class="headerlink" title="pom.xml的需要导入的依赖和配置"></a>pom.xml的需要导入的依赖和配置</h3><blockquote><p>需要导入的依赖</p></blockquote><pre><code>&lt;!-- -添加mybatis-generator-core插件 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;    &lt;version&gt;1.3.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据库连接包 --&gt; &lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.30&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 日志文件管理包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;${log4j.version}&lt;/version&gt;&lt;/dependency&gt;</code></pre><blockquote><p>需要更改的配置</p></blockquote><pre><code>    &lt;build&gt;    &lt;!--  强制将xml文件打到war包中 s--&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;    &lt;pluginManagement&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.6&lt;/version&gt;                &lt;configuration&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/pluginManagement&gt;&lt;/build&gt;</code></pre><h3 id="逆向工程的配置文件generatorConfig-xml"><a href="#逆向工程的配置文件generatorConfig-xml" class="headerlink" title="逆向工程的配置文件generatorConfig.xml"></a>逆向工程的配置文件generatorConfig.xml</h3><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;!DOCTYPE generatorConfiguration    PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;    &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;    &lt;generatorConfiguration&gt;&lt;!-- 数据库驱动--&gt;&lt;classPathEntry  location=&quot;lib/mysql-connector-java-8.0.11.jar&quot;/&gt;&lt;context id=&quot;DB2Tables&quot;  targetRuntime=&quot;MyBatis3&quot;&gt;    &lt;commentGenerator&gt;        &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;        &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;        &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;    &lt;/commentGenerator&gt;    &lt;!--数据库链接URL，用户名、密码 --&gt;    &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/ssmtest&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt;        &lt;!--设置为 true 可以获取 tables 信息, 解决生成文件缺少 xxxByPrimaryKey 的问题 --&gt;        &lt;property name=&quot;useInformationSchema&quot; value=&quot;true&quot;/&gt;    &lt;/jdbcConnection&gt;    &lt;javaTypeResolver&gt;        &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;    &lt;/javaTypeResolver&gt;    &lt;!-- 生成模型的包名和位置--&gt;    &lt;javaModelGenerator targetPackage=&quot;pojo&quot; targetProject=&quot;src/main/java&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;    &lt;/javaModelGenerator&gt;    &lt;!-- 生成映射文件的包名和位置--&gt;    &lt;sqlMapGenerator targetPackage=&quot;mapping&quot; targetProject=&quot;src/main/java&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;    &lt;/sqlMapGenerator&gt;    &lt;!-- 生成DAO的包名和位置--&gt;    &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;dao&quot; targetProject=&quot;src/main/java&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;    &lt;/javaClientGenerator&gt;    &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt;    &lt;table tableName=&quot;user_t&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;    &lt;/table&gt;&lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><blockquote><p>关键的属性:</p></blockquote><ul><li>javaModelGenerator,生成PO类的位置</li><li>sqlMapGenerator,mapper映射文件生成的位置</li><li>javaClientGenerator,mapper接口生成的位置</li><li>table,其tableName属性对应数据库中相应表</li></ul><h3 id="配置相应的运行命令"><a href="#配置相应的运行命令" class="headerlink" title="配置相应的运行命令"></a>配置相应的运行命令</h3><p>点击Edit Configuration，点击+号，在Command line中输入mybatis-generator:generate -e然后点击应用，选择运行，等一会逆向工程便成功地建立！</p><p>###需要注意的地方<br>生成逆向工程进行JUnit测试时，报错Result Maps collection already contains value for …<br>原因:多次使用逆向工程生成mapper接口和xml文件时，是增加，而不是覆盖。所以需要将已经生成的文件删除，重新运行逆向工程。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>如果需要联系作者，请在主页点击右下角的微信图标，或者通过以下方式:</p><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p><pre><code>-</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过去我们在开发时都需要通过数据库中的表然后自己在po包下手动建立相对应的pojo类，并要创建相应的mapper.xml写出对表的所有操作，而使用插件mybatis-generator-core生成mybatis逆向工程就不用我们自己再编写pojo类与相应的mapper类和相应的xml文件，它可以自动对单表生成sql，包括:mapper.xml、mapper.java、表名.java(po类)。这是非常方便快捷的。下面我将为你们介绍如何使用插件生成mybatis的逆向工程，只需三步而已。&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="MyBatis" scheme="http://codinglembre.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis和Spring整合</title>
    <link href="http://codinglembre.top/2018/09/17/MyBatis%E5%92%8CSpring%E6%95%B4%E5%90%88/"/>
    <id>http://codinglembre.top/2018/09/17/MyBatis和Spring整合/</id>
    <published>2018-09-17T04:36:10.000Z</published>
    <updated>2018-09-20T11:27:05.449Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis是一种开源的半自动的持久化框架，它通过抽象jdbc模板代码提供简单的api交互简化持久层实现。通过读取mybatis.xml，Mapper.xml，Mapper映射了相应的JavaBean，通过SqlSessionFactory的实例化出来的SqlSession，执行对应方法，根据方法名回到Mapper.xml中找到和方法名相对应的id(注释方式的话找到接口类里面注释id对应的方法)，根据sql语句，还有传入的参数，还有Bean，这几者的联系形成的映射，进行CURD操作，省去JDBC那些模板方法代码。Spring也是开源框架，简化了Java开发，其主要功能是依赖注入和面向切面工程。</p><a id="more"></a><h2 id="mybatis和spring整合的思路"><a href="#mybatis和spring整合的思路" class="headerlink" title="mybatis和spring整合的思路"></a>mybatis和spring整合的思路</h2><ul><li>使用spring管理SqlSessionFactory</li><li><p>使用spring管理mapper对象和dao</p><blockquote><p>使用spring和mybatis整合开发mapper代理及原始dao接口。<br>自动开启事务，自动管理sqlsession</p></blockquote></li><li><p>让spring管理数据源(即数据库连接池)</p></li></ul><h2 id="开始整合工作"><a href="#开始整合工作" class="headerlink" title="开始整合工作"></a>开始整合工作</h2><h3 id="pom-xml的需要导入的依赖和配置"><a href="#pom-xml的需要导入的依赖和配置" class="headerlink" title="pom.xml的需要导入的依赖和配置"></a>pom.xml的需要导入的依赖和配置</h3><blockquote><p>需要导入的依赖</p></blockquote><pre><code>&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.11&lt;/version&gt;    &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- spring核心包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis核心包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;${mybatis.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis/spring包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 导入java ee jar 包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax&lt;/groupId&gt;    &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;    &lt;version&gt;7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 导入Mysql数据库链接jar包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.30&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;    &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;    &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 日志文件管理包 --&gt;&lt;!-- log start --&gt;&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;${log4j.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 格式化对象，方便输出日志 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.1.41&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;    &lt;version&gt;${slf4j.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;    &lt;version&gt;${slf4j.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- log end --&gt;&lt;!-- 映入JSON --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;    &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;    &lt;version&gt;1.9.13&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="整合配置文件spring-MyBatis-xml"><a href="#整合配置文件spring-MyBatis-xml" class="headerlink" title="整合配置文件spring-MyBatis.xml"></a>整合配置文件spring-MyBatis.xml</h3><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;   xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd                    http://www.springframework.org/schema/context                    http://www.springframework.org/schema/context/spring-context-3.1.xsd                    http://www.springframework.org/schema/mvc                    http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt;&lt;!-- 自动扫描 --&gt;&lt;context:component-scan base-package=&quot;dao&quot; /&gt;&lt;context:component-scan base-package=&quot;pojo&quot; /&gt;&lt;context:component-scan base-package=&quot;mapping&quot; /&gt;&lt;context:component-scan base-package=&quot;service&quot; /&gt;&lt;context:component-scan base-package=&quot;serviceimpl&quot; /&gt;&lt;!-- 引入配置文件 --&gt;&lt;bean id=&quot;propertyConfigurer&quot;      class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;    &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;      destroy-method=&quot;close&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&gt;    &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt;    &lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&gt;    &lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&gt;    &lt;!-- 初始化连接大小 --&gt;    &lt;property name=&quot;initialSize&quot; value=&quot;${initialSize}&quot;&gt;&lt;/property&gt;    &lt;!-- 连接池最大数量 --&gt;    &lt;property name=&quot;maxActive&quot; value=&quot;${maxActive}&quot;&gt;&lt;/property&gt;    &lt;!-- 连接池最大空闲 --&gt;    &lt;property name=&quot;maxIdle&quot; value=&quot;${maxIdle}&quot;&gt;&lt;/property&gt;    &lt;!-- 连接池最小空闲 --&gt;    &lt;property name=&quot;minIdle&quot; value=&quot;${minIdle}&quot;&gt;&lt;/property&gt;    &lt;!-- 获取连接最大等待时间 --&gt;    &lt;property name=&quot;maxWait&quot; value=&quot;${maxWait}&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;!-- 自动扫描mapping.xml文件 --&gt;    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapping/*.xml&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;dao&quot; /&gt;    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;&lt;bean id=&quot;transactionManager&quot;      class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>至此，MyBatis便和Spring整合成功。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>如果需要联系作者，请在主页点击右下角的微信图标，或者通过以下方式:</p><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MyBatis是一种开源的半自动的持久化框架，它通过抽象jdbc模板代码提供简单的api交互简化持久层实现。通过读取mybatis.xml，Mapper.xml，Mapper映射了相应的JavaBean，通过SqlSessionFactory的实例化出来的SqlSession，执行对应方法，根据方法名回到Mapper.xml中找到和方法名相对应的id(注释方式的话找到接口类里面注释id对应的方法)，根据sql语句，还有传入的参数，还有Bean，这几者的联系形成的映射，进行CURD操作，省去JDBC那些模板方法代码。Spring也是开源框架，简化了Java开发，其主要功能是依赖注入和面向切面工程。&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="MyBatis" scheme="http://codinglembre.top/tags/MyBatis/"/>
    
      <category term="Spring" scheme="http://codinglembre.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>常用Markdown语法</title>
    <link href="http://codinglembre.top/2018/05/27/%E5%B8%B8%E7%94%A8Markdown%E8%AF%AD%E6%B3%95/"/>
    <id>http://codinglembre.top/2018/05/27/常用Markdown语法/</id>
    <published>2018-05-27T02:09:01.000Z</published>
    <updated>2018-09-20T11:25:52.408Z</updated>
    
    <content type="html"><![CDATA[<p>其实这周挺忙的，各种考试，实验，作业统统集中到一起（内心os:麻木到习以为常了QAQ），但是还是抽空搭建了自己的个人博客网站，第一篇博文也不知道该写什么好，就把昨天自学的Markdown语法写下来了。</p><a id="more"></a><h2 id="关于Markdown，你需要了解的概念"><a href="#关于Markdown，你需要了解的概念" class="headerlink" title="关于Markdown，你需要了解的概念"></a>关于Markdown，你需要了解的概念</h2><p><strong>Markdown</strong> 是一种可以使用 普通文本编辑器编写的轻量级 <strong>标记语言</strong>，通过简单的标记语法，它可以使普通文本内容具有一定的格式。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的 <strong>语法很简单</strong>。常用的标记符号不超过十个。让我们开始学习MarkDown语法吧！</p><h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><p>因为MarkDown并不是我的学习方向，我学Markdown只是为了更好的写博文。因此，对于实现的效果相同的语法，我只列出最容易记的那种。若需要系统的学习MarkDown语法，请百度官方文档或者打开<a href="https://blog.csdn.net/witnessai1/article/details/52551362" target="_blank" rel="noopener">MarkDown</a>链接。</p><h3 id="1-段落，标题和区块代码"><a href="#1-段落，标题和区块代码" class="headerlink" title="1.段落，标题和区块代码"></a>1.段落，标题和区块代码</h3><p>①段落:</p><blockquote><p>一个以上的空行则会划分出不同的段落,一般的段落不需要用空白或换行缩进。(标题和正文之间会自动添加阴影线以及段落)</p></blockquote><p>②标题:</p><blockquote><p>推荐使用ATX形式。即在行首插入1到六个#，对应到标题的1到六阶。</p></blockquote><p>③区块代码: </p><blockquote><p>区块引用则使用 email 形式的 ‘&gt;’ 角括号。</p></blockquote><h3 id="2-强调"><a href="#2-强调" class="headerlink" title="2.强调"></a>2.强调</h3><blockquote><p>可以在需要强调的位置前后加 <strong>两个星号</strong> 来标记需要强调的区段。</p></blockquote><h3 id="3-列表-共有两种形式"><a href="#3-列表-共有两种形式" class="headerlink" title="3.列表(共有两种形式)"></a>3.列表(共有两种形式)</h3><p>①无序列表:使用星号， <strong>加号</strong>，减号来进行标记,例如</p><blockquote><p>  +Candy.</p><p>  +Gum.</p></blockquote><p>效果：</p><ul><li>Candy.</li><li>Gum.</li></ul><p>②有序列表:使用一般的数字接着一个英文句点,例如</p><blockquote><ol><li><p>Red</p></li><li><p>Green</p></li></ol></blockquote><p>效果:</p><ol><li>Red</li><li>Green</li></ol><h3 id="4-链接-不区分大小写，共有两种形式"><a href="#4-链接-不区分大小写，共有两种形式" class="headerlink" title="4.链接(不区分大小写，共有两种形式)"></a>4.链接(不区分大小写，共有两种形式)</h3><blockquote><p>①行内形式: []里写 <strong>链接文字</strong>，()里写 <strong>链接地址</strong>, 此外还可以为链接指定title属性，title属性可加可不加</p><p>②参考形式:文中的写法 [链接文字]接上[链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p></blockquote><h3 id="5图片-类似于链接，分为两种形式"><a href="#5图片-类似于链接，分为两种形式" class="headerlink" title="5图片(类似于链接，分为两种形式)"></a>5图片(类似于链接，分为两种形式)</h3><blockquote><p>①行内形式： <strong>![图片Alt]接上(图片地址 “图片Title”)</strong></p><p>②参考形式:在文档要插入图片的地方写 <strong>![图片Alt]接上[标记]</strong>,在文档的最后写上[标记]:图片地址 “Title”</p></blockquote><h3 id="6代码和代码段"><a href="#6代码和代码段" class="headerlink" title="6代码和代码段"></a>6代码和代码段</h3><blockquote><p>①段落文字中存在代码区段，可以用 <strong>反引号</strong> 在代码区段左右加一个 `来标记代码区段</p><p>②代码区块已经被格式化,可以使用 <strong>tab或者空四个格</strong></p><p>③代码段可以使用 <strong>‘’’代码段’’’</strong> 来实现</p></blockquote><h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><blockquote><p>在设置标题时，#后面务必加上个空格，否则会导致标题效果渲染失败</p></blockquote><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>如果需要联系作者，请在主页点击右下角的微信图标，或者通过以下方式:</p><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul><p>完结撒花!!!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这周挺忙的，各种考试，实验，作业统统集中到一起（内心os:麻木到习以为常了QAQ），但是还是抽空搭建了自己的个人博客网站，第一篇博文也不知道该写什么好，就把昨天自学的Markdown语法写下来了。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://codinglembre.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Blog" scheme="http://codinglembre.top/tags/Blog/"/>
    
      <category term="HTML" scheme="http://codinglembre.top/tags/HTML/"/>
    
  </entry>
  
</feed>
