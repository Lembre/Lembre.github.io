<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>codingLembre&#39;s blog</title>
  
  <subtitle>I have a dream!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://codinglembre.top/"/>
  <updated>2018-10-04T02:33:00.370Z</updated>
  <id>http://codinglembre.top/</id>
  
  <author>
    <name>Lembre</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java学习之阅读Java编程思想</title>
    <link href="http://codinglembre.top/2018/10/04/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%98%85%E8%AF%BB%E2%80%9C%E2%80%98%E2%80%98Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    <id>http://codinglembre.top/2018/10/04/Java学习之阅读“‘‘Java编程思想/</id>
    <published>2018-10-03T19:16:15.000Z</published>
    <updated>2018-10-04T02:33:00.370Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象导论"><a href="#对象导论" class="headerlink" title="对象导论"></a>对象导论</h3><ul><li>程序可以通过添加新类型的对象使得自身使用于某个特定的问题。</li><li><strong>可以通过构建包含现有对象的方式来创建新的对象。以此在程序中构建复杂的体系，同时将其复杂性隐藏在对象简单性的背后</strong></li><li>某一特定类型的所有对象可以接受同样的消息，这种可替代性是OOP中最强有力的概念</li><li>每一个对象都能和其他对象区分开来，具体说来，在内存中有一个唯一地址。</li><li>程序通过定义类来适应问题，而不再使用现有的表示机器中存储单元的数据类型。</li><li><strong>将对象看做服务提供者，这个对象又需要哪些服务提供者？这是一种将问题分节为对象集合的一种合理方式，还有助于提高对象的内聚性。</strong></li></ul><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对象导论&quot;&gt;&lt;a href=&quot;#对象导论&quot; class=&quot;headerlink&quot; title=&quot;对象导论&quot;&gt;&lt;/a&gt;对象导论&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;程序可以通过添加新类型的对象使得自身使用于某个特定的问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以通过构建包含现
      
    
    </summary>
    
      <category term="Java" scheme="http://codinglembre.top/categories/Java/"/>
    
    
      <category term="JavaSE" scheme="http://codinglembre.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>Java学习之阅读Java编程思想</title>
    <link href="http://codinglembre.top/2018/10/04/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%98%85%E8%AF%BBJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    <id>http://codinglembre.top/2018/10/04/Java学习之阅读Java编程思想/</id>
    <published>2018-10-03T19:16:15.000Z</published>
    <updated>2018-10-03T19:35:18.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象导论"><a href="#对象导论" class="headerlink" title="对象导论"></a>对象导论</h3><ul><li>程序可以通过添加新类型的对象使得自身使用于某个特定的问题。</li><li><strong>可以通过构建包含现有对象的方式来创建新的对象。以此在程序中构建复杂的体系，同时将其复杂性隐藏在对象简单性的背后</strong></li><li>某一特定类型的所有对象可以接受同样的消息，这种可替代性是OOP中最强有力的概念</li><li>每一个对象都能和其他对象区分开来，具体说来，在内存中有一个唯一地址。</li><li>程序通过定义类来适应问题，而不再使用现有的表示机器中存储单元的数据类型。</li><li><strong>将对象看做服务提供者，这个对象又需要哪些服务提供者？这是一种将问题分节为对象集合的一种合理方式，还有助于提高对象的内聚性。</strong></li><li></li></ul><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对象导论&quot;&gt;&lt;a href=&quot;#对象导论&quot; class=&quot;headerlink&quot; title=&quot;对象导论&quot;&gt;&lt;/a&gt;对象导论&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;程序可以通过添加新类型的对象使得自身使用于某个特定的问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以通过构建包含现
      
    
    </summary>
    
      <category term="Java" scheme="http://codinglembre.top/categories/Java/"/>
    
    
      <category term="JavaSE" scheme="http://codinglembre.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习之JSP</title>
    <link href="http://codinglembre.top/2018/10/04/JavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8BJSP/"/>
    <id>http://codinglembre.top/2018/10/04/JavaWeb学习之JSP/</id>
    <published>2018-10-03T16:44:50.000Z</published>
    <updated>2018-10-04T02:30:23.278Z</updated>
    
    <content type="html"><![CDATA[<p>JSP，即Java Server Pages，和Servlet一样，都是<strong>SUN公司定义的一种用于开发动态WEB资源的技术的标准，在服务器端执行的动态网页。</strong>JSP虽然像是在写HTML，但是JSP允许在页面中嵌套Java代码，或者利用某个标签表示Java代码（EL与jstl）。这就使得我们在<strong>写JSP时能够获取请求对象Request和响应对象Response等这样的web开发常用对象，实现与浏览器的交互。</strong></p><h3 id="JSP页面元素简介及page指令"><a href="#JSP页面元素简介及page指令" class="headerlink" title="JSP页面元素简介及page指令"></a>JSP页面元素简介及page指令</h3><p>page指令:通常位于jsp页面的顶端，同一个页面可以有多个page指令。<br><img src="https://i.imgur.com/TSgAZI7.png" alt=""></p><h3 id="JSP页面的生命周期"><a href="#JSP页面的生命周期" class="headerlink" title="JSP页面的生命周期"></a>JSP页面的生命周期</h3><p><img src="https://i.imgur.com/qwYKNVD.png" alt=""><br><img src="https://i.imgur.com/mhggkB5.png" alt=""></p><p><strong>每个客户端对应一个线程，这种多线程的处理方式，大大地降低了系统的资源需求，提高了系统的并发性，减少了响应时间。但是使用多线程编程就要注意线程带来的同步问题。(临界资源的共享和保护等等)</strong></p><h3 id="JSP内置域对象"><a href="#JSP内置域对象" class="headerlink" title="JSP内置域对象"></a>JSP内置域对象</h3><p>1.out对象:JspWriter的实例，是向客户端输出内容的常用的对象。<br>先了解一下什么是缓冲区:内存一块用于保存临时数据的区域<br><img src="https://i.imgur.com/zVk3D3O.png" alt=""><br>2.request和response对象<br>先了解一下Get和Post的区别:</p><ul><li>get：以明文的方式通过URL提交数据，数据在URL中可以看到。提交的数据最多不超过2KB。<strong>安全性低但效率比post方式高、适合提交数据量不大，安全性不高的数据。比如：搜索、查询等功能。</strong></li><li>post：<strong>将用户提交的信息封装在HTML、HEADER内。适合提交数据量大，安全性高的用户信息。比如：注册、修改、上传等功能。</strong><br><img src="https://i.imgur.com/c7sl04S.png" alt=""><br><img src="https://i.imgur.com/bPqdyGv.png" alt=""><br><strong>注意URL传递中文参数乱码的问题无法通过req.setCharacterEncoding解决，需要到Tomcat配置文件中设置修改tomcat中的server.xml 在端口号后，增加URIEncoding=”utf-8”;</strong><br><strong>response对象虽然重要，但是实际上JSP很少用他。*</strong><br><img src="https://i.imgur.com/pAgkss8.png" alt=""><br><strong>特别注意:PrintWriter向客户端输出字符串对象， 而且先于jspWriter，使用out.flush()来避免 PrintWriter response.getWriter()*</strong><br><img src="https://i.imgur.com/NVTxAW7.png" alt=""><br><strong>特别注意:对象是否保存！！</strong></li></ul><p>3.session:是<strong>客户端与服务器端建立的一个会话并保存在服务器中，和用户意义对应，session对象保存在服务器端的同时服务器还会给客户端发送一个带有JSESSIONID的Cookie。它实际是一个特定的时间概念</strong><br><img src="https://i.imgur.com/e0qWXdF.png" alt=""></p><p><strong>注意在之前讲过的session中的生命周期中，原有会话还在服务器端，只是再也没有客户端会携带它然后交于服务端进行校验</strong><br><img src="https://i.i8mgur.com/Gw0mfkA.png" alt=""><br>4.application（<strong>相当于Java中的全局变量，是ServletContext类的实例，服务器的关闭启动决定他的周期</strong>）<br><img src="https://i.imgur.com/5eNbRcK.png" alt=""><br><img src="https://i.imgur.com/Yf54HFW.png" alt=""><br>5.page对象（<strong>指向当前JSP页面本身，相当于this,，是Object类的实例）<br><img src="https://i.imgur.com/lTc2tZX.png" alt=""><br>6.pageContext和Config对象</strong>pageContext 用于获取其他对象，功能的集大成者<strong><br><img src="https://i.imgur.com/AILNWGT.png" alt=""><br>pageContext常用API如下:<br><img src="https://i.imgur.com/OpzsHxG.png" alt=""><br>Config对象及常用API如下:<br><img src="https://i.imgur.com/ISekqRE.png" alt=""><br>7.exception对象<br><img src="https://i.imgur.com/yeUeARD.png" alt=""></strong>但是需要在page指令中写属性errorpage=“出错跳转到的页面” 2.在跳转到的错误处理页面page指令中输入属性isErrorPage=“true”**</p><h3 id="JavaBeans"><a href="#JavaBeans" class="headerlink" title="JavaBeans"></a>JavaBeans</h3><p><strong>解决了代码重复编写，减少代码冗余，功能区分明确，提高了代码的维护性</strong><br>设计原则:</p><ul><li>公有类</li><li>属性私有</li><li>无参的构造方法</li><li>setter/getter方法</li></ul><h3 id="JSP动作元素"><a href="#JSP动作元素" class="headerlink" title="JSP动作元素"></a>JSP动作元素</h3><p>其实就是一个标签，可以有属性和可选内容:<br><img src="https://i.imgur.com/INmKtx0.png" alt=""></p><ul><li><p>userBean创建JavaBeans语法</p><pre><code>&lt;body&gt;&lt;jsp:useBean id=&quot;myUsers&quot; class=&quot;com.po.Users&quot; scope=&quot;page&quot;/&gt;用户名:&lt;%= myUsers.getUsername()%&gt;&lt;br&gt;密码：&lt;%= myUsers.getPassword()%&gt;&lt;br&gt;&lt;/body&gt;</code></pre></li><li><p>setProperty用法<br><img src="https://i.imgur.com/89YkdNo.png" alt=""></p><ul><li><p>1.根据表单自动匹配所有属性</p><pre><code>&lt;jsp:setProperty name=&quot;myUsers&quot; property=&quot;*&quot;/&gt;</code></pre></li><li><p>2.根据表单自动匹配部分属性</p><pre><code>&lt;jsp:setProperty name=&quot;myUsers&quot; property=&quot;username&quot;/&gt;</code></pre></li><li><p>3.跟表单无关，手工赋值给属性</p><pre><code>&lt;jsp:setProperty name=&quot;myUsers&quot; property=&quot;username&quot; value=&quot;admin&quot;/&gt;</code></pre></li><li><p>4.通过URL传参数来给属性赋值(需要在表单的action后面添加参数)</p><p>   &lt;jsp:setProperty name=”myUsers” property=”password” param=”myPass”/&gt;</p></li></ul></li></ul><form name="loginForm" action="dologin.jsp?myPass= 888888" method="post"><ul><li><p>getProperty用法(<strong>代替了传统表达式和内置对象来获取用户名和密码)</strong></p><pre><code>&lt;jsp:getProperty name=&quot;myUsers&quot; property=&quot;username&quot;/&gt;</code></pre></li></ul><h3 id="JSP四个作用域对象范围"><a href="#JSP四个作用域对象范围" class="headerlink" title="JSP四个作用域对象范围"></a>JSP四个作用域对象范围</h3><p><img src="https://i.imgur.com/HG1zJN6.png" alt=""></p><p><strong>page仅在当前页面有效，哪怕用全局对象pageContext在另一个页面也获取不到值</strong></p><h3 id="http协议的无状态性"><a href="#http协议的无状态性" class="headerlink" title="http协议的无状态性"></a>http协议的无状态性</h3><p><strong>同一个浏览器多次发送请求给服务器，服务器并不会知道这是同一个浏览器，即无法保存用户状态。</strong><br>由于这个特性，提供了两大保存用户转状态的机制：</p><ul><li>session</li><li><p>cookie: <strong>Web服务器保存在客户端的一系列文本信息。但是容易泄露用户信息</strong></p><ul><li>购物车</li><li>判断注册用户是否已经登录网站</li></ul></li></ul><p><img src="https://i.imgur.com/iXXXQVM.png" alt=""><br><img src="https://i.imgur.com/GD3k516.png" alt=""><br><strong>注意设置完cookie后，比如遍历cookie时，当存在对应的用户cookie时，用户勾选了不记住登录状态，那么就要cookie失效，即cookie.setMaxAge(0)（马上删除这个cookie）,最后别忘记response.addCookie(cookie),否则不起作用</strong><br><img src="https://i.imgur.com/MsHeI7S.png" alt=""><br>是否保存过这个用户的cookie（<strong>如果用户勾选了不保存cookie，那么已经删除，这里就不会遍历到关于用户名和密码的cookie</strong>）<br><strong>解决Cookie无法保存中文字符串的问题 </strong></p><pre><code>String username= URLEncode.encode(request.getParameter(&quot;username&quot;),&quot;utf-8&quot;)</code></pre><p><strong>解决Cookie无法读取中文字符串的问题 </strong></p><pre><code>username= URLEncode.decode(c.getValue(),&quot;utf-8&quot;)</code></pre><h3 id="session和cookie对比"><a href="#session和cookie对比" class="headerlink" title="session和cookie对比"></a>session和cookie对比</h3><p><img src="https://i.imgur.com/wzdFsDc.png" alt=""></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul></form>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSP，即Java Server Pages，和Servlet一样，都是&lt;strong&gt;SUN公司定义的一种用于开发动态WEB资源的技术的标准，在服务器端执行的动态网页。&lt;/strong&gt;JSP虽然像是在写HTML，但是JSP允许在页面中嵌套Java代码，或者利用某个标签表
      
    
    </summary>
    
      <category term="前端" scheme="http://codinglembre.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaWeb" scheme="http://codinglembre.top/tags/JavaWeb/"/>
    
      <category term="JSP" scheme="http://codinglembre.top/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb之HTML+CSS笔记</title>
    <link href="http://codinglembre.top/2018/10/03/JavaWeb%E4%B9%8BHTML%E7%AC%94%E8%AE%B0/"/>
    <id>http://codinglembre.top/2018/10/03/JavaWeb之HTML笔记/</id>
    <published>2018-10-03T03:42:44.000Z</published>
    <updated>2018-10-03T18:00:02.192Z</updated>
    
    <content type="html"><![CDATA[<p><strong>HTML是网页内容的载体。HTML是静态页面，浏览器就可以解析。而JSP是动态页面，需要服务器去解析。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等. </strong>CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。由于前端并不是我的主要学习方向，但是在学习到JavaWeb时会用到，但是如果不懂，那也是比较麻烦的，所以这里只做简单的学习。</p><a id="more"></a><h3 id="html文件基本结构"><a href="#html文件基本结构" class="headerlink" title="html文件基本结构"></a>html文件基本结构</h3><pre><code>&lt;html&gt;    &lt;head&gt;...&lt;/head&gt;    &lt;body&gt;...&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>html文件由根标签,头部标签,网页内容标签组成。</strong></p><h3 id="一般的标签以及语法"><a href="#一般的标签以及语法" class="headerlink" title="一般的标签以及语法"></a>一般的标签以及语法</h3><ul><li>标题标签：&lt;h1&gt;标题&lt;/h1&gt; </li><li>段落标签：&lt;p&gt;段落&lt;/p&gt; </li><li>图片标签：&lt;img src=”1.jpg”&gt;</li><li><strong>&lt;body&gt;标签，网页上显示的内容放在这里</strong></li><li>加入强调语气，使用&lt;strong&gt;和&lt;em&gt;标签</li><li><strong>使用&lt;span&gt;标签为文字设置单独样式，需要与&lt;style&gt;标签配合使用</strong></li><li>&lt;q&gt;标签，短文本引用</li><li>&lt;blockquote&gt;标签，长文本引用</li><li>为你的网页中添加一些空格:语法&amp;nbsp+;</li><li>&lt;hr&gt;标签，添加水平横线</li><li>想加入一行代码吗？使用&lt;code&gt;标签</li><li>使用&lt;pre&gt;标签为你的网页加入大段代码</li><li>ul-li是没有前后顺序的信息列表。</li><li>使用ol，在网页中展示有前后顺序的信息列表</li></ul><p><strong>标签与标签之间是可以嵌套的，但先后顺序必须保持一致</strong>，如：&lt;div&gt;里嵌套&lt;p&gt;，那么&lt;/p&gt;必须放在&lt;/div&gt;的前面。<br><strong>HTML标签不区分大小写，</strong>&lt;h1&gt;和&lt;H1&gt;是一样的，但建议小写，因为大部分程序员都以小写为准。</p><h3 id="重要标签以及属性"><a href="#重要标签以及属性" class="headerlink" title="重要标签以及属性"></a>重要标签以及属性</h3><ul><li><strong>在网页制作过程过中，可以把一些独立的逻辑部分划分出来，放在一个div标签中，这个标签的作用就相当于一个容器</strong></li><li>表格的四个标签：table、tbody、tr、th、td。<strong>table表格在没有添加css样式之前，在浏览器中显示是没有表格线的，th标签中的文本默认为粗体并且居中显示</strong></li><li><p>用css样式，为表格加入边框</p><p>  &lt;style type=”text/css”&gt;</p><pre><code>table tr td,th{border:1px solid #000;}</code></pre><p>  &lt;/style&gt;</p></li><li><p>caption标签，为表格添加标题和摘要,<strong>摘要summary标签的内容是不会在浏览器中显示出来的。它的作用是增加表格的可读性(语义化）</strong></p><p>  &lt;table summary=”本表格记录2012年到2013年库存记录，记录包括U盘和耳机库存量”&gt;</p><pre><code>&amp;lt;caption&gt;2012年到2013年库存记录&lt;/caption&gt;&amp;lt;tr&gt;      &amp;lt;th&gt;产品名称 &lt;/th&gt;      &amp;lt;th&gt;品牌 &lt;/th&gt;  &amp;lt;th&gt;库存量（个） &lt;/th&gt;</code></pre><p>  &lt;th&gt;入库时间 </p><pre><code>&amp;lt;/tr&gt;</code></pre><p>  &lt;/table&gt;</p></li><li><p>使用a标签可实现超链接，里面<strong>title属性的作用，鼠标滑过链接文字时会显示这个属性的文本内容</strong>，target=”_blank”设置超链接在新的浏览器窗口中打开。</p></li></ul><h3 id="表单标签以及属性，与用户交互"><a href="#表单标签以及属性，与用户交互" class="headerlink" title="表单标签以及属性，与用户交互"></a>表单标签以及属性，与用户交互</h3><p><strong>所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在 <form></form> 标签之间（否则用户输入的信息可提交不到服务器上哦！），特别重要</strong><br>1.文本输入框、密码输入框<br>语法:</p><pre><code>&lt;form&gt;   &lt;input type=&quot;text/password&quot; name=&quot;名称&quot; value=&quot;文本&quot; /&gt;&lt;/form&gt;</code></pre><p><strong>name：为文本框命名，以备后台程序ASP 、PHP引用</strong>。value：为文本输入框设置默认值。(一般起到提示作用)<br>2.文本域，支持多行文本输入</p><pre><code>&lt;textarea  rows=&quot;行数&quot; cols=&quot;列数&quot;&gt;文本&lt;/textarea&gt;</code></pre><p>3.使用单选框、复选框，让用户选择</p><pre><code>&lt;input   type=&quot;radio/checkbox&quot;   value=&quot;值&quot;    name=&quot;名称&quot;   checked=&quot;checked&quot;/&gt;</code></pre><p>4.使用下拉列表框，节省空间</p><pre><code>&lt;select&gt;  &lt;option value=&quot;看书&quot;&gt;看书&lt;/option&gt;  &lt;option value=&quot;旅游&quot;selected=&quot;selected&quot;&gt;旅游&lt;/option&gt;  &lt;option value=&quot;运动&quot;&gt;运动&lt;/option&gt;  &lt;option value=&quot;购物&quot;&gt;购物&lt;/option&gt;&lt;/select&gt;</code></pre><p><strong>selected=”selected”：设置selected=”selected”属性，则该选项就被默认选中</strong><br>5.使用下拉列表框进行多选，<strong>设置multiple=”multiple”属性，就可以实现多选功能</strong></p><pre><code>&lt;select multiple=&quot;multiple&quot;&gt;  &lt;option value=&quot;看书&quot;&gt;看书&lt;/option&gt;  &lt;option value=&quot;旅游&quot;&gt;旅游&lt;/option&gt;  &lt;option value=&quot;运动&quot;&gt;运动&lt;/option&gt;  &lt;option value=&quot;购物&quot;&gt;购物&lt;/option&gt;&lt;/select&gt;</code></pre><p>6.使用提交按钮，提交数据</p><pre><code>&lt;input   type=&quot;submit&quot;   value=&quot;提交&quot;&gt;</code></pre><p>7.<strong>使用重置按钮，重置表单信息为初始状态</strong></p><pre><code>&lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;</code></pre><p>8.<strong>form表单中的label标签，标签的 for 属性中的值应当与相关控件的 id 属性值一定要相同。</strong></p><pre><code>&lt;form&gt;      &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;      &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;male&quot; /&gt;&lt;/form&gt;</code></pre><h3 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h3><p><strong>CSS可以让不同网页位置的文字有着统一的字体、字号或者颜色等。css 样式由选择符和声明组成，而声明又由属性和值组成</strong>，如下图所示：</p><p><img src="http://img.mukewang.com/52fde5c30001b0fe03030117.jpg" alt=""></p><blockquote><p>最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号。</p></blockquote><p>1.<strong>内联式css样式，直接写在现有的HTML标签中</strong></p><pre><code>&lt;p style=&quot;color:red&quot;&gt;这里文字是红色。&lt;/p&gt;&lt;p style=&quot;color:red;font-size:12px&quot;&gt;这里文字是红色。&lt;/p&gt;</code></pre><p>2.<strong>嵌入式css样式，写在当前的文件中</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;span{    color:red;    }&lt;/style&gt;</code></pre><p>3.<strong>外部式css样式，写在单独的一个文件中</strong></p><pre><code>&lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</code></pre><ul><li>1.css样式文件名称以有意义的英文字母命名，如 main.css。</li><li>2.<strong>rel=”stylesheet” type=”text/css” 是固定写法不可修改。</strong></li><li>3.<strong>link标签位置一般写在head标签之内。</strong></li></ul><p><strong> 优先级:相同权值下，就近原则</strong></p><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><pre><code>选择器{    样式;}</code></pre><p>包括标签选择器，类选择器，ID选择器，子选择器，包含选择器，通用选择器<br>类选择器和ID选择器的区别:</p><pre><code>.stress{    color:red;}.bigsize{    font-size:25px;}#stressid{    color:red;}#bigsizeid{    font-size:25px;}</code></pre><h3 id="CSS继承，层叠和特殊性"><a href="#CSS继承，层叠和特殊性" class="headerlink" title="CSS继承，层叠和特殊性"></a>CSS继承，层叠和特殊性</h3><p>1.<strong>继承CSS的某些样式是具有继承性的，注意只是有些</strong>，比如</p><pre><code>p{color:red;}&lt;p&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt;</code></pre><p>2.特殊性，即<strong>CSS样式矛盾</strong>有的时候我们为同一个元素设置了不同的CSS样式代码，那么元素会启用哪一个CSS样式呢?这跟权值有关</p><blockquote><p><strong>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为10,继承也有权值但很低，有的文献提出它只有0.1</strong></p></blockquote><p>3.<strong>层叠，即CSS样式覆盖,规则为后面的样式会覆盖前面的样式。</strong></p><h3 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h3><p>符合内容的结构化（内容语义化），选择合适的标签（代码语义化）<br>4.<strong>设置最高权值,使用!important来解决。</strong>:</p><pre><code>p{color:red!important;}p{color:green;}&lt;p class=&quot;first&quot;&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt;</code></pre><h3 id="CSS排版之文字与段落"><a href="#CSS排版之文字与段落" class="headerlink" title="CSS排版之文字与段落"></a>CSS排版之文字与段落</h3><p>####文字排版<br>1.字体。<strong>不要设置不常用的字体，因为如果用户本地电脑上如果没有安装你设置的字体，就会显示浏览器默认的字体</strong></p><pre><code>body{font-family:&quot;宋体&quot;;}</code></pre><p>2.字号、颜色。</p><pre><code>body{font-size:12px;color:#666}</code></pre><p>3.粗体</p><pre><code>p span{font-weight:bold;}</code></pre><p>4.斜体</p><pre><code>p a{font-style:italic;}</code></pre><p>5.下划线</p><pre><code>p a{text-decoration:underline;}</code></pre><p>6.删除线</p><pre><code>.oldPrice{text-decoration:line-through;}</code></pre><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>1.缩进，<strong>中文文字中的段前习惯空两个文字的空白，这个特殊的样式可以用下面代码来实现：</strong></p><pre><code>p{text-indent:2em;}</code></pre><p>2.行间距（行高）</p><pre><code>p{line-height:1.5em;}</code></pre><p>3.中文字间距、字母间距(就是文字间距)</p><pre><code>h1{letter-spacing:50px;}...&lt;h1&gt;了不起的盖茨比&lt;/h1&gt;</code></pre><p>4.对齐，<strong> 想为块状元素中的文本、图片设置居中样式？注意要设置宽度和高度</strong></p><pre><code>h1{    width:100px;    height: 50px;       text-align:center;}&lt;h1&gt;了不起的盖茨比&lt;/h1&gt;</code></pre><h3 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h3><p>常用的块状元素有：</p><pre><code>&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;</code></pre><p>常用的内联元素有：</p><pre><code>&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;</code></pre><p>常用的内联块状元素有：</p><pre><code>&lt;img&gt;、&lt;input&gt;</code></pre><p>1.<strong>元素分类–块级元素</strong><br><strong>如何将内联元素a转换为块状元素？</strong></p><pre><code>a{display:block;}</code></pre><p><strong>块状元素也可以通过代码display:inline将元素设置为内联元素。</strong></p><pre><code>div{ display:inline; }&lt;div&gt;我要变成内联元素&lt;/div&gt;</code></pre><p>内联元素特点：</p><ul><li><strong>和其他元素都在一行上；</strong></li><li><strong>元素的高度、宽度及顶部和底部边距不可设置；</strong></li><li><strong>元素的宽度就是它包含的文字或图片的宽度，不可改变。</strong></li></ul><p>Deom:<br><img src="https://i.imgur.com/sZxpve6.png" alt=""></p><p>inline-block 元素特点：</p><ul><li><strong>和其他元素都在一行上；</strong></li><li><strong>元素的高度、宽度、行高以及顶和底边距都可设置。</strong></li></ul><h3 id="CSS盒模型和布局模型"><a href="#CSS盒模型和布局模型" class="headerlink" title="CSS盒模型和布局模型"></a>CSS盒模型和布局模型</h3><p>1.边框</p><pre><code>div{border:2px  solid  red;}</code></pre><p>2.<strong>单独设置上下左右边框</strong></p><pre><code>li{border-bottom:1px dotted #ccc;}</code></pre><p>3.盒模型–宽度和高度<br><strong>一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。</strong></p><p>4.盒模型–填充(padding)<br><strong>显示在左上角不是padding的效果，而是html代码默认的就是从显示器的左上角开始显示，而整个HTML文档只有一个div元素，当然就显示在左上角了</strong><br><img src="https://i.imgur.com/FseuQai.png" alt=""><br>5.盒模型–边界<br><img src="https://i.imgur.com/RAdqNxE.png" alt=""></p><h3 id="CSS布局模型"><a href="#CSS布局模型" class="headerlink" title="CSS布局模型"></a>CSS布局模型</h3><ul><li>流动模型（Flow）</li><li>浮动模型 (Float)</li><li>层模型（Layer）</li></ul><p>1.流动模型<br><strong>块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。</strong><br><img src="https://i.imgur.com/hzNIeXe.png" alt=""></p><p><strong>，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示</strong><br>2.浮动模型<br><strong>块状元素这么霸道都是独占一行，如果现在我们想让两个块状元素并排显示</strong><br><img src="https://i.imgur.com/0bsLYzA.png" alt=""><br>3.层模型<br><strong>每个图层能够精确定位操作，但在网页设计领域，由于网页大小的活动性，层布局没能受到热捧</strong><br>1.层模型–绝对定位<br>绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位<br><img src="https://i.imgur.com/0NO1Zur.png" alt=""><br>2.层模型–相对定位<br>，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动<br><img src="https://i.imgur.com/ZIMbD7g.png" alt=""><br>3.层模型–固定定位<br>fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响<br><img src="https://i.imgur.com/Xhdb6Xi.png" alt=""></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;HTML是网页内容的载体。HTML是静态页面，浏览器就可以解析。而JSP是动态页面，需要服务器去解析。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等. &lt;/strong&gt;CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。由于前端并不是我的主要学习方向，但是在学习到JavaWeb时会用到，但是如果不懂，那也是比较麻烦的，所以这里只做简单的学习。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://codinglembre.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaWeb" scheme="http://codinglembre.top/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC学习之快速入门</title>
    <link href="http://codinglembre.top/2018/10/03/SpringMVC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://codinglembre.top/2018/10/03/SpringMVC学习之快速入门/</id>
    <published>2018-10-02T17:22:18.000Z</published>
    <updated>2018-10-03T03:28:21.178Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-MVC框架"><a href="#Spring-MVC框架" class="headerlink" title="Spring MVC框架"></a>Spring MVC框架</h3><h4 id="Spring-MVC介绍"><a href="#Spring-MVC介绍" class="headerlink" title="Spring MVC介绍"></a>Spring MVC介绍</h4><p><strong>SpringMVC和Struts2都属于表现层的框架，它是Spring框架的一个模块，提供web层解决方案，我们可以从Spring的整体结构中看得出来:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%887.56.09.png" alt=""></p><h4 id="MVC在b-s系统的应用"><a href="#MVC在b-s系统的应用" class="headerlink" title="MVC在b/s系统的应用"></a>MVC在b/s系统的应用</h4><p><strong>mvc是一个设计模式，在b/s系统(即浏览器和服务器端，在客户机端不用装专门的软件，只要一个浏览器即可)</strong>的应用如图:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%887.58.00.png" alt=""><br>解释如下:</p><ul><li>1.用户发起request请求至控制器(Controller),控制接收用户请求的数据，委托给模型进行处理。</li><li>2.控制器通过模型(Model)处理数据并得到处理结果，模型通常是指业务逻辑(jsp、dao、service)。</li><li>3.模型处理结果返回给控制器。</li><li>4.控制器将模型数据在视图(View)中展示，web中模型无法将数据直接在视图上显示，需要通过控制器完成。如果在C/S应用中模型是可以将数据在视图中展示的。</li><li>5.控制器将视图response响应给用户，通过视图展示给用户要的数据或处理结果。</li></ul><h4 id="Spring-mvc架构"><a href="#Spring-mvc架构" class="headerlink" title="Spring mvc架构"></a>Spring mvc架构</h4><p>1.架构图<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%888.04.54.png" alt=""><br>2.架构流程</p><ul><li>1.用户发送请求至前端控制器DispatcherServlet</li><li>2.DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>3.处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li><li>4.DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</li><li>5.执行处理器(Controller，也叫后端控制器)。</li><li>6.Controller执行完成返回ModelAndView</li><li>7.HandlerAdapter将controller执行结果ModelAndView返回</li><li>8.DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>9.ViewReslover解析后返回具体View</li><li>10.DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</li><li>11.DispatcherServlet响应用户</li></ul><p>3.架构中涉及的组件说明</p><ul><li>1.DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。由框架实现</li><li>2.HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。由框架实现</li><li>3.Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</li><li>4.HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。</li><li>5.ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</li></ul><h3 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p><strong>实现商品列表的查询并在页面中显示。这里由于Spring mvc不涉及对数据库的操作，所以我们在程序中的数据就用静态数据生成。</strong></p><h4 id="第一步-前端控制器的配置"><a href="#第一步-前端控制器的配置" class="headerlink" title="第一步:前端控制器的配置"></a>第一步:前端控制器的配置</h4><p>在WEB-INF/web.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;     version=&quot;3.1&quot;&gt;&lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!--加载springmvc配置文件--&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;!--配置文件的地址        如果不配置contextConfigLocation，默认查找的配置文件名称是classpath下的:servlet名称+&quot;-servlet.xml&quot;        即springmvc-servlet.xml--&gt;        &lt;param-value&gt;springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;!--可以配置/：此工程所有的请求全部由springmvc解析，此种方式可以实现RESTful方式，需要特殊处理对静态文件的解析不能由springmvc解析    可以配置*.do或者*.action,所有请求的url扩展名为.do或.action由springmvc解析，此中方法常用    不可以配置/*,如果配置/*,返回jsp也由springmvc解析，这是不对的--&gt;    &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h4 id="第二步-Spring-MVC配置文件"><a href="#第二步-Spring-MVC配置文件" class="headerlink" title="第二步:Spring MVC配置文件"></a>第二步:Spring MVC配置文件</h4><p><strong>在web目录下创建Spring MVC的配置文件springmvc.xml，以后需要在里面配置Spring MVC架构三大组件(处理器映射器、适配器、视图解析器)，里面根标签的内容同Spring的配置文件:</strong></p><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd    http://www.springframework.org/schema/mvc    http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd    http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context-3.2.xsd    http://www.springframework.org/schema/aop    http://www.springframework.org/schema/aop/spring-aop-3.2.xsd    http://www.springframework.org/schema/tx    http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;&lt;/beans&gt;</code></pre><h4 id="第三步-配置处理器映射器"><a href="#第三步-配置处理器映射器" class="headerlink" title="第三步:配置处理器映射器"></a>第三步:配置处理器映射器</h4><p><strong>因为对于用户发起的request请求，前端控制器首先会请求HandlerMapping处理器映射器来查找Handler，所以我们首先配置它，在springmvc.xml中加入如下内容:</strong></p><pre><code>&lt;!--配置处理器映射器springmvc框架根据HandlerMapping接口判断是否是处理器映射器--&gt;&lt;!--根据bean的name进行查找Handler,将action的url配置在bean的name中--&gt;&lt;bean    class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;</code></pre><p><strong>BeanNameUrlHandlerMapping:表示将定义的Bean名字作为请求的url，需要将编写的controller在spring容器中进行配置，且指定bean的name为请求的url，且必须以.action结尾。</strong></p><h4 id="第四步-配置处理器适配器"><a href="#第四步-配置处理器适配器" class="headerlink" title="第四步:配置处理器适配器"></a>第四步:配置处理器适配器</h4><p>处理器映射器将查找到的Handler返回给DispatcherServlet后，DispatcherServlet会调用适配器执行Handler，通过适配器去扩展对不同Handler的执行。所以我们再配置它,在springmvc.xml中添加如下内容:</p><pre><code>&lt;!--配置处理器适配器springmvc框架根据HandlerAdapter接口判断是否是处理器适配器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;</code></pre><p>SimpleControllerHandlerAdapter:即简单控制器处理适配器，所有实现了org.springframework.web.servlet.mvc.Controller 接口的Bean作为Springmvc的后端控制器。</p><h4 id="第五步-后端控制器的编写"><a href="#第五步-后端控制器的编写" class="headerlink" title="第五步:后端控制器的编写"></a>第五步:后端控制器的编写</h4><p>DispatcherServlet通过处理器适配器找到后端控制器Handler，所以我们需要进行Handler的编写,在src包下新建ItemController.java，内容如下:</p><pre><code>package controller;public class ItemController1 implements Controller{@Overridepublic ModelAndView handleRequest(HttpServletRequest httpServletRequest,                                  HttpServletResponse httpServletResponse) throws Exception {    //使用静态的数据将商品信息显示在jsp页面    List&lt;Items&gt; itemsList = new ArrayList&lt;&gt;();    Items items_1 = new Items();    items_1.setName(&quot;联想笔记本&quot;);    items_1.setPrice(6000f);    items_1.setCreatetime(new Date());    items_1.setDetail(&quot;ThinkPad T430 联想笔记本电脑！&quot;);    Items items_2 = new Items();    items_2.setName(&quot;苹果手机&quot;);    items_2.setPrice(5000f);    items_2.setDetail(&quot;iphone6苹果手机！&quot;);    itemsList.add(items_1);    itemsList.add(items_2);    ModelAndView modelAndView=new ModelAndView();    modelAndView.addObject(&quot;itemsList&quot;,itemsList);    modelAndView.setViewName(&quot;/WEB-INF/jsp/itemsList.jsp&quot;);//指定用户访问的jsp页面地址    return modelAndView;}}</code></pre><p>数据我们采用静态数据的输入，当然我们还需要创建Items.java这个pojo对象，就是上一篇文章中我们用到的.java文件。</p><h4 id="第六步-后端控制器的配置"><a href="#第六步-后端控制器的配置" class="headerlink" title="第六步:后端控制器的配置"></a>第六步:后端控制器的配置</h4><pre><code>&lt;!--配置Handler由于使用了BeanNameUrlHandlerMapping处理映射器，所以name要配置为url--&gt;&lt;bean name=&quot;/itemList.action&quot; class=&quot;controller.ItemController1&quot;&gt;&lt;/bean&gt;</code></pre><p>name=”/itemsList.action”:前边配置的处理器映射器为BeanNameUrlHandlerMapping，如果请求的URL为“上下文/itemsList.action”将会成功映射到ItemController1控制器。</p><h4 id="配置视图解析器"><a href="#配置视图解析器" class="headerlink" title="配置视图解析器"></a>配置视图解析器</h4><p><strong>Handler执行完成后给处理器适配器返回一个ModelAndView对象，</strong>它是Spring MVC的一个对象，用于对Model和View进行封装。然后处理器适配器又将这个对象返回给DispatcherServlet,DispatcherServlet调用视图解析器进行视图解析，所以这里我们要配置视图解析器，在springmvc.xml中添加如下内容:<br>    <!--配置视图解析器    要求将jstl的包加到classpath--><br>    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"><br>    </bean><br>然后部署服务器，在浏览器中输入<a href="http://localhost:8080/SpringMvc/itemList.action后便可以看到如下页面" target="_blank" rel="noopener">http://localhost:8080/SpringMvc/itemList.action后便可以看到如下页面</a>:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%888.47.32.png" alt=""></p><p>扩展:对于前端控制器DispatcherServlet,我有必要多说几句，<strong>在spring-webmvc.jar包中有一个DispatcherServlet.properties文件</strong>，内容如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%886.51.45.png" alt=""><br>里面包含一些默认的组件例如处理器映射器、处理器适配器等，当程序启动时，DispatcherServlet会自动加载DispatcherServlet.properties配置文件，从而默认加载各个组件，所以如果我们在springmvc.xml中配置了处理器映射器和处理器适配器，那程序就以springmvc.xml中的配置信息为主。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring-MVC框架&quot;&gt;&lt;a href=&quot;#Spring-MVC框架&quot; class=&quot;headerlink&quot; title=&quot;Spring MVC框架&quot;&gt;&lt;/a&gt;Spring MVC框架&lt;/h3&gt;&lt;h4 id=&quot;Spring-MVC介绍&quot;&gt;&lt;a href=&quot;#S
      
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="SpringMVC" scheme="http://codinglembre.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习之快速入门</title>
    <link href="http://codinglembre.top/2018/10/03/Spring%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://codinglembre.top/2018/10/03/Spring学习之快速入门/</id>
    <published>2018-10-02T16:10:29.000Z</published>
    <updated>2018-10-02T17:23:17.644Z</updated>
    
    <content type="html"><![CDATA[<p>当客户端向服务器发出请求时，服务器把得到的请求发送给控制器Servlet，而在Servlet中需要创建Service对象来调用业务层相关功能(故说控制器层Servlet依赖于业务层Service),而在Service中又需要创建数据库层DAO对象来对数据库进行操作(故说业务层Service依赖于数据库层DAO)。</p><p>思考:针对上述过程，我们需要考虑这样几个问题。1.Servlet、Service以及Dao对象的创建时间、创建数量。2.<strong>Servlet、Service以及Dao之间的依赖关系。如何处理这些问题呢</strong>？<strong>Spring就是用来处理对象的创建、以及对象之间依赖关系的一个开发框架</strong>。它打破了我们传统开发的观念，我们不再需要像以前那样在具体的类中创建具体的对象，而是将<strong>对象的创建交给它去完成</strong>。它是我们所要学习的框架中最重要的框架，请务必好好学习。</p><h3 id="Spring框架中的专业术语"><a href="#Spring框架中的专业术语" class="headerlink" title="Spring框架中的专业术语"></a>Spring框架中的专业术语</h3><h4 id="组件／框架设计"><a href="#组件／框架设计" class="headerlink" title="组件／框架设计"></a>组件／框架设计</h4><pre><code>- 侵入式设计:对现有类的结构有影响，即需要实现或继承某些特定类。 如Struts框架。- **非侵入式设计:引入了框架，对现有的类结构没有影响。如Spring框架**／Hibernate框架。</code></pre><h4 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h4><p>Inversion On Control，简称IOC。对象的创建交给外部容器自动完成，这个就叫做控制反转。(有控制反转就有控制正转，<strong>控制正转:对象的创建由我们自己创建</strong>)</p><p>依赖注入dependency injection,简称DI，用于处理对象间的依赖关系。</p><p><strong>二者区别:控制反转(IOC):解决对象创建的问题，(对象的创建交给别人)。依赖注入(DI):在创建完对象后，对象关系的处理就是依赖注入，(通过set方法依赖注入。)</strong></p><h4 id="面向切面编程AOP"><a href="#面向切面编程AOP" class="headerlink" title="面向切面编程AOP"></a>面向切面编程AOP</h4><p>面向切面编程。<strong>切面，简单来说可以理解为一个类，由很多重复代码形成的类。切面举例:事务、日志、权限。</strong> 关于AOP的详细讲解我推荐你们看这篇博客:<a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/" target="_blank" rel="noopener">Spring AOP实现原理与应用</a></p><h3 id="Spring框架概述"><a href="#Spring框架概述" class="headerlink" title="Spring框架概述"></a>Spring框架概述</h3><p><strong>Spring框架，可以解决对象创建以及对象之间依赖关系的一种框架。</strong>且可以和其它框架一起使用，例如spring与struts、spring和hibernate。(起到整合／粘合作用的一个框架)。<br>spring提供了一站式解决方案:<br>1）SpringCore:是Spring的核心功能：IOC容器，解决对象创建及依赖关系。<br>2）SpringWeb:Spring对web模块的支持。</p><blockquote><p>可以与struts整合，让struts的action创建交给spring。<br>Spring mvc模式，用springmvc整合了就不用struts了。</p></blockquote><p>3）Spring DAO:是Spring对Jdbc操作的支持。(Jdbc Template模块工具类)</p><p>4)Spring ORM:是Spring对ORM的支持。</p><blockquote><p>既可以与hibernate整合(使用原始的session)<br>也可以使用Spring对Hibernate操作的封装(对上面的session又进行了一层封装)</p></blockquote><p>5）Spring AOP:关于AOP的详细讲解我推荐你们看这篇博客:<a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/" target="_blank" rel="noopener">Spring AOP实现原理与应用</a></p><p>6）SpringEE:Spring对javaEE其它模块的支持</p><h3 id="Spring开发步骤"><a href="#Spring开发步骤" class="headerlink" title="Spring开发步骤"></a>Spring开发步骤</h3><p>1)导入jar包:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%882.01.02.png" alt=""><br>写在前面的话:当你运行程序出现org.springframework.beans.factory.BeanDefinitionStoreException的报错信息时，不要想了，出现这种报错的信息原因绝对是因为jdk版本和你导入的spring jar包不兼容的问题。<strong>由于spring3.x与jdk1.7兼容，而spring4.x与jdk1.8兼容</strong>，所以这里提供两种解决方案:<br>1.将jdk版本调为1.7，我用的开发工具为IDEA，它默认下的JDK使用1.8版本，所以我需要在三个地方将jdk的版本改过来(前提是你已经下载了jdk1.7版本)，修改IDEA配置中Project的jdk版本、Modules的jdk版本、SDKs的版本，如果你用到leTomcat还需要修改Tomcat配置的jdk版本。这样jdk1.7与spring3.x才兼容。<br>2.将spring3.x.jar换成spring4.x.jar包。这种方式比较繁琐，建议大家使用第一种方式。spring4.x与jdk1.8才兼容。<br>2)配置核心文件applicationContext.xml(文件名称随意):</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;    http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt;</code></pre><p>3)使用:<br>首先我们创建一个pojo对象User.java:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.48.12.png" alt=""><br>然后创建测试类使用这个User对象，以前我们要使用User对象时直接像这样User user=new User();new一个对象即可:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.50.26.png" alt=""><br>而当我们使用Spring后就应该这样使用User对象，首先在applicationContext.xml中添加<bean>标签，一个<bean>标签代表一个pojo对象:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.53.52.png" alt=""><br>其中各个属性的说明见注释。然后我们通过如下步骤获取该pojo对象:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.59.37.png" alt=""><br>运行测试类:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.59.42.png" alt=""><br>说明成功获取到User对象。<strong>上述是通过工厂类获取的IOC容器创建的User对象，下面我们看看使用Spring框架获取pojo对象的第二种方式直接得到IOC容器的对象:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.05.52.png" alt=""><br>运行程序，成功打印出user信息，说明我们通过IOC容器成功获取到user对象。</bean></bean></p><h3 id="lt-bean-gt-创建的细节"><a href="#lt-bean-gt-创建的细节" class="headerlink" title="&lt;bean&gt;创建的细节"></a>&lt;bean&gt;创建的细节</h3><p><strong>对上述代码进行改进，对于IOC容器对象，我们只需创建一次即可，所以将创建IOC对象的代码改为成员变量。</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.14.51.png" alt=""><br>代码中我们通过IOC对象创建了两个User对象，运行测试类得到打印结果:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.15.44.png" alt=""><br><strong>发现答应的这两个User对象id都一样，说明我们获取到的是同一个对象，也说明通过<bean>标签设置的pojo对象是单例的。</bean></strong>为什么呢？其实<bean>标签默认有一个scope=”singleton”的属性，代表该&lt;bean标签对象的pojo对象是单例的。我们可以将该属性值改为scope=”prototype”，如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.18.48.png" alt=""><br>然后再运行测试类,输出如下内容:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.19.43.png" alt=""><br>说明此时获取的两个User不再是同一个对象。</bean></p><p>那么由<strong>IOC容器管理的pojo对象应该在何时创建</strong>呢？我们来看看，首先在User.java中添加一个无参构造器:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.31.57.png" alt=""></p><p>然后修改测试类:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.32.37.png" alt=""><br>运行测试类:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.33.24.png" alt=""><br>从控制台中输出内容我们可以得知:<strong>当程序运行时，IOC容器首先创建，然后当我们需要得到IOC容器中的pojo对象时我们通过语句ac.getBean(“user”);得到，此时就会在IOC中创建由它管理的pojo对象</strong>。当我们删除ac.getBean(“user”);语句时，再次运行程序，得到如下内容:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.36.49.png" alt=""><br>这说明什么呢?说明IOC容器中没有创建pojo对象(因为一旦创建就会有”—User对象创建—“的语句输出)。综上情况，即只有当我们用到pojo对象时，IOC容器才会在自己内部创建它。此种情况为<bean>标签的属性为scope=”prototype”的结果，那么我们再来看看<strong>当属性为scope=”singleton”时的输出结果为</strong>:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.40.53.png" alt=""><br>打印台的内容说明该User对象在程序启动时就创建在IOC容器中了，不信我们把通过IOC容器得到User对象的代码注释掉再看输出结果:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.42.48.png" alt=""></bean></p><p>发现此时即使我们不通过ac.getBean(“user”);语句得到User对象，它也在程序启动时就创建了。</p><p><strong>总结:在<bean>标签中设置bean对象为单例时，该对象在系统启动时就会创建；设置为多例时，该对象在我们需要使用时才创建。</bean></strong></p><h4 id="标签中的其它属性说明"><a href="#标签中的其它属性说明" class="headerlink" title="标签中的其它属性说明"></a><bean>标签中的其它属性说明</bean></h4><ul><li>1.lazy-init:<strong>延迟初始化bean对象，默认值为false，即不延迟创建bean对象，在程序启动时就在IOC中创建bean对象</strong>；若其值为true则延迟创建bean对象，即在我们需要对象时才在IOC容器中创建该对象。此属性只对单例bean对象有效。</li><li>2.init-method:可以给该属性传递一个在pojo对象中创建的方法例如A方法的方法名A作为init-method的属性值，表示当该pojo对象在IOC容器中被创建后就立刻执行这个A方法。</li><li>3.destoy-method:同上，给该属性传递一个在pojo对象中创建的方法例如B方法的方法名B作为destoy-method的属性值，表示当IOC容器被销毁时(该pojo对象也会在IOC中销毁)会立刻调用这个B方法。当然我们通过ApplicationContext ac=new ClassPathXmlApplicationContext(“applicationContext.xml”);创建的IOC对象ac是没有destoy()方法的，我们需要这个创建IOC对象ClassPathXmlApplicationContext ac=new ClassPathXmlApplicationContext(“applicationContext.xml”);这样创建出来的IOC对象才有destoy()方法。</li></ul><h3 id="Spring-IOC容器"><a href="#Spring-IOC容器" class="headerlink" title="Spring IOC容器"></a>Spring IOC容器</h3><p><strong>Spring IOC容器，是Spring的核心内容，用于创建对象和处理对象间的依赖关系。</strong></p><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>利用IOC容器创建对象的方式有如下几种:1.调用无参数构造器。2.调用带参数构造器。3.工厂创建对象。包括工厂类的静态方法创建对象和工厂类的非静态方法创建对象4.<strong>反射。(IOC的原理就是通过反射来创建对象)</strong><br>1.调用无参数构造器,在配置文件中加入如下内容:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.31.43.png" alt=""><br>2.调用带参数构造器<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.31.50.png" alt=""></p><p><constructor-arg>标签中还有一个ref的属性，属性值代表引用配置文件(即IOC容器)中的相应对象。</constructor-arg></p><p>故<strong>还可以采用这种方法调用带参数构造器创建对象:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.31.58.png" alt=""><br>3.用工厂创建对象<br>首先创建一个工厂类:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.34.32.png" alt=""><br>调用工厂的实例方法创建对象:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.32.02.png" alt=""><br>调用工厂静态方法创建对象:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.32.05.png" alt=""></p><h4 id="处理对象的依赖关系"><a href="#处理对象的依赖关系" class="headerlink" title="处理对象的依赖关系"></a>处理对象的依赖关系</h4><p><strong>在IOC容器的配置文件中我们有如下给对象注入属性的方法:1.通过构造方法。2.通过set方法给属性注入值。3.p名称空间。4.自动装配。5.注解。</strong></p><p>1.通过构造方法<br>首先我们来看看如何通过构造方法来给对象的属性赋值,在配置文件中添加如下标签即可通过构造器给该User对象的属性赋值:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.21.03.png" alt=""></p><p>2.通过set方法给属性注入值。<br><strong>通过set方法给属性赋值,前提是在User对象中给它的属性添加了set方法:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.26.29.png" alt=""><br>接下来我们看个案例，<strong>以前我们开发时根据MVC模式都会像下面这样建立相应的Service.java、Servlet.java和dao.java:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.38.05.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.38.10.png" alt=""><br><strong>都需要我们自己在.java文件中添加A a=new A();来创建其所需要的依赖对象，而现在我们就将对象的创建交给IOC了，选择set给属性赋值的方式来给它们注入其所需依赖对象，修改它们的代码:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.44.48.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.44.53.png" alt=""><br>然后我们需要在application.xml中进行配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.48.51.png" alt=""><br>ref的属性值代表给该对象注入它所依赖的对象，即我们上述讲到的依赖注入(dependency injection),通过上述步骤我们便完成了将对象的创建交给IOC的操作。</p><p>上述三个对象的创建我们需要写三个<bean>标签才能完成，<strong>接下来我将介绍第二种方法通过内部bean的操作一次性完成它们的创建以及它们之间的依赖关系，修改配置文件中的内容</strong>:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%885.04.23.png" alt=""><br>通过上述内部<bean>标签的方式我们便可实现和set注入依赖相同的效果。我们来看看它们两者的相同和区别:</bean></bean></p><ul><li>相同:都可以创建Service对象，并处理了之间的依赖关系。</li><li><p>区别:set注入创建的Service对象可以给另一个Servlet对象调用，而内部bean将Service对象写在Servlet内部导致该Service对象只能被该Servlet使用，所以内部bean标签的使用场景在只需要一个Servlet对象的项目中。<br>3.通过p名称空间给对象的属性注入值<br><strong>此中方法只有在Spring3.0版本及以上版本才能用。首先在配置文件的<beans>根标签中加入属性:xmlns:p=”<a href="http://www.springframework.org/schema/p&quot;。" target="_blank" rel="noopener">http://www.springframework.org/schema/p&quot;。</a></beans></strong>然后我们便可以在配置文件中这样给对象的属性赋值:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%885.18.05.png" alt=""><br>当我们在配置文件中输入p:时，会出现两个属性1.p:userDao 和p:userDao-ref,这里有必要说明一下二者区别:</p></li><li><p>p:userDao:代表直接给UserService对象的userDao属性赋值</p></li><li>p:userDao-ref:代表引用的userDao对象</li></ul><p>例如使用p名称空间给传统的对象属性赋值时我们这样写:</p><pre><code>&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot; p:id=&quot;xxx&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot; p:name=&quot;xxx&quot;/&gt;</code></pre><p>4.通过自动装配<br>当我们在配置文件中用<bean>标签指明相应对象的同时就将这个对象放入到了IOC容器中(其中标签中的id属性唯一指示一个对象)，<strong>当我们给该bean标签添加了autowrite=”byName”的属性后，对于该标签对应的对象注入的属性，会去IOC容器中自动查找与属性同名的对象。</strong><br>例如如下代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%8812.12.14.png" alt=""><br>通过上述三个<bean>标签我们就将userDao、userService、userServlet三个对象添加到了IOC容器中。我们在UserService对象的bean标签中加上了autowrite=”byName”的属性，这样我们查看UserService.java的代码，它有一个UserDao对象名为userDao的属性，此时就会自动去IOC容器中寻找与userDao同名的对象(即在bean标签中寻找id为userDao的对象)，然后进行注入，此时我们若将<bean id="userDao" class="pojo.UserDao">的id=”userDao”属性值改为userDao1或者其它名字，则运行系统会出现空指针异常，道理上述已分析。UserServlet注入userService的属性道理同此。</bean></bean></bean></p><p>我们也可以将该属性定义到全局<beans>标签中，设置default-autowrite=”byName”的属性,这样就不用每个bean标签中都写上autowrite=”byName”属性了。</beans></p><p>上述是根据名称自动装配，其实autowrite的属性值还可以为byType即根据类型自动装配。对于<bean id="userService" class="pojo.UserService">，当添加了autowrity=”byType”的属性后，此时寻找它依赖的属性userDao的过程如下:查看UserService.java代码，它需要注入的属性类型为UserDao类型，所以就会自动去IOC容器中查找UserDao类型的对象并自动为UserService对象注入该属性，此时各bean标签的id属性值便可以随便写了如果根据类型自动装配，则要保证保证该类型的对象只有一个，否则会报错。该属性同样可以在全局beans标签中进行配置。</bean></p><p><strong>利用自动装配的优缺点:简化了配置，但不利用系统维护。所以一般不推荐此中用法，下面我们再来介绍第5中非常简单的配置。</strong></p><p>5.通过注解<br><strong>注解方式可以简化Spring的IOC容器的配置。</strong><br>使用步骤:</p><ul><li>1.先引入context名称空间</li><li>2.开启注解扫描</li><li>3.使用注解:通过注解的方式，把对象加入到IOC容器中</li></ul><p>首先在IOC配置文件中引入context名称空间,即在<beans>全局标签中添加xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;属性" target="_blank" rel="noopener">http://www.springframework.org/schema/context&quot;属性</a><br>然后在配置文件中添加如下标签：<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%8812.53.31.png" alt=""><br>base-package:表示该扫描器只扫描此包下所有类。</beans></p><p>最后我们便可以使用注解了，在pojo对象的.java文件中分别加入如下注解:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%8812.54.31.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%8812.54.43.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%8812.54.52.png" alt=""><br><strong>@Componet注解:代表将该对象放入到IOC容器中，括号里面的名字代表该对象在IOC容器中的唯一标识名字，名字任意取。该注解写在代码第一行。</strong></p><p><strong>@Resource注解:用于将该对象依赖的属性从IOC容器中找到并注入，括号里面的name属性值必须跟@Compenent注解里填入的名字相同。</strong></p><p><strong>通过注解方法便可去掉各.java文件中为属性创建设置的set方法。</strong></p><p>继续对上述注解方式进行配置优化，去掉括号中的内容:<br><img src="img src=&quot;http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%881.21.06.png&quot; alt=&quot;&quot;" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%881.21.10.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%881.21.15.png" alt=""></p><p>在测试类中运行依然可以正常运行。</p><p>说明:<strong>利用@Compenent注解的方式是通用的将对象加入到IOC容器中的方式，而有时候我们需要区别各层对象添加的方式，所以这里我们将Dao层对象添加到IOC容器的注解方式改为:@Repository表示持久层的组件;修改Service层对象添加到IOC容器的注解方式:@Service表示业务逻辑层的组件;修改Servlet层对象添加到IOC容器的注解方式为:@Controller表示控制层的组件。</strong></p><p>另外需要说明的是使用注解的方式将对象添加到IOC容器中和在xml文件中添加配置的方式是可以共存的。但通过@Resource不带括号的注解，必须要保证该类型只有一个变量，所以一般情况下我们还是优先使用@Resource(name=””)注解。</p><p>到此，Spring框架的学习我们已完成。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当客户端向服务器发出请求时，服务器把得到的请求发送给控制器Servlet，而在Servlet中需要创建Service对象来调用业务层相关功能(故说控制器层Servlet依赖于业务层Service),而在Service中又需要创建数据库层DAO对象来对数据库进行操作(故说业务
      
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://codinglembre.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis学习之查询缓存</title>
    <link href="http://codinglembre.top/2018/10/02/MyBatis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/"/>
    <id>http://codinglembre.top/2018/10/02/MyBatis学习之查询缓存/</id>
    <published>2018-10-02T14:00:14.000Z</published>
    <updated>2018-10-02T14:24:25.911Z</updated>
    
    <content type="html"><![CDATA[<p>正如大多数持久层框架一样，MyBatis同样也提供了对查询数据的缓存支持。今后我们要学习的<strong>SpringMVC框架属于系统控制层，它也有它的缓存区域，对响应的jsp页面进行缓存；Spring属于系统业务层，它的缓存区域对业务数据进行缓存。</strong>而它们三者的缓存区域都存在于用户要访问数据库的中间，<strong>当用户向数据库中发送查询请求时，系统会先在它们三者的缓存区域看是否有满足用户要求的查询数据，若有则直接从缓存区域返回信息；若没有则从数据库中进行查询。</strong></p><a id="more"></a><h3 id="缓存的意义"><a href="#缓存的意义" class="headerlink" title="缓存的意义"></a>缓存的意义</h3><p><strong>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</strong></p><h3 id="MyBatis持久层缓存"><a href="#MyBatis持久层缓存" class="headerlink" title="MyBatis持久层缓存"></a>MyBatis持久层缓存</h3><p>MyBatis提供了一级缓存和二级缓存，概念图如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.15.43.png" alt=""><br>图中所示，<strong>MyBatis一级缓存是一个SqlSession级别，SqlSession只能访问自己的一级缓存的数据，二级缓存是跨SqlSession，是mapper级别的缓存，对于mapper级别的缓存不同的Sqlsession是可以共享的。</strong></p><h3 id="MyBatis一级缓存"><a href="#MyBatis一级缓存" class="headerlink" title="MyBatis一级缓存"></a>MyBatis一级缓存</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.19.30.png" alt=""><br><strong>对于图的解释:第一次发出一个查询sql，sql查询结果写入sqlsession的一级缓存中，缓存使用的数据结构是一个map&lt;key,value&gt;。</strong></p><ul><li>key：hashcode+sql+sql输入参数+输出参数（sql的唯一标识）</li><li>value：用户信息</li></ul><p>同一个sqlsession再次发出相同的sql，就从缓存中取,而不走数据库。如果两次中间出现commit操作（修改、添加、删除），本sqlsession中的一级缓存区域全部清空，下次再去缓存中查询不到所以要从数据库查询，从数据库查询到再写入缓存。即对于查询操作，每次查询都先从缓存中查询，如果缓存中查询到数据则将缓存数据直接返回，如果缓存中查询不到就从数据库查询。</p><h4 id="一级缓存配置"><a href="#一级缓存配置" class="headerlink" title="一级缓存配置"></a>一级缓存配置</h4><p><strong>mybatis默认支持一级缓存不需要配置</strong>。</p><p>注意:mybatis和spring整合后进行mapper代理开发，不支持一级缓存，mybatis和spring整合，spring按照mapper的模板去生成mapper代理对象，模板中在最后统一关闭sqlsession。</p><h4 id="一级缓存的测试"><a href="#一级缓存的测试" class="headerlink" title="一级缓存的测试"></a>一级缓存的测试</h4><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.25.22.png" alt=""><br>运行，在控制台看到输出:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.26.38.png" alt=""><br><strong>发现打印两次结果只有第一次向数据库中发送了查询请求，第二次是直接从缓存中返回的数据。接下来我们在中间加入更新数据的操作:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.29.29.png" alt=""><br>然后在控制台中看到打印过程:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.30.31.png" alt=""><br>可以发现向数据库发送了三次请求。</p><h3 id="MyBatis二级缓存"><a href="#MyBatis二级缓存" class="headerlink" title="MyBatis二级缓存"></a>MyBatis二级缓存</h3><h4 id="二级缓存原理"><a href="#二级缓存原理" class="headerlink" title="二级缓存原理"></a>二级缓存原理</h4><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.31.30.png" alt=""><br>二级缓存的范围是mapper级别（mapper同一个命名空间），mapper以命名空间为单位创建缓存数据结构，结构是map&lt;key、value&gt;。</p><p>过程:<strong>每次查询先看是否开启二级缓存，如果开启从二级缓存的数据结构中取缓存数据，如果从二级缓存没有取到，再从一级缓存中找，如果一级缓存也没有，从数据库查询</strong></p><h4 id="二级缓存的配置"><a href="#二级缓存的配置" class="headerlink" title="二级缓存的配置"></a>二级缓存的配置</h4><p>不像一级缓存那样mybatis自动开启一级缓存，mybatis是默认关闭二级缓存的，所以我们需要需要进行两个操作才能开启二级缓存:<br>1.在核心配置文件SqlMapperConfig.xml中加入</p><pre><code>&lt;!--开启二级缓存--&gt;&lt;setting name = &quot;cacheEnabled&quot; value = &quot;true&quot;&gt;</code></pre><p>属性值cacheEnabled表示对在此配置文件下的所有cache 进行全局性开/关设置，它的可选值为true｜false,默认值为true.</p><p>2.<strong>在你的Mapper映射文件中添加一行:<cache> ，表示此mapper开启二级缓存。</cache></strong><br>3.查询结果映射的pojo序列化：<br><strong>mybatis二级缓存需要将查询结果映射的pojo实现 java.io.serializable接口，如果不实现则抛出异常：</strong><br>org.apache.ibatis.cache.CacheException: Error serializing object. Cause: java.io.NotSerializableException: cn.itcast.mybatis.po.User</p><p>二级缓存可以将内存的数据写到磁盘，存在对象的序列化和反序列化，所以要实现java.io.serializable接口。</p><p>如果结果映射的pojo中还包括了pojo，都要实现java.io.serializable接口。</p><h4 id="二级缓存的禁用"><a href="#二级缓存的禁用" class="headerlink" title="二级缓存的禁用"></a>二级缓存的禁用</h4><p>于变化频率较高的sql，需要禁用二级缓存：在statement中设置useCache=false可以禁用当前select语句的二级缓存，即每次查询都会发出sql去查询，默认情况是true，即该sql使用二级缓存。</p><pre><code>&lt;select id=&quot;findOrderListResultMap&quot; resultMap=&quot;ordersUserMap&quot; useCache=&quot;false&quot;&gt;</code></pre><h4 id="刷新缓存"><a href="#刷新缓存" class="headerlink" title="刷新缓存"></a>刷新缓存</h4><p>将二级缓存进行刷新操作有两种方式:</p><pre><code>- **如果sqlsession操作commit操作，对二级缓存进行刷新（全局清空）。**- 设置statement的flushCache是否刷新缓存，默认值是true。</code></pre><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.41.06.png" alt=""><br>分别将中间更新用户信息的代码注释:发现两次打印用户信息的操作只向数据库中发送一次查询请求;去掉注释:三次操作向数据库中发送三次请求。</p><h4 id="二级缓存的应用场景"><a href="#二级缓存的应用场景" class="headerlink" title="二级缓存的应用场景"></a>二级缓存的应用场景</h4><p><strong>对查询频率高，变化频率低的数据建议使用二级缓存。</strong></p><p>对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。</p><p>实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。</p><h4 id="二级缓存的局限性"><a href="#二级缓存的局限性" class="headerlink" title="二级缓存的局限性"></a>二级缓存的局限性</h4><p>mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。</p><h3 id="MyBatis和ehcache缓存框架整合"><a href="#MyBatis和ehcache缓存框架整合" class="headerlink" title="MyBatis和ehcache缓存框架整合"></a>MyBatis和ehcache缓存框架整合</h3><h4 id="分布缓存"><a href="#分布缓存" class="headerlink" title="分布缓存"></a>分布缓存</h4><p><strong>将缓存数据进行分布式管理</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.45.41.png" alt=""></p><h4 id="MyBatis和ehcache整合思路"><a href="#MyBatis和ehcache整合思路" class="headerlink" title="MyBatis和ehcache整合思路"></a>MyBatis和ehcache整合思路</h4><p>通过MyBatis和ehcache框架进行整合，就可以把缓存数据的管理托管给ehcache。</p><p>首先我们看看MyBatis自己的二级缓存，它在自己内部提供了一个cache接口，我们只要实现了cache接口就可以把缓存数据灵活的管理起来。</p><p>要将MyBatis和ehcache整合，我们首先需要下载ehcache的jar包:</p><ul><li>ehcache-core.jar</li><li>mybatis-ehcache.jar</li></ul><p>然后需要添加一个ehcache的配置文件ehcache.xml:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.59.32.png" alt=""><br>然后在mapper.xml中添加ehcache的配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%8812.00.18.png" alt=""></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正如大多数持久层框架一样，MyBatis同样也提供了对查询数据的缓存支持。今后我们要学习的&lt;strong&gt;SpringMVC框架属于系统控制层，它也有它的缓存区域，对响应的jsp页面进行缓存；Spring属于系统业务层，它的缓存区域对业务数据进行缓存。&lt;/strong&gt;而它们三者的缓存区域都存在于用户要访问数据库的中间，&lt;strong&gt;当用户向数据库中发送查询请求时，系统会先在它们三者的缓存区域看是否有满足用户要求的查询数据，若有则直接从缓存区域返回信息；若没有则从数据库中进行查询。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="MyBatis" scheme="http://codinglembre.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis学习之使用resultMap实现高级映射</title>
    <link href="http://codinglembre.top/2018/10/02/MyBatis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BD%BF%E7%94%A8result%E5%AE%9E%E7%8E%B0%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84/"/>
    <id>http://codinglembre.top/2018/10/02/MyBatis学习之使用result实现高级映射/</id>
    <published>2018-10-02T09:52:47.000Z</published>
    <updated>2018-10-02T12:28:12.176Z</updated>
    
    <content type="html"><![CDATA[<p>对于数据库中对表的增删改查操作，我们知道增删改都涉及的是单表，而<strong>只有查询操作既可以设计到单表操作又可以涉及到多表操作，所以对于输入映射parameterType而言是没有所谓的高级映射的</strong>，也就是说高级映射只针对于输出映射(因为高级映射设计到多张表)。</p><p>前五篇文章我们都只实现了单表中的字段与pojo的映射，<strong>而本篇文章我们将来讲解如何实现多表与pojo之间的高级映射,分别有一对一映射、一对多映射和多对多映射。</strong>首先我们来看看如何使用<br>resultType完成一对一映射。</p><h3 id="多表间的一对一查询"><a href="#多表间的一对一查询" class="headerlink" title="多表间的一对一查询"></a>多表间的一对一查询</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>查询订单信息关联查询用户信息。这里我们知道一个用户可以有多张订单，而一张订单只能属于一个用户，所以<strong>用户与订单间的关系是一对多而订单与用户间的关系是一对一。所以这里我们将订单表作为主查询表来关联用户表，从而实现一对一映射。</strong></p><h4 id="创建表和数据"><a href="#创建表和数据" class="headerlink" title="创建表和数据"></a>创建表和数据</h4><pre><code>create table orders( id int primary key auto_increment, user_id int , number int,  createtime datetime, note varchar(50));用户表在第一篇文章中我们已经创建。</code></pre><p>建立oders表和user表对应的pojo对象Orders.java和User.java。</p><pre><code>public class Orders{private Integer id;private Integer userId;private String number;private Date createtime;private String note;｝</code></pre><p>并建立相关的get和set方法，User.java我们之前已建立。</p><h4 id="sql查询语句"><a href="#sql查询语句" class="headerlink" title="sql查询语句"></a>sql查询语句</h4><p>对于查询语句，我们需要知道:1.先确定主查询表:订单表。2.再确定关联查询表:用户信息表。通过orders关联查询用户使用user_id一个外键，<strong><em>只能关联查询出一条用户记录，我们使用内连接</em></strong>。查询语句为:</p><pre><code>SELECT orders.*,user.username,user.sex FROM orders,user WHERE orders.user_id = user.id</code></pre><h4 id="使用resultType实现一对一映射"><a href="#使用resultType实现一对一映射" class="headerlink" title="使用resultType实现一对一映射"></a>使用resultType实现一对一映射</h4><p>通过查询语句，查询到的结果同时包括user表和orders表两张表的列，那么我们将结果映射到哪个pojo对象中呢？若映射到User.java，那查询结果中对应的orders表的字段一定会遗失；若映射到Orders.java，那查询结果中对应的user表的字段同样也会遗失。<strong>所以这里需要我们针对查询的结果重新创建一个映射的pojo对象OrderCustom.java:</strong><br><img src="https://i.imgur.com/i3uwu6K.png" alt=""><br>这里我们让OrderCustom.java继承自Order.java，<strong>这样我们就只需在OrderCustom.java中添加user表中的字段即可</strong>。因为MyBatis主要的重点在sql语句，所以我们完成配置和pojo对象的建立后主要的点就放在了sql语句上，所以接下来要定义写sql语句的mapper.xml和对数据库进行操作的mapper.java接口了<br>OrdersMapperCustom.xml文件内容如下:<br><img src="https://i.imgur.com/A4DcmBr.png" alt=""><br><strong>因为我们只关心输出映射，所以在xml中写sql查询语句时没有写parameterType属性</strong>，而resultType的属性值我之所以没有写全OrderCustom类的全限定性名，是因为我们在SqlMapperConfig.xml中进行了别名的配置。相应的OrdersMapperCustom.java接口内容如下:<br><img src="https://i.imgur.com/7EccSos.png" alt=""><br>然后在测试类中测试:<br><img src="https://i.imgur.com/Y8mu3T8.png" alt=""><br>便可完成这两张表的关联与我们自定义的pojo对象的映射。接下来我们看看如何使用resultMap完成。</p><h3 id="使用resultMap实现一对一映射"><a href="#使用resultMap实现一对一映射" class="headerlink" title="使用resultMap实现一对一映射"></a>使用resultMap实现一对一映射</h3><p>思路:将关联查询的信息映射到pojo中，如下:只需在Orders类中创建一个User属性，将关联查询的信息映射到User属性中。<br>这样我们便可以将查询的结果映射到Orders.java类中，而不用自己再自定义一个pojo了。</p><p>修改OrdersMapperCustom.xml中的内容(添加并使用resultMap标签),<strong>注意association标签的用法</strong><br><img src="https://i.imgur.com/Jj3AJZw.png" alt=""><br>然后在OrdersMapperCutom.java中添加方法:<br><img src="https://i.imgur.com/7EccSos.png" alt=""><br>最后测试:<br><img src="https://i.imgur.com/BXSuSe0.png" alt=""><br>发现查询结果已全部映射到Orders.java类中。</p><h3 id="比较resultType和resultMap完成一对一映射"><a href="#比较resultType和resultMap完成一对一映射" class="headerlink" title="比较resultType和resultMap完成一对一映射"></a>比较resultType和resultMap完成一对一映射</h3><ul><li>resultType：<strong>要自定义pojo 保证sql查询列和pojo的属性对应，这种方法相对较简单，所以应用广泛。</strong></li><li>resultMap：<strong>使用association完成一对一映射需要配置一个resultMap标签，过程有点复杂，如果要实现延迟加载(后面会讲)就只能用resultMap实现 ，如果为了方便对关联信息进行解析，也可以用association将关联信息映射到pojo中方便解析。</strong></li></ul><h3 id="多表间的一对多查询"><a href="#多表间的一对多查询" class="headerlink" title="多表间的一对多查询"></a>多表间的一对多查询</h3><h4 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h4><p>查询所有订单信息及订单下的订单明细信息。分析:<strong>一个订单可以可以有多个订单明细，而一个订单明细只属于一个订单，所以订单与订单明细间的关系为一对多。</strong></p><h4 id="创建表和数据-1"><a href="#创建表和数据-1" class="headerlink" title="创建表和数据"></a>创建表和数据</h4><pre><code>create table orderdetail( id int primary key auto_increment, orders_id int, items_id int, items_num int);//创建订单明细</code></pre><p>创建和订单明细表对应的pojo对象:</p><pre><code>public class Orderdetail{    private Integer id;       private Integer ordersId;       private Integer itemsId;       private Integer itemsNum;}</code></pre><p>并创建相关的set和get方法。</p><h4 id="sql查询语句-1"><a href="#sql查询语句-1" class="headerlink" title="sql查询语句"></a>sql查询语句</h4><p>1.先确定主查询表:订单表。2.再确定关联查询表:用户表加订单明细表。通过orderdetail关联查询订单使用orders_id一个外键，只能关联查询出一条订单记录，我们使用内连接。查询语句为:</p><pre><code>SELECT orders.*,user.username,user.sex ,orderdetail.id orderdetail_id,orderdetail.items_num,orderdetail.items_idFROM orders,user,orderdetail WHERE orders.user_id = user.id AND orders.id=orderdetail.orders_id</code></pre><h4 id="使用resultMap进行一对多映射"><a href="#使用resultMap进行一对多映射" class="headerlink" title="使用resultMap进行一对多映射"></a>使用resultMap进行一对多映射</h4><p>思路:<strong>resultMap 提供collection完成关联信息映射到集合对象中。在orders类中创建集合属性</strong>：<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%885.14.55.png" alt=""><br>然后修改OrdersMapperCustom.xml中的信息:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%885.32.43.png" alt=""><br>并在其中添加resultMap的定义:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%885.32.50.png" alt=""><br>最后进行测试:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%885.33.31.png" alt=""></p><h3 id="延迟加载-只能用resultMap"><a href="#延迟加载-只能用resultMap" class="headerlink" title="延迟加载(只能用resultMap)"></a>延迟加载(只能用resultMap)</h3><h4 id="使用延迟加载的意义"><a href="#使用延迟加载的意义" class="headerlink" title="使用延迟加载的意义"></a>使用延迟加载的意义</h4><p>在进行数据查询时，<strong>为了提高数据库查询性能，尽量使用单表查询，因为单表查询比多表关联查询速度要快。</strong><br><strong>如果查询单表就可以满足需求，一开始先查询单表，当需要关联信息时，再关联查询，当需要关联信息再查询这个叫延迟加载。</strong><br>mybatis中resultMap提供延迟加载功能，通过resultMap配置延迟加载,但需要在MyBatis的配置文件中进行相关配置，如下<br><img src="https://i.imgur.com/E3ZML6z.png" alt=""><br>然后在SqlMapperConfig.xml中添加如下配置信息:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%887.39.21.png" alt=""></p><h3 id="一对一延迟加载的实现"><a href="#一对一延迟加载的实现" class="headerlink" title="一对一延迟加载的实现"></a>一对一延迟加载的实现</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>需求:查询订单及用户的信息，一对一查询。</p><p>刚开始我们只查询订单信息。而当需要用户信息时调用Orders类中的getUser()方法执行延迟加载 ，向数据库发出sql。代码实现如下:<br>在OrderMapperCustom.xml文件中添加如下信息:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%887.41.51.png" alt=""><br>并定义resultMap标签:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%887.42.51.png" alt=""><br>最后是测试代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%887.44.14.png" alt=""></p><h4 id="一对多延迟加载的实现"><a href="#一对多延迟加载的实现" class="headerlink" title="一对多延迟加载的实现"></a>一对多延迟加载的实现</h4><p>一对多延迟加载的方法同一对一延迟加载，在collection标签中配置select内容。</p><h3 id="resultType、resultMap、延迟加载使用场景总结"><a href="#resultType、resultMap、延迟加载使用场景总结" class="headerlink" title="resultType、resultMap、延迟加载使用场景总结"></a>resultType、resultMap、延迟加载使用场景总结</h3><p>延迟加载:<br>延迟加载实现的方法多种多样，在只查询单表就可以满足需求，为了提高数据库查询性能使用延迟加载，再查询关联信息。</p><p>mybatis提供延迟加载的功能用于service层。</p><p>resultType:作用：将查询结果按照sql列名pojo属性名一致性映射到pojo中。</p><p>场合：常见一些明细记录的展示，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。</p><p>resultMap:使用association和collection完成一对一和一对多高级映射。</p><p>association:作用:将关联查询信息映射到一个pojo类中。</p><p>场合:为了方便获取关联信息可以使用association将关联订单映射为pojo，比如:查询订单及关联用户信息。</p><p>collection:作用:将关联查询信息映射到一个list集合中。</p><p>场合:为了方便获取关联信息可以使用collection将关联信息映射到list集合中，比如:查询用户权限范围模块和功能，可使用collection将模块和功能列表映射到list中</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于数据库中对表的增删改查操作，我们知道增删改都涉及的是单表，而&lt;strong&gt;只有查询操作既可以设计到单表操作又可以涉及到多表操作，所以对于输入映射parameterType而言是没有所谓的高级映射的&lt;/strong&gt;，也就是说高级映射只针对于输出映射(因为高级映射设计到
      
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="MyBatis" scheme="http://codinglembre.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Java封装继承多态和OOP设计原则</title>
    <link href="http://codinglembre.top/2018/10/02/Java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    <id>http://codinglembre.top/2018/10/02/Java三大特性封装继承多态/</id>
    <published>2018-10-02T08:03:41.000Z</published>
    <updated>2018-10-03T02:30:56.346Z</updated>
    
    <content type="html"><![CDATA[<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="封装的定义"><a href="#封装的定义" class="headerlink" title="封装的定义"></a>封装的定义</h4><ul><li>首先是抽象，把事物抽象成一个类，其次才是封装，将事物拥有的属性和动作隐藏起来，只保留特定的方法与外界联系</li></ul><h4 id="为什么要封装"><a href="#为什么要封装" class="headerlink" title="为什么要封装"></a>为什么要封装</h4><ul><li><strong>实现了对属性和实现细节的封装，用户不用去关心内部的实现；使用者只能通过规定的方法访问数据，可以方便的加入存取控制语句，限制了不合理的操作；当内部逻辑发生变化时，外部访问不用修改。</strong></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Java的类可以分为三类：</p><pre><code>- 普通类：使用class定义，没有抽象方法- 抽象类：使用abstract class定义，可以有也可以没有抽象方法- 接口：使用inerface定义，只能有抽象方法</code></pre><h4 id="继承到底做了什么-扩展和覆盖"><a href="#继承到底做了什么-扩展和覆盖" class="headerlink" title="继承到底做了什么(扩展和覆盖)"></a>继承到底做了什么(扩展和覆盖)</h4><pre><code>- **子类继承除构造函数的一切东西。(私有属性能被继承的,但是子类无法访问父类的私有属性或方法,用反射的话，私有属性和方法都是可以访问的)**- **子类可以添加自己的方法和属性，即对父类进行扩展**- **子类可以重新定义父类的方法，即多态里面的覆盖，后面会详述**</code></pre><p>关于构造函数：</p><pre><code>- **构造函数不能被继承，子类可以通过super()显式调用父类的构造函数**- **创建子类时，编译器会自动调用父类的 无参构造函数**- **如果父类没有定义无参构造函数，子类必须在构造函数的第一行代码使用super()显示调用**</code></pre><h4 id="为什么要有继承"><a href="#为什么要有继承" class="headerlink" title="为什么要有继承"></a>为什么要有继承</h4><p><strong>代码重用是一点，最重要的还是所谓想上转型，即父类的引用变量可以指向子类对象</strong>，这是Java面向对象最重要特性多态的基础。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><pre><code>- **多态可以分为两种类型：编译时多态（方法的重载）和运行时多态（继承时方法的重写），编译时多态很好理解，后述内容针对运行时多态**- 运行时多态依赖于继承、重写和向上转型</code></pre><p>首先需要知道方法的唯一性标识即什么是相同/不同的方法：</p><pre><code>- 其中只有**方法名和参数**是唯一性标识，意即只要方法名和参数相同那他们就是相同的方法- **所谓参数相同，是指参数的个数，类型，顺序一致，其中任何一项不同都是不同的方法**</code></pre><p>何谓重载：</p><pre><code>- **重载是指一个类里面（包括父类的方法）存在方法名相同，但是参数不一样的方法，参数不一样可以是不同的参数个数、类型或顺序**- 如果仅仅是修饰符、返回值、throw的异常 不同，那这是2个相同的方法，编译都通不过，更不要说重载了</code></pre><p>何谓覆盖Override：</p><pre><code>- 覆盖描述存在继承关系时子类的一种行为- **子类中存在和父类相同的方法即为覆盖，何谓相同方法请牢记前面的描述，方法名和参数相同，包括参数个数、类型、顺序**</code></pre><p>覆盖/重写的规则：（两同两小一大原则）</p><pre><code>-子类不能覆盖父类private的方法，private对子类不可见，如果子类定义了一个和父类private方法相同的方法，实为新增方法- 重写方法的修饰符一定要大于被重写方法的修饰符(public &gt; protected &gt; default &gt; private)- 重写抛出的异常需与父类相同或是父类异常的子类，或者重写方法干脆不写throws重写方法的返回值必须与被重写方法一致，否则编译报错- 静态方法不能被重写为非静态方法，否则编译出错</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>java中变量不能重写，可以按如下口诀记忆：</p><pre><code>- **变量多态看左边，** - **方法多态看右边，**- 静态多态看左边。</code></pre><p><strong>多态的好处:降低代码的耦合度</strong></p><h3 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h3><p>面向对象设计原则是我们用于评价一个设计模式的使用效果的重要标准之一。</p><pre><code>- 单一职责原则    定义：**一个类只负责一个领域的相应职责 **  - 开闭原则  定义：软件实体应对扩展开放，而对修改关闭- 里氏替换原则  定义：所有引用基类的对象能够透明的使用其子类的对象- 依赖倒转原则  定义：抽象不应该依赖于细节，细节依赖于抽象- 接口隔离原则  定义：**使用多个专门的接口，而不是使用单一总接口**- 合成复用原则  定义：尽量使用对象组合，而不是继承来达到复合目的- 迪米特法则  定义：一个软件实体应当尽可能少的与其它实体发生相互作用</code></pre><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h3&gt;&lt;h4 id=&quot;封装的定义&quot;&gt;&lt;a href=&quot;#封装的定义&quot; class=&quot;headerlink&quot; title=&quot;封装的定义&quot;&gt;&lt;/a&gt;封装的定
      
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="JavaSE" scheme="http://codinglembre.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis学习之输入与输出映射</title>
    <link href="http://codinglembre.top/2018/10/02/MyBatis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E6%98%A0%E5%B0%84/"/>
    <id>http://codinglembre.top/2018/10/02/MyBatis学习之输入与输出映射/</id>
    <published>2018-10-02T06:51:50.000Z</published>
    <updated>2018-10-02T13:44:32.351Z</updated>
    
    <content type="html"><![CDATA[<p>在MyBatis中，我们通过parameterType完成输入映射(指<strong>将值映射到sql语句的占位符中，值的类型与dao层响应方法的参数类型一致</strong>)，通过resultType完成输出映射(<strong>从数据库中输出，通过dao层的方法查询到的数据输出到pojo对象中</strong>)。 注意输入与输出都是相对于数据库的。接下来我们先谈谈输入映射。</p><a id="more"></a><h3 id="输入映射parameterType"><a href="#输入映射parameterType" class="headerlink" title="输入映射parameterType"></a>输入映射parameterType</h3><p>通过parameterType传入简单类型或对象，我们之前讲过了，接下来我们要讲的是<strong>parameterType传递pojo包装对象。</strong>可以定义pojo包装类型扩展mapper接口输入参数的内容。</p><p>看下我们的需求:定义查询条件查询用户信息，需要向statement输入查询条件，查询条件可以有user信息、商品信息等等。<br>首先我们在domain包下创建UserCustom类并继承User：<br><img src="http://od2xrf8gr.bkt.clouddn.com/ssss.png" alt=""><br>UserCustom类用于对User属性进行扩展(例如User中只有用户信息，而我们可以在UserCustom中加入商品信息)，然后再创建User的包装类UserQueryVo.java:<br><img src="http://od2xrf8gr.bkt.clouddn.com/ssssss.png" alt=""><br>UserMapper.xml中添加如下配置信息:<br><img src="http://od2xrf8gr.bkt.clouddn.com/sjjj.png" alt=""><br>UserMapper.java中添加方法:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.41.10.png" alt=""><br>然后便可以进行测试:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.41.34.png" alt=""> </p><blockquote><p>可能出现的异常:如果在parameterType中指定了错误的属性名时会出现如下异常:</p></blockquote><pre><code>org.apache.ibatis.exceptions.PersistenceException: ### Error querying database.  Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;userCusto&apos; in &apos;class cn.itcast.mybatis.po.UserQueryVo&apos;### Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;userCusto&apos; in &apos;class cn.itcast.mybatis.po.UserQueryVo&apos;</code></pre><h3 id="输出映射-resultType和resultMap"><a href="#输出映射-resultType和resultMap" class="headerlink" title="输出映射(resultType和resultMap)"></a>输出映射(resultType和resultMap)</h3><p><strong>输出映射有resultType和resultMap,他们都是指定输出结果的类型(pojo、简单类型、hashmap…)，并将sql查询结果映射为java对象 。</strong></p><h4 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h4><p>借用上述parameter传递包装pojo对象的知识(不用parameter传递包装pojo对象的知识也行)，我们来谈谈用resultType输出简单类型。UserMapper.xml文件中添加如下配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.51.42.png" alt=""><br>然后在UserMapper.java中添加如下方法:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.52.30.png" alt=""><br>测试:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.53.12.png" alt=""><br><strong>使用resultType时我们应该注意:sql查询的列名要和resultType指定pojo的属性名相同，</strong>指定相同属性方可映射成功，如果sql查询的列名要和resultType指定pojo的属性名全部不相同(或是部分不相同)，则映射到pojo对象中的对应属性为null。例如有时候我们不需要查询select * from user where id = ?而是select username,address _address where id = ? <strong>此时我们给查询的address列名给了一个别名_address，这样我们通过查询表中address的数据然后在将它映射到User对象时，该对象的address属性就为null，即没将从表中查询到的address数据映射到user对象的address属性中</strong></p><h3 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h3><p>使用resultMap需要在UserMapper.xml中进行配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%887.06.02.png" alt=""><br>然后在UserMapper.xml中使用它:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%887.06.23.png" alt=""><br>UserMapper.java文件中:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%887.08.19.png" alt=""><br>测试类代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%887.08.51.png" alt=""></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在MyBatis中，我们通过parameterType完成输入映射(指&lt;strong&gt;将值映射到sql语句的占位符中，值的类型与dao层响应方法的参数类型一致&lt;/strong&gt;)，通过resultType完成输出映射(&lt;strong&gt;从数据库中输出，通过dao层的方法查询到的数据输出到pojo对象中&lt;/strong&gt;)。 注意输入与输出都是相对于数据库的。接下来我们先谈谈输入映射。&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="MyBatis" scheme="http://codinglembre.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis之优化MyBatis配置文件中的配置</title>
    <link href="http://codinglembre.top/2018/10/02/MyBatis%E4%B9%8B%E4%BC%98%E5%8C%96MyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://codinglembre.top/2018/10/02/MyBatis之优化MyBatis配置文件中的配置/</id>
    <published>2018-10-02T02:35:50.000Z</published>
    <updated>2018-10-02T13:43:40.004Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MyBatis配置文件属性了解"><a href="#MyBatis配置文件属性了解" class="headerlink" title="MyBatis配置文件属性了解"></a>MyBatis配置文件属性了解</h3><p>MyBatis配置文件很重要，首先我们来看看MyBatis配置文件中的内容和顺序:</p><pre><code>&lt;properties&gt;(属性)&lt;setting&gt;(全局配置参数)&lt;typeAliases&gt;(类型别名)&lt;typeHandlers&gt;(类型处理器)&lt;objectFactory&gt;(对象工厂)&lt;plugins&gt;(插件)&lt;environments&gt;(环境集合属性对象)    &lt;environment&gt;(环境子属性对象)        &lt;transactionManager&gt;(事务管理)        dataSource&gt;(数据源)&lt;mappers&gt;(映射器)</code></pre><h3 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a><properties>属性定义</properties></h3><p>可以把一些通用的属性值配置在属性文件中，加载到mybatis运行环境内。例如创建db.properties文件，然后在SqlMapperConfig.xml中进行配置。db.properties文件内容如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/db.pro.png" alt=""><br>然后在SqlMapperConfig.xml中进行配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%885.59.18.png" alt=""><br>然后在<environments>标签中用${}符号做如下修改:<br><img src="http://od2xrf8gr.bkt.clouddn.com/nima.png" alt=""><br>注意:Mybatis将按照下面的顺序来加载属性</environments></p><pre><code>- 1.在properties标签之间定义的属性首先被读取。- 2.然后会读取properties标签内部resource或url的属性，它会覆盖已读取的同名属性。- 3.最后读取parameterType(即insert标签或是update标签或是…)传递的属性，它会覆盖已读取的同名属性。</code></pre><p><strong>所以我们建议使用properties标签时，不要在properties标签之间定义属性，只引用在.properties文件中定义的属性，并且.properties文件中定义的key值要有一些特殊的规则。</strong>例如我上述定义key值时前面都加了jdbc.的前缀</p><h3 id="lt-settings-gt-全局参数配置"><a href="#lt-settings-gt-全局参数配置" class="headerlink" title="&lt;settings&gt;全局参数配置"></a>&lt;settings&gt;全局参数配置</h3><p>mybatis运行时可以调整一些全局参数(相当于软件的运行参数)。根据使用需求进行参数配置。但是要注意:小心配置，配置参数会影响mybatis的执行。</p><p><strong>ibatis的全局配置参数中包括很多的性能参数(最大线程数、最大等待时间…)，通过调整这些性能参数使ibatis达到高性能的运行，而mybatis没有这些性能参数，由mybatis自动调节。</strong></p><h3 id="lt-typeAliases-gt-属性"><a href="#lt-typeAliases-gt-属性" class="headerlink" title="&lt;typeAliases&gt;属性"></a>&lt;typeAliases&gt;属性</h3><p>可以将parameterType、resultType中指定的类型通过别名引用。MyBatis提供了很多的别名如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%88%AB%E5%90%8D.png" alt=""><br>这里我们采用自定义的别名，在SqlMapperConfig.xml中进行如下配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/hahaha.png" alt=""><br>里面包括定义单个别名和批量别名定义(即一次性定义一个包下所有.java文件的别名)。</p><p><strong>定义别名后这样我们在parameterType和resultType中使用时就不用再繁琐的指定类的全限定类名了，像下面这样使用即可</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/dadada.png" alt=""></p><h3 id="lt-typeHandlers-gt-属性"><a href="#lt-typeHandlers-gt-属性" class="headerlink" title="&lt;typeHandlers&gt;属性"></a>&lt;typeHandlers&gt;属性</h3><p>类型处理器将java类型和jdbc类型进行映射，mybatis提供了很多类型处理器，一般情况下够用了。</p><h3 id="lt-mapper-gt-映射器属性"><a href="#lt-mapper-gt-映射器属性" class="headerlink" title="&lt;mapper&gt;映射器属性"></a>&lt;mapper&gt;映射器属性</h3><p>之前我们在配置文件中使用的<mapper>标签内容为:&lt;mapper resource=“mapper/UserMapper.xml”/&gt;，接下来我要讲的是另一种在配置文件中映射mapper动态代理的方法。在配置文件中这样配置<mapper class="“mapper.UserMapper”/"><strong>这样的要求需要保证UserMapper.xml文件和UserMapper.java在同一个包下且.xml文件和.java文件名要同名。</strong></mapper></mapper></p><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.12.42.png" alt=""></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MyBatis配置文件属性了解&quot;&gt;&lt;a href=&quot;#MyBatis配置文件属性了解&quot; class=&quot;headerlink&quot; title=&quot;MyBatis配置文件属性了解&quot;&gt;&lt;/a&gt;MyBatis配置文件属性了解&lt;/h3&gt;&lt;p&gt;MyBatis配置文件很重要，首先我
      
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="MyBatis" scheme="http://codinglembre.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis之Mapper动态代理开发</title>
    <link href="http://codinglembre.top/2018/10/02/MyBatis%E4%B9%8BMapper%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%BC%80%E5%8F%91/"/>
    <id>http://codinglembre.top/2018/10/02/MyBatis之Mapper动态代理开发/</id>
    <published>2018-10-02T01:58:00.000Z</published>
    <updated>2018-10-02T13:47:11.115Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SqlSession的使用范围"><a href="#SqlSession的使用范围" class="headerlink" title="SqlSession的使用范围"></a>SqlSession的使用范围</h3><p>1.SqlSessionFactoryBuilder<br>SqlSessionFactoryBuilder是以工具类的方式来使用:需要创建sqlSessionFactory时就new一个 SqlSessionFactoryBuilder</p><p>2.sqlSessionFactory<br>正常开发时，以单例方式管理sqlSessionFactory，整个系统运行过程中sqlSessionFactory只有一个实例，<strong>将来和Spring整合后由Spring以单例方式管理sqlSessionFactory</strong></p><p>3.SqlSession<br><strong>SqlSession是一个面向用户(程序员)的接口，程序员调用 SqlSession接口的方法进行操作数据库。</strong>那么我们会思考:SqlSession能否以单例方式使用？？？由于 SqlSession是线程不安全的，所以 SqlSession最佳应用范围在方法体内。也就是说在方法体内定义局部变量 SqlSession的对象来使用。</p><h3 id="MyBatis开发DAO的方式"><a href="#MyBatis开发DAO的方式" class="headerlink" title="MyBatis开发DAO的方式:"></a>MyBatis开发DAO的方式:</h3><p>我们先来看看MyBatis原始开发dao的开发方式，发现原始开发的问题，然后再来看看MyBatis使用mapper动态代理开发dao的方式(也是MyBatis目前使用的开发dao的方式)。</p><h4 id="原始dao的开发方式"><a href="#原始dao的开发方式" class="headerlink" title="原始dao的开发方式"></a>原始dao的开发方式</h4><p>程序员需要编写dao接口和dao实现类<br><a href="http://od2xrf8gr.bkt.clouddn.com/dao%E6%8E%A5%E5%8F%A3.png" target="_blank" rel="noopener"></a><br><a href="http://od2xrf8gr.bkt.clouddn.com/dao%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" target="_blank" rel="noopener"></a><br>然后就能在测试类中使用。测试类代码如下:<br><a href="http://od2xrf8gr.bkt.clouddn.com/%E6%B5%8B%E8%AF%95222.png" target="_blank" rel="noopener"></a></p><ul><li>1.<strong>dao的实现类中存在重复代码，整个mybatis操作的过程代码模板重复(都是先创建sqlSession、调用sqlSession的方法、关闭sqlSession)。</strong></li><li>2.<strong>dao的实现类中存在硬编码，调用sqlSession方法时将statement的id硬编码。</strong></li></ul><h4 id="mapper动态代理的方式"><a href="#mapper动态代理的方式" class="headerlink" title="mapper动态代理的方式"></a>mapper动态代理的方式</h4><p>程序员只需要写dao接口，dao接口实现对象由mybatis自动生成代理对象。因为本身dao在三层架构中就是一个通用的接口。<br>1.mapper开发规范：<br>要想让mybatis自动创建dao接口实现类的代理对象，必须要遵循一些规则:</p><pre><code>- **mapper.xml中 namespace指定为mapper接口的全限定名。此步骤的目的:将mapper.xml和mapper.java关联。**- mapper.xml中**statement的id就是mapper.java中的方法名。即对应相同**- mapper.xml中**statement的parameterType和mapper.java中方法输入参数一致。即参数一致**- **mapper.xml中statement的resultType和mapper.java中方法的返回值类型一致。即返回值一致**</code></pre><p>2.mapper.xml(映射文件)<br><img src="http://od2xrf8gr.bkt.clouddn.com/namespace.png" alt=""><br>3.mapper.java接口</p><pre><code>public interface UserMapper{};</code></pre><p>4.将mapper.xml在SqlMapConfing.xml中进行注册</p><pre><code>&lt;mappers&gt;     &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><p>5.mapper接口返回单个对象和集合对象<br>在UserMapper.java中添加如下两个方法:</p><pre><code>User findUserById(int id) throws Exception ;List&lt;User&gt; findUserByName (String username) throws Exception;</code></pre><p><strong>对于UserMapper.xml，不管你查询的记录是单条还是多条，在statement(即UserMapper.xml)中的resultType都定义一致，都是单条记录映射的pojo类型</strong></p><p><strong>而对于UserMapper.java接口方法中的返回值，如果返回的是单个对象，返回值类型是pojo，生成的代理对象内部会自动通过selectOne获取记录，如果返回值类型是多条对象，生成的代理对象内部会自动通过selectList获取记录。</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/ceshissss.png" alt=""></p><p><strong>UserMapper userMapper = sqlsession.getMapper(UserMapper.class)</strong></p><h3 id="注意-mapper动态代理开发的问题"><a href="#注意-mapper动态代理开发的问题" class="headerlink" title="注意:mapper动态代理开发的问题"></a>注意:mapper动态代理开发的问题</h3><pre><code>- 返回值的问题:如果方法(即UserMapper.java接口中的方法)调用的statement中返回是多条记录，而mapper.java方法的返回值为pojo，此时代理对象通过selectOne调用，但由于返回的是多条记录所以会报错:Expected one result (for null ) to be returned by selectOne() but found 4;- 输入参数的问题:使用mapper代理的方式开发，mapper接口方法的输入参数只有一个，可扩展性是否很差?答:可扩展性没有问题，因为dao层就是通用的，可以通过扩展pojo(定义pojo包装类型，后面第四篇文章–MyBatis输入输出映射会讲扩展pojo的知识)来将不同的参数(可以是pojo也可以是简单类型)传入进去</code></pre><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;SqlSession的使用范围&quot;&gt;&lt;a href=&quot;#SqlSession的使用范围&quot; class=&quot;headerlink&quot; title=&quot;SqlSession的使用范围&quot;&gt;&lt;/a&gt;SqlSession的使用范围&lt;/h3&gt;&lt;p&gt;1.SqlSessionFactor
      
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="MyBatis" scheme="http://codinglembre.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis学习之快速入门</title>
    <link href="http://codinglembre.top/2018/10/02/MyBatis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://codinglembre.top/2018/10/02/MyBatis学习之快速入门/</id>
    <published>2018-10-01T17:09:51.000Z</published>
    <updated>2018-10-02T01:53:13.416Z</updated>
    
    <content type="html"><![CDATA[<p>在学习框架之前，我们先弄明白为什么要学框架。首先个人认为<strong><em>简化开发并不是采用框架唯一的目的，更重要的是规范，不用框架时写出来的代码千奇百怪，各种凌乱，有框架的约束更容易制定规范，而简化的任务是基于框架再做一些有针对性的封装时该做的事。</em></strong> 而因为框架内部执行的复杂带来的性能损耗是要配合其他手段来优化的，比如连接池、缓存之类的，而这些手段是很容易通过框架间的整合融入进来的，如果你只用纯jdbc， 就比较困难，自己要做很多事情，还很难做好。框架整合封装完毕后，再来测试性能问题，单纯的执行一条SQL语句来判断效率是没有必要的，没什么实际价值，更多的应该是去看在并发的情况下、不同的业务场景、针对业务有效的优化后，再来看整个工程所有功能模块的平均效率，你才会做出合理的判断。项目代码<a href="https://github.com/Lembre/FirstMyBatis" target="_blank" rel="noopener"></a></p><a id="more"></a><h3 id="MyBatis框架的引入"><a href="#MyBatis框架的引入" class="headerlink" title="MyBatis框架的引入"></a>MyBatis框架的引入</h3><p>我们来看看传统的编程方式中使用jdbc的问题:</p><ul><li>数据库连接频繁的创建和关闭，缺点:浪费数据库的资源，影响操作效率。解决方法:<strong><em>使用数据库连接池如c3p0.</em></strong></li><li>sql语句是硬编码(不利用系统维护)，如果需求变更需要修改sql，这时候就需要修改java代码，然后需要重新编译，系统不易维护。解决方法:将sql语句统一配置在文件中。这样以后修改sql时就不需要修改java代码了。</li><li>我们通过preparedStatement对象向占位符设置参数，存在硬编码(参数位置、参数)问题，系统不易维护。解决方法:<strong><em>将sql中的占位符及对应的参数类型配置在配置文件中，能够自动输入的映射。</em></strong></li><li>遍历查询结果集存在硬编码(列名)。解决方法:<strong><em>自动进行sql查询结果向java对象的映射(输出映射)</em></strong></li></ul><h3 id="MyBatis的优点"><a href="#MyBatis的优点" class="headerlink" title="MyBatis的优点"></a>MyBatis的优点</h3><p><strong><em>MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身</em></strong>，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。<br>MyBatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。</p><h3 id="MyBatis架构"><a href="#MyBatis架构" class="headerlink" title="MyBatis架构"></a>MyBatis架构</h3><p>如下图:<br><img src="http://od2xrf8gr.bkt.clouddn.com/mybatis.png" alt=""></p><h3 id="MyBatis快速入门"><a href="#MyBatis快速入门" class="headerlink" title="MyBatis快速入门"></a>MyBatis快速入门</h3><ul><li>编写SqlMapConfig.xml</li><li>编写mapper.xml(每个字段定义一个statement)</li><li>编程通过配置文件创建SqlSessionFactory</li><li>通过SqlSessionFactory获取SqlSession对象。</li><li>通过SqlSession操作数据库。(如果执行添加、更新、删除需要调用SqlSession.commit())</li><li>SqlSesion使用完成要关闭。</li></ul><h4 id="准备开发环境"><a href="#准备开发环境" class="headerlink" title="准备开发环境"></a>准备开发环境</h4><p>1.创建测试项目，普通java项目或是web项目都可<br>2.导入jar包:mybatis-3.1.1.jar(低于这个版本的jar包需要导入很多依赖包)和mysql-connection-java<br>3.创建数据库和相应的表,SQL脚本如下:</p><pre><code>create database mybatis;use mybatis;create table user(  id int primary key auto_increment,  username varchar(50),   birthday date,  sex varchar(20),  address varchar(50));insert into user values(null,&apos;yzh&apos;,&apos;1996-09-14&apos;,&apos;male&apos;,null);insert into user values(null,&apos;pcl&apos;,&apos;1997-08-26&apos;,&apos;female&apos;,null);</code></pre><p>到此，环境配置就告一段落。</p><h4 id="使用MyBatis查询表中数据-通过id查询"><a href="#使用MyBatis查询表中数据-通过id查询" class="headerlink" title="使用MyBatis查询表中数据(通过id查询)"></a>使用MyBatis查询表中数据(通过id查询)</h4><p>1.添加Mybatis的配置文件SqlMapConfig.xml(名字可以随便起)</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!--和spring整合后，environments配置将废除--&gt;&lt;environments default=&quot;development&quot;&gt;&lt;environment id=&quot;development&quot;&gt;    &lt;!--使用JDBC事务管理--&gt;  &lt;transactionManager type=&quot;JDBC&quot;&gt;    &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;  &lt;/transactionManager&gt;    &lt;!--数据库连接池--&gt;  &lt;dataSource type=&quot;POOLED&quot;&gt;    &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;  &lt;/dataSource&gt;&lt;/environment&gt;&lt;/environments&gt;&lt;/configuration&gt;</code></pre><p>2.定义表所需要的实体类User.java<br>3.定义操作user表的sql映射文件User.xml<br>这里我们没将文件命名为userMapper.xml，后面我们会改。<br>文件内容如下:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;Message&quot;&gt;&lt;!--根据id查询用户信息--&gt;&lt;!--id为唯一标识#{}表示一个占位符，如果#{}传入的是简单类型的参数，那么他里面的名称随意，paramterType:输入参数的类型，通过占位符#{}接受paramterType传入的参数值resultType：输出结果参数--&gt;&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;entity.User&quot;&gt;    SELECT * from user WHERE id = #{id}&lt;/select&gt;&lt;/mapper&gt;</code></pre><p><strong><em>在User.xml中写SQL语句，在参数处使用占位符#{}，应该注意的是大括号{}中传入的数据应该与User.java中的属性对应，文件中各个属性的解释见图中注释处。</em></strong></p><p>4.在SqlMapConfig文件中注册User.xml文件<br><strong><em>在SqlMapConfig.xml中添加一个<mappers></mappers>字段，并在里面传入User.xml文件路径。</em></strong></p><p>5.接下来我们便可以借助上面MyBatis架构图来编写测试类了</p><pre><code>public class FirstMyBatis {private SqlSessionFactory sqlSqlSessFactory;//创建工厂@Beforepublic void init() throws IOException {    //配置文件    String resource = &quot;Configuration.xml&quot;;    //加载配置文件到输入流中    //InputStream inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);    InputStream inputStream = Resources.getResourceAsStream(resource);    //创建会话工厂    sqlSqlSessFactory = new SqlSessionFactoryBuilder().build(inputStream);}//根据id查找用户@Testpublic void testFindUserById(){    //通过sqlSqlSessFactory创建sqlSession    SqlSession sqlSession = sqlSqlSessFactory.openSession();    User user = null;    //通过sqlSession操作数据库    //第一个参数为statement的位置，等于namespace+statement的id    //第二个参数，传给占位符大的参数    user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1);    System.out.println(user);}}</code></pre><h4 id="使用MyBatis根据用户名模糊查询用户信息-通过name"><a href="#使用MyBatis根据用户名模糊查询用户信息-通过name" class="headerlink" title="使用MyBatis根据用户名模糊查询用户信息(通过name)"></a>使用MyBatis根据用户名模糊查询用户信息(通过name)</h4><p>1.需要在mapper.xml中添加以下字段:</p><pre><code>&lt;select id=&quot;findUserByNamr&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;entity.User&quot;&gt;    SELECT  * from user WHERE username like &apos;%${value}%&apos;&lt;/select&gt;</code></pre><p>此时，我们在传入参数的地方不再使用占位符#{}而是使用${}，二者区别如下:</p><ul><li>#{}:1.<strong><em>表示一个占位符，向占位符输入参数，mybatis自动进行java类型和jdbc类型的转换。</em></strong>2.<strong><em>程序员不需要考虑参数的类型，比如：传入字符串，mybatis最终拼接好的sql就是参数两边加单引号</em></strong>。3.#{}接收pojo(Plain Old Java Object Java数据对象)数据，可以使用OGNL(就是el表达式)解析出pojo的属性值。</li><li>${}:1.<strong><em>表示sql的拼接，通过${}接收参数，将参数的内容不加任何修饰拼接在sql中。</em></strong>2.${}也可以接收pojo数据，可以使用OGNL解析出pojo的属性值。3.缺点:不能防止sql注入</li></ul><p>什么是sql注入，怎样防止？<br><strong><em>，如果是直接拼接的方式那么就非常容易被注入</em></strong>。比如：select <em> from tablename where user=’admin’ and pwd =’123’ 假设说这个是一个登录的sql语句，admin是用户文本框输入的，pwd是密码框输入的。如果密码文本框如果输入：’ or ‘1’=’1 那么拼接起sql就是select </em> from tablename where user=’admin’ and pwd =’’ or ‘1’=’1’ 那么就会跳过sql的条件就直接进入登录，但是如果是使用绑定变量的就不一样</p><p>Demo：</p><pre><code>//测试根据name查询用户（得到多条记录）@Testpublic void testFindUserByName(){    //通过sqlSqlSessFactory创建sqlSession    SqlSession sqlSession = sqlSqlSessFactory.openSession();    List&lt;User&gt; list = null;    list = sqlSession.selectList(&quot;test.findUserByName&quot;,&quot;y&quot;);    sqlSession.close();    System.out.println(list.get(0).getUsername());}</code></pre><p>注意，此时我们通过name查询出来的语句为多条，<strong><em>故此时我们应该选择调用sqlSession对象的selectList()方法返回多条记录，输出我们查询到的第一条记录即可。若使用selectOne()方法，当返回的记录为多条时就会发生异常。</em></strong></p><p>这样我们便完成了查询时将sql结果输出映射到Java对象中。那如何将Java对象输入映射到sql语句中，接下来我们就来讲通过MyBatis实现增、删、改数据库。</p><h3 id="使用MyBatis向表中插入一条记录"><a href="#使用MyBatis向表中插入一条记录" class="headerlink" title="使用MyBatis向表中插入一条记录"></a>使用MyBatis向表中插入一条记录</h3><pre><code>&lt;insert id=&quot;insertUser&quot; parameterType=&quot;entity.User&quot;&gt;    INSERT INTO user VALUES (#{id},#{username},#{birthday},#{sex},#{address})&lt;/insert&gt;</code></pre><p>测试类:</p><pre><code>@Testpublic void testInsertUser(){    SqlSession sqlSession = sqlSqlSessFactory.openSession();    User user = new User();    user.setUsername(&quot;codingLembre&quot;);    user.setAddress(&quot;GuangDong&quot;);    user.setBirthday(new Date());    user.setSex(&quot;1&quot;);    sqlSession.insert(&quot;test.insertUser&quot;,user);    sqlSession.commit();    sqlSession.close();}</code></pre><p>此时查看数据库，发现数据已经被插入</p><blockquote><p><strong><em>注意插入和查询不一样需要sqlSession.commit();否则没有效果</em></strong></p></blockquote><p>Demo:<br><img src="https://i.imgur.com/uNUVLFS.png" alt=""></p><h3 id="拓展-主键返回"><a href="#拓展-主键返回" class="headerlink" title="拓展:主键返回"></a>拓展:主键返回</h3><p>在测试类中，我们没有给User对象的id属性设置值，所以我们在测试类中尝试输出User对象的id时会输出id=0，但是该对象通过输入映射在数据库中是有对应的id值的(因为我们为该字段设置了自增长属性)。那么我们想输出该对象在记录中的id时，又该怎么做呢？只需在User.xml文件中的<insert></insert>标签中添加<selectkey>标签即可,属性解释见图:</selectkey></p><pre><code>&lt;!--主键返回,order属性比那时该字段在insert语句之后才执行,还要借助函数--&gt;&lt;insert id=&quot;insertUserByKey&quot; parameterType=&quot;entity.User&quot;&gt;    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt;        SELECT LAST_INSERT_ID()    &lt;/selectKey&gt;    INSERT INTO user VALUES (#{id},#{username},#{birthday},#{sex},#{address})&lt;/insert&gt;</code></pre><p>此时我们在测试类中便可输出该User对象插入在表中的记录id值了。</p><blockquote><p><strong><em>如果未设置主键返回，那么sout(id)得到的都是0；</em></strong></p></blockquote><p>这里我们<strong><em>由于在建表时设置了id字段为自增长，采用自增长的形式生成主键，所以我们在传入User对象的id属性时可以将该属性设置为null。</em></strong>那么当我们使用uuid生成主键时又该怎么做呢？</p><pre><code>&lt;insert id=&quot;insertUserByUUID&quot; parameterType=&quot;entity.User&quot;&gt;    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;int&quot;&gt;        SELECT uuid()    &lt;/selectKey&gt;    INSERT INTO user VALUES (#{id},#{username},#{birthday},#{sex},#{address})&lt;/insert&gt;</code></pre><p>属性值”before”的意思表示在执行插入操作时，会先调用uuid()函数生成uuid得到主键，然后将主键设置到User对象中，再将User对象插入到数据库。所以此时我们在测试类中也可以不对User的id属性进行设置值。但是无法演示功能，因为user表已经设置为自动增长。</p><h4 id="使用MyBatis实现删除表中数据"><a href="#使用MyBatis实现删除表中数据" class="headerlink" title="使用MyBatis实现删除表中数据"></a>使用MyBatis实现删除表中数据</h4><p>因为和上述的操作差不多，注意commit即可，不再演示。</p><h4 id="使用MyBatis实现更新表中数据"><a href="#使用MyBatis实现更新表中数据" class="headerlink" title="使用MyBatis实现更新表中数据"></a>使用MyBatis实现更新表中数据</h4><p>因为和上述的操作差不多，注意commit即可，不再演示。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习框架之前，我们先弄明白为什么要学框架。首先个人认为&lt;strong&gt;&lt;em&gt;简化开发并不是采用框架唯一的目的，更重要的是规范，不用框架时写出来的代码千奇百怪，各种凌乱，有框架的约束更容易制定规范，而简化的任务是基于框架再做一些有针对性的封装时该做的事。&lt;/em&gt;&lt;/strong&gt; 而因为框架内部执行的复杂带来的性能损耗是要配合其他手段来优化的，比如连接池、缓存之类的，而这些手段是很容易通过框架间的整合融入进来的，如果你只用纯jdbc， 就比较困难，自己要做很多事情，还很难做好。框架整合封装完毕后，再来测试性能问题，单纯的执行一条SQL语句来判断效率是没有必要的，没什么实际价值，更多的应该是去看在并发的情况下、不同的业务场景、针对业务有效的优化后，再来看整个工程所有功能模块的平均效率，你才会做出合理的判断。项目代码&lt;a href=&quot;https://github.com/Lembre/FirstMyBatis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://codinglembre.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="MyBatis" scheme="http://codinglembre.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记之MySQL语法</title>
    <link href="http://codinglembre.top/2018/09/30/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BMySQL%E8%AF%AD%E6%B3%95/"/>
    <id>http://codinglembre.top/2018/09/30/MySQL学习笔记之MySQL语法/</id>
    <published>2018-09-30T03:27:08.000Z</published>
    <updated>2018-10-02T13:54:05.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h3><ul><li>DDL(Data Definition Language):数据定义语言，用来定义数据库对象：库、表、列等。功能：创建、删除、修改库和表结构。</li><li>DML(Data Manipulation Language):数据操作语言，用来定义数据库记录:增、删、改表记录。</li><li>DCL(Data Control Language):数据控制语言，用来定义访问权限和安全级别</li><li>DQL(Data Query Language):数据查询语言，用来查询记录。也是本章学习的重点。</li></ul><h3 id="SQL数据中的属性类型"><a href="#SQL数据中的属性类型" class="headerlink" title="SQL数据中的属性类型"></a>SQL数据中的属性类型</h3><ul><li>TINYINT:1字节，小整数值。</li><li>SMALLINT:2字节，大整数值。</li><li>MEDIUMINT:3字节，大整数值。</li><li>INT或INTEGER:4字节，整型,大整数值。</li><li>FLOAT:单精度浮点数值。</li><li>DOUBLE(5,2):双精度浮点型数值，参数表示该浮点型数值最多有5位，其中必须有2位小数。</li><li>DECIMAL(M,D):小数值,参数表示该数值最多有M位，其中必须有D位小数。</li><li>CHAR:字符型，<strong>固定长度字符串类型</strong>:char(255)。你存入一个a字符，虽然a只占一个字符，但是它会自动给你加254个空格凑成255个长度。即<strong>数据的长度不足指定长度，它会补足到指定长度。</strong></li><li>VARCHAR:<strong>可变长度字符串类型</strong>：varchar(65535),你存入的数据多长它就是多长。它会抽出几个字节来记录数据的长度。</li><li>TEXT(CLOB):mysql独有的数据类型，字符串类型。</li><li>BLOB:字节类型。</li><li>YEAR:年份值，格式为:YYYY</li><li>DATA:日期类型，格式为:yyyy-MM-dd。</li><li>TIME:时间类型，格式为:hh:mm:ss。</li><li>TIMESTAMP:时间戳类型，格式为上面二者的综合。</li><li>DATETIME:混合日期和时间值，格式为:YYYYMMDD HHMMSS.</li></ul><h3 id="SQL语句详解"><a href="#SQL语句详解" class="headerlink" title="SQL语句详解"></a>SQL语句详解</h3><h4 id="DDL-数据定义语言-语法"><a href="#DDL-数据定义语言-语法" class="headerlink" title="DDL(数据定义语言)语法"></a>DDL(数据定义语言)语法</h4><p>该语言用来<strong>对数据库和表结构</strong>进行操作。</p><p>对数据库的操作:</p><p>查看所有数据库:<strong><em>SHOW DATABASES;</em></strong></p><p>使用数据库:<strong>USE 数据库名</strong>;</p><p>创建数据库并指定编码:<strong>CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARACTER SET UTF8];</strong></p><p>删除数据库:<strong>DROP DATABASE 数据库名;</strong></p><p>修改数据库的编码:<strong>ALTER DATABASE 数据库名 CHARACTER SET UTF-8;</strong></p><p>对表结构的操作</p><p>创建表:</p><pre><code>CREATE TABLE (IF NOT EXISTS) 表名(列名 列类型，...，列名 列类型)；  </code></pre><p>查看当前数据库中所有表:<strong>SHOW TABLES;</strong></p><p>查看表结构:<strong>DESC 表名;</strong></p><p>删除表:<strong>DROP 表名;</strong></p><p>修改表:修改表有5个操作，但前缀都是一样的:<strong>ALTER TABLE 表名…</strong></p><pre><code>修改表之添加列:ALTER TABLE 表名 add (列名 列类型，...，列名 列类型);修改表之修改列类型:ALTER TABLE 表名 MODIFY 列名 列的新类型;修改表之列名称列类型一起修改:ALTER TABLE 表名 CHANGE 原列名 新列名 列名类型;修改表之删除列:ALTER TABLE 表名 DROP 列名;修改表之修改表名:ALTER TABLE 表名 RENAME TO 新表名</code></pre><h3 id="DML-数据操作语言-语法-增，删，改"><a href="#DML-数据操作语言-语法-增，删，改" class="headerlink" title="DML(数据操作语言)语法(增，删，改)"></a>DML(数据操作语言)语法(增，删，改)</h3><p>该语言用来<strong>对表记录操作(增、删、改)。</strong></p><h4 id="插入数据-一次插入就是插入一行"><a href="#插入数据-一次插入就是插入一行" class="headerlink" title="插入数据(一次插入就是插入一行)"></a>插入数据(一次插入就是插入一行)</h4><p><strong>insert into 表名 (列名1，列名2，列名3) values (列值1，列值2，列值3)</strong></p><p>说明:1.在数据库中所有的字符串类型，必须使用单引号。2.(列名1，列名2，列名3)可省略，表示按照表中的顺序插入。但不建议采取这种写法，因为降低了程序的可读性。3.<strong>在命令行插入记录不要写中文，否则会出现乱码</strong></p><h4 id="修改记录-不会修改一行"><a href="#修改记录-不会修改一行" class="headerlink" title="修改记录(不会修改一行)"></a>修改记录(不会修改一行)</h4><p>修改某列的全部值:update 表名 set 列名1=列值1(，列名2=列值2);</p><p>修改(某行或者多行记录的)列的指定值:update 表名 set 列名1=列值1 where 列名2=列值2 or 列名3=列值3;</p><p>运算符:=、!=、&lt;&gt;、&lt;、&gt;、&gt;=、&lt;=、between…and、in(…)、is null、not、or、and。</p><blockquote><p><strong>其中in(…)的用法表示集合。</strong>例如:update 表名 set 列名1=列值1 where 列名2=列值2 or 列名2=列值22用in(…)写成update 表名 set 列名1=列值1 where 列名2 in(列值2，列值3),具体效果如下图所示</p></blockquote><p><img src="https://i.imgur.com/ROVeEju.png" alt=""><br>执行命令并刷新数据库后:<br><img src="https://i.imgur.com/0zOSzBh.png" alt=""></p><h4 id="删除数据-删除整行"><a href="#删除数据-删除整行" class="headerlink" title="删除数据(删除整行)"></a>删除数据(删除整行)</h4><p>delete from 表名 (where 条件);<strong>不加where条件时会删除表中所有的记录，所以为了防止这种失误操作，很多数据库往往都会有备份。</strong></p><h3 id="DCL-数据控制语言-语法"><a href="#DCL-数据控制语言-语法" class="headerlink" title="DCL(数据控制语言)语法"></a>DCL(数据控制语言)语法</h3><p>该语言用来定义访问权限，理解即可，以后不会多用。需要记住的是，<strong>一个项目创建一个用户，一个项目对应的数据库只有一个。这个用户只能对这个数据库有权限，其它数据库该用户就操作不了。</strong></p><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>用户只能在指定ip地址上登录mysql:create user 用户名@IP地址 identified by ‘密码’；</p><p>用户可以在任意ip地址上登录:create user 用户名@‘％’ identified by ‘密码’；</p><h4 id="给用户授权"><a href="#给用户授权" class="headerlink" title="给用户授权"></a>给用户授权</h4><p>语法:<strong>grant 权限1，…，权限n on 数据库.* to 用户名@IP地址；其中权限1、2、n可以直接用all关键字代替。权限例如:create,alter,drop,insert,update,delete,select。</strong></p><h4 id="撤销授权"><a href="#撤销授权" class="headerlink" title="撤销授权"></a>撤销授权</h4><p>语法:revoke 权限1，…，权限n on 数据库.<em> from 用户名@ ip地址；撤销指定用户在指定数据库上的指定权限。撤销例如:revoke create,delete on mydb1.</em> form user@localhost;表示的意思是撤消user用户在数据库mydb1伤的create、alter权限。</p><h4 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h4><p>查看指定用户的权限:show grants for 用户名@ip地址；</p><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>drop user 用户名@ip地址；</p><h3 id="DQL-数据查询语言-语法-查"><a href="#DQL-数据查询语言-语法-查" class="headerlink" title="DQL(数据查询语言)语法(查)"></a>DQL(数据查询语言)语法(查)</h3><p>重点，该语言用来查询记录，不会修改数据库和表结构。</p><h4 id="基本查询-后缀都是统一为from-表名"><a href="#基本查询-后缀都是统一为from-表名" class="headerlink" title="基本查询(后缀都是统一为from 表名)"></a>基本查询(后缀都是统一为from 表名)</h4><ul><li>1.字段(列)控制<blockquote><p>1.查询所有列:select * from 表名;其中＊表示查询所有列，而不是所有行的意思。</p><p>2.查询指定列:select 列1，列2，列n from 表名；</p><p>3.完全重复的记录只显示一次:<strong><em>:select distinct $ from 表名；缺省值为all。</em></strong></p><p>4.列运算<br>  a.<strong><em>数量类型的列可以做加、减、乘、除</em></strong>:SELECT sal<em>5 from 表名；说明:1.**</em>遇到null加任何值都等于null的情况，需要用到ifnull()函数。2.将字符串做加减乘除运算，会把字符串当作0。<strong><em><br>  b.字符串累类型可以做连续运算(需要用到concat()函数):select concat(列名1，列名2) from 表名;其中列名的类型要为字符串。</em></strong>在mysql中不能使用+等运算符进行字符串的连接<strong><em><br>  c. </em></strong>给列名起别名:select 列名1 (as) 别名1,列名2 (as) 别名2 from 表名；***</p></blockquote></li><li><p>2.条件控制</p><blockquote><p>1.条件查询。在后面添加where指定条件:select * from 表名 where 列名＝指定值;</p><p>2.模糊查询：当你想查询所有姓张的记录。用到关键字like。eg:select <em> from 表名 where 列名 like ‘张_’;(**</em>_代表匹配任意一个字符，％代表匹配0～n个任意字符)。***</p></blockquote></li><li><p>3.聚合函数</p><ul><li>1.count:select count(列名) from 表名；,纪录有效行数。</li><li>2.max:select max(列名) from 表名；,列中最大值。</li><li>3.min:select min(列名) from 表名；,列中最小值。</li><li>4.sum:select sum(列名) from 表名；,求列的总值，null 和字符串默认为0。<ul><li>5.avg:select avg(列名) from 表名;,一列的平均值。</li></ul></li></ul></li><li><p>4排序(所谓升序和降序都是从上往下排列)</p><p>  1.升序:select <em> form 表名 order by 列名 (ASC ); ()里面的内容为缺省值；<br>  2.降序:select </em> from 表名 order by 列名 DESC;<br>  3.使用多列作为排序条件:<strong> 当第一列排序条件相同时，根据第二列排序条件排序(当第二列依旧相同时可视情况根据第三例条件排序)</strong>。eg:select * from 表名 order by 列名1 ASC, 列名2 DESC;意思是当列名1的值相同时按照列名2的值降序排。</p></li><li><p>5.分组查询<br><strong>分组查询的信息都是组的信息，不能查到个人的信息，其中查询组的信息是通过聚合函数得到的</strong>。</p></li></ul><p>语法：select 分组列名，聚合函数1,聚合函数2 from 表名 group by 该分组列名；其中分组列名需要的条件是该列名中有重复的信息。</p><p>查询的结果只能为：作为分组条件的列和聚合函数；查处的信息都是组的信息。</p><p>分组查询前，还可以通过关键字where先把满足条件的人分出来，再分组。语法为:select 分组列，聚合函数 from 表名 where 条件 group by 分组列；</p><p>分组查询后，也可以通过关键字having把组信息中满足条件的组再细分出来。语法为：select 分组列，聚合函数 from 表名 where 条件 group by 分组列 having 聚合函数或列名(条件)；</p><p><strong>分组查询的应用有查看每个部门的平均工资等等,而使用order by无法做到多条统计信息同时显示</strong></p><p><img src="https://i.imgur.com/wis98px.png" alt=""></p><ul><li>6.LIMIT子句<strong>(mysql中独有的语法)</strong><br>LIMIT用来限定查询结果的起始行，以及总行数。</li></ul><p>例如：select * from 表名 limit 4，3；<strong>表示起始行为第5行，一共查询3行记录。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>学过的关键字：select,from,where,group by,having ,order by。当一条查询语句中都包含所有这些关键字时它们的优先级是select&gt;from&gt;where&gt;group by&gt;having&gt;order by</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;SQL语句分类&quot;&gt;&lt;a href=&quot;#SQL语句分类&quot; class=&quot;headerlink&quot; title=&quot;SQL语句分类&quot;&gt;&lt;/a&gt;SQL语句分类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DDL(Data Definition Language):数据定义语言，用来定义数据库
      
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="数据库" scheme="http://codinglembre.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>String，StringBuilder和StringBuffer的区别</title>
    <link href="http://codinglembre.top/2018/09/30/Java%E4%B8%ADString%EF%BC%8CStringBuilder%E5%92%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://codinglembre.top/2018/09/30/Java中String，StringBuilder和StringBuffer的区别/</id>
    <published>2018-09-30T03:13:23.000Z</published>
    <updated>2018-09-30T12:51:41.676Z</updated>
    
    <content type="html"><![CDATA[<p>现在很多互联网公司面试java的面试官都喜欢问这样一个问题，那么就来谈谈java中String、StringBuilder和StringBuffer的区别。</p><a id="more"></a><h3 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h3><ul><li>String字符串常量</li><li>StringBuffer字符串变量(线程安全）</li><li>StringBuilder字符串变量（非线程安全）</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>所谓常量，即该对象的值已经被赋予了，不能再更改。若非要更改，则只能再重新创建另一个对象，在这个新创建的对象上再进行赋值。因此，每次在对String类型的对象进行改变的时候其实都等同于生成了一个新的String对象，然后将指针指向新的String对象，所以经常改变内容的字符串最好不要用String，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM的GC就会开始工作，那速度是一定会相当慢的。</p><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>所谓变量，即是可以随时变化的量。如果对StringBuffer对象进行改变，每次结果都会对StringBuffer对象进行操作，而不是生成新的对象。所以一般字符串要经常变化的话我推荐使用StringBuffer。</p><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>StringBuilder和StringBuffer类功能基本相似，方法也差不多，主要区别在于<strong><em>StringBuffer类的方法是多线程安全的，而StringBuilder不是线程安全的</em></strong>，相比而言<strong><em>StringBuilder类会略微快一点。</em></strong></p><h3 id="运行速度"><a href="#运行速度" class="headerlink" title="运行速度"></a>运行速度</h3><ul><li>Java中对String对象进行的操作实际上是一个<strong>不断创建新的对象并且将旧的对象回收的一个过程</strong>，所以执行速度很慢。</li><li>而StringBuilder和StringBuffer的对象是变量，<strong><em>对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作</em></strong>，所以速度要比String快很多。</li></ul><p>但是，有时候我们会这样对字符串进行赋值:</p><pre><code>String str=&quot;abc&quot;+&quot;de&quot;;StringBuilder stringBuilder=new StringBuilder().append(&quot;abc&quot;).append(&quot;de&quot;);System.out.println(str);System.out.println(stringBuilder.toString());</code></pre><p>这样输出结果也是“abcde”和“abcde”，但是<strong><em>String的速度却比StringBuilder的反应速度要快很多</em></strong></p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>如果<strong><em>一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字</em></strong>，所以可以保证线程是安全的，但<strong><em>StringBuilder的方法则没有该关键字，所以不能保证线程安全</em></strong>，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p><h3 id="使用须知"><a href="#使用须知" class="headerlink" title="使用须知"></a>使用须知</h3><ul><li><p>String：适用于少量的字符串操作的情况</p></li><li><p>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</p></li><li><p>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>现在很多互联网公司面试java的面试官都喜欢问这样一个问题</p><blockquote><p>请你谈谈StringBuffer和StringBuilder的区别。</p></blockquote><p>大多数人肯定会直接说前者是线程安全的而后者是非线程安全的。其实这个时候才是面试官真正想问的，他会顺着你的回答又问你，那请你谈谈什么是线程…balabalabala。哈哈，要想顺利通过面试，所以对知识的了解还是全面点吧～！</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在很多互联网公司面试java的面试官都喜欢问这样一个问题，那么就来谈谈java中String、StringBuilder和StringBuffer的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://codinglembre.top/categories/Java/"/>
    
    
      <category term="JavaSE" scheme="http://codinglembre.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习之监听器</title>
    <link href="http://codinglembre.top/2018/09/30/JavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>http://codinglembre.top/2018/09/30/JavaWeb学习之监听器/</id>
    <published>2018-09-30T01:50:52.000Z</published>
    <updated>2018-10-03T13:27:23.517Z</updated>
    
    <content type="html"><![CDATA[<p>监听器(Listener)其实就是一个<strong><em>实现特定接口的普通java程序</em></strong>，监听器是一个<strong><em>专门用于对其他对象身上(三大域对象)发生的事件或状态改变进行监听和相应处理的对象，它可以监听客户端请求和服务端的操作</em></strong>，当被监视的对象发生情况时，立即采取相应的行动。这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法立即被执行。</p><p>上述概念设计到3个名词概念:</p><ul><li>事件源:即谁产生的事件</li><li>事件对象:即产生了什么事件</li><li>监听器:监听事件源的动作</li></ul><p>由于事件源可以产生多个动作(即产生多个事件)，而<strong><em>监听器中的每一个方法监听一个动作，故每个监听器中都有很多方法。</em></strong></p><a id="more"></a><h3 id="JavaWeb中的监听器的概念"><a href="#JavaWeb中的监听器的概念" class="headerlink" title="JavaWeb中的监听器的概念"></a>JavaWeb中的监听器的概念</h3><p>JavaWeb中的监听器是Servlet规范中定义的一种特殊类，它用于监听web应用程序中的ServletContext、HttpSession和 ServletRequest这三大域对象的创建、销毁事件以及监听这些域对象中的属性发生修改的事件。<br><img src="https://i.imgur.com/9Em7yhT.png" alt=""><br><img src="https://i.imgur.com/45msGDS.png" alt=""></p><p>其中，<strong>Java中的ServletContext对象对应JSP的application对象（上下文对象，由容器创建和初始化），HTTPSession对象对应JSP的session对象（保存上下文对象的机制，放在服务器端，通过sessionID区分的，服务器关闭和结束时销毁），ServletRequest对象（容器创建时创建的对象，来进行封装请求对象，同时还会创建ServletResponse对象）对应JSP中的request对象。</strong></p><p><strong>总而言之，就是监听这三个对象的创建销毁和属性的变化</strong></p><h3 id="JavaWeb中监听器的分类"><a href="#JavaWeb中监听器的分类" class="headerlink" title="JavaWeb中监听器的分类"></a>JavaWeb中监听器的分类</h3><p>在Servlet规范中定义了多种类型的监听器(一共8个监听器)，它们用于监听的事件源分别为ServletContext，HttpSession和ServletRequest这三个域对象。Servlet规范针对这三个对象上的操作，又把多种类型的监听器划分为三种类型：</p><ul><li><p>域对象的生命周期监听:<strong>监听域对象自身的创建和销毁</strong>。这个监听器需要实现相应的监听器接口:ServletContextListener(<strong>定时器和全局属性对象</strong>)、HttpSessionListener(<strong>统计在线人数和记录访问日志</strong>)、ServletRequestListener(<strong>读取参数和记录访问历史</strong>)。<br>关于的ServletContext的Demo:<br>在配置文件web.xml配置:<br>  <context-param></context-param></p><pre><code>&lt;param-name&gt;initParam&lt;/param-name&gt;&lt;param-value&gt;codingLembre&lt;/param-value&gt;</code></pre><p>  <br>然后可以在<strong>实现ServletContextListener接口的类中可以获取到相应的配置</strong>:</p><p>  public void contextInitialized(ServletContextEvent sce) {</p><pre><code>sce.getServletContext().getInitParameter(&quot;initParam&quot;);</code></pre><p><strong>结合之前的过滤器的学习，由此我们也可以知道配置文件中的配置和对应的映射的接口实现类中的参数的一些微妙的关系，在此之前我一直不懂</strong></p></li><li>域对象的属性监听:<strong>监听域对象中属性的增加和删除。</strong>这个监听器需要实现的监听器接口为:ServletContextAttributeListener、HttpSessionAttributeListener、ServletRequestAttributeListener</li><li>感知监听(<strong>监听绑定到HTTPSession域中的某个对象的状态的事件监听器</strong>):监听绑定到HttpSession域中的某个JavaBean对象的状态的监听器。这个监听器需要实现的监听器接口:HttpSessionBindingListener、HttpSessionActiveationListener</li></ul><h3 id="第一类-域对象的生命周期监听"><a href="#第一类-域对象的生命周期监听" class="headerlink" title="第一类:域对象的生命周期监听"></a>第一类:域对象的生命周期监听</h3><p>事件源为:三大域<br>事件对象为:创建与销毁<br>监听器为:实现了ServletContextListener、HttpSessionListener、ServletRequestListener这三个接口的监听器</p><h4 id="ServletContext的生命周期监听"><a href="#ServletContext的生命周期监听" class="headerlink" title="ServletContext的生命周期监听"></a>ServletContext的生命周期监听</h4><pre><code>public class AListener implements ServletContextListener{public void contextInitialized(ServletContextEvent sce){  //在项目启动时调用}public void contextDestroyed(ServletContextEvent sce){  //在项目关闭时调用}}</code></pre><p>需要在web.xml文件中进行配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/alistern.png" alt=""></p><h4 id="HttpSession的生命周期监听"><a href="#HttpSession的生命周期监听" class="headerlink" title="HttpSession的生命周期监听"></a>HttpSession的生命周期监听</h4><pre><code>public class AListener implements HttpSessionListener{public void sessionCreated(HttpSessionEvent sce){  //在会话产生时调用}public void sessionDestroyed(HttpSessionEvent sce){  //在会话关闭时调用}}</code></pre><p>需要在web.xml文件中进行配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/alistern.png" alt=""></p><h4 id="ServletRequest的生命周期"><a href="#ServletRequest的生命周期" class="headerlink" title="ServletRequest的生命周期"></a>ServletRequest的生命周期</h4><pre><code>public class AListener implements ServletRequestListener{public void requestInitialized(ServletRequestEvent sce){  //在请求产生时调用}public void requestDestroyed(ServletRequestEvent sce){  //在请求关闭时调用}}</code></pre><p>需要在web.xml文件中进行配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/alistern.png" alt=""></p><h4 id="对各个监听器接口的方法中出现的类介绍"><a href="#对各个监听器接口的方法中出现的类介绍" class="headerlink" title="对各个监听器接口的方法中出现的类介绍"></a>对各个监听器接口的方法中出现的类介绍</h4><p>ServletContextEvent类:<strong><em>类中有一个方法getServletContext(),该方法返回ServletContext对象。</em></strong><br>HttpSessionEvent类:类中有一个方法<strong><em>getSession()，该方法返回一个HttpSession对象。</em></strong><br>ServletRequestEvent类:类中有两个方法，<strong><em>getServletContext()用于返回一个ServletContext对象，getServletRequest()用于返回一个ServletRequest对象。</em></strong></p><h3 id="第二类-域对象的属性监听"><a href="#第二类-域对象的属性监听" class="headerlink" title="第二类:域对象的属性监听"></a>第二类:域对象的属性监听</h3><p>事件源:三大域<br>事件对象:属性的增加与删除<br>监听器:实现了ServletContextAttributeListener、HttpSessionAttributeListener、ServletRequestAttributeListener接口的监听器</p><h4 id="ServletContext的属性监听"><a href="#ServletContext的属性监听" class="headerlink" title="ServletContext的属性监听"></a>ServletContext的属性监听</h4><pre><code>public class AListener implements ServletContextAttributeListener{public void attributeAdded(ServletcontextAttribute scab){  //给ServletContext对象添加属性时调用}public void attributeRemoved(ServletContextAttributeEvent scab){//给ServletContext对象删除属性时调用}public void attributeReplaced(ServletContextAttributeEvent scab){//给ServletContext对象替换属性值时调用}}</code></pre><p>同样需要在web.xml文件中对AListener进行配置。</p><h4 id="HttpSession的属性监听"><a href="#HttpSession的属性监听" class="headerlink" title="HttpSession的属性监听"></a>HttpSession的属性监听</h4><pre><code>public class AListener implements HttpSessionAttributeListener{public void attributeAdded(HttpSessionAttribute scab){  //给HttpSession对象添加属性时调用}public void attributeRemoved(HttpSessionAttributeEvent scab){//给HttpSession对象删除属性时调用}    public void attributeReplaced(HttpSessionAttributeEvent scab){//给HttpSession对象替换属性值时调用}}</code></pre><p>同样需要在web.xml中对AListener进行配置。</p><h4 id="ServletRequest的属性监听"><a href="#ServletRequest的属性监听" class="headerlink" title="ServletRequest的属性监听"></a>ServletRequest的属性监听</h4><pre><code>public class AListener implements ServletRequestAttributeListener{public void attributeAdded(ServletRequestAttribute scab){  //给ServletRequest对象添加属性时调用}public void attributeRemoved(ServletRequestAttributeEvent scab){//给ServletRequest对象删除属性时调用}public void attributeReplaced(ServletRequestAttributeEvent scab){//给ServletRequest对象替换属性值时调用}}</code></pre><h4 id="对各个监听器接口的方法中出现的类介绍-1"><a href="#对各个监听器接口的方法中出现的类介绍-1" class="headerlink" title="对各个监听器接口的方法中出现的类介绍"></a>对各个监听器接口的方法中出现的类介绍</h4><p>ServletContextAttributeEvent类:该类对象有三个方法，<strong><em>getSevletContext()用于返回一个ServletContext，getName()用于返回属性名，getValue()用于返回属性值。</em></strong></p><p>HttpSessionBindingEvent类:该类对象有两个方法，<strong><em>getName()用于获取属性名，getValue()用于获取属性值。</em></strong></p><p>ServletRequestAttributeEvent类:该类对象有两个方法，<strong><em>getName()用于获取属性名，getValue()用于获取属性值。</em></strong></p><h3 id="感知监听器"><a href="#感知监听器" class="headerlink" title="感知监听器"></a>感知监听器</h3><p>在此之前先了解一下<strong>Session对象的几种状态机制</strong></p><ul><li>绑定:Session对象持久化到存储设备中</li><li>解除绑定:Session对象从存储设备中回复</li><li>钝化机制:session过多，session在服务器内存中的开销将十分巨大，直接影响Web服务器的性能。此时，服务器自动将不常用的session将被序列化到系统文件或数据库中，使用时再由服务器自动反序列化到服务器内存中。这个机制由SessionManager管理，它的管理机制:<br><img src="https://i.imgur.com/CRoZZlF.png" alt=""><br><img src="https://i.imgur.com/xpTMe4F.png" alt=""></li></ul><p><strong><em>保存在Session域中的对象可以有多种状态：绑定(session.setAttribute(“bean”,Object))到Session中,随Session对象持久化到一个存储设备中；从Session域中解除(session.removeAttribute(“bean”))绑定,随Session对象从一个存储设备中恢复。</em></strong></p><p>Servlet 规范中定义了两个特殊的监听器接口<strong><em>”HttpSessionBindingListener和HttpSessionActivationListener”来帮助JavaBean 对象了解自己在Session域中的这些状态，实现这两个接口的类不需要 web.xml 文件中进行注册。</em></strong><br><img src="https://i.imgur.com/ZDuyKUI.png" alt=""></p><h4 id="HttpSessionBindingListener接口"><a href="#HttpSessionBindingListener接口" class="headerlink" title="HttpSessionBindingListener接口"></a>HttpSessionBindingListener接口</h4><p>实现了HttpSessionBindingListener接口的JavaBean对象可以感知自己被绑定到Session中和 Session中删除的事件。</p><p>当对象被绑定到HttpSession对象中时，web服务器调用该对象的void valueBound(HttpSessionBindingEvent event)方法。</p><p>当对象从HttpSession对象中解除绑定时，web服务器调用该对象的void valueUnbound(HttpSessionBindingEvent event)方法。</p><pre><code>public class JavaBeanDemo1 implements HttpSessionBindingListener { private String name; @Override public void valueBound(HttpSessionBindingEvent event) {     System.out.println(name+&quot;被加到session中了&quot;); } @Override public void valueUnbound(HttpSessionBindingEvent event) {     System.out.println(name+&quot;被session踢出来了&quot;); } public String getName() {     return name; } public void setName(String name) {     this.name = name; } public JavaBeanDemo1(String name) {     this.name = name; }}</code></pre><p>上述的JavaBeanDemo1这个javabean实现了HttpSessionBindingListener接口，那么这个JavaBean对象可以感知自己被绑定到Session中和从Session中删除的这两个操作。</p><h3 id="HttpSessionActivationListener接口"><a href="#HttpSessionActivationListener接口" class="headerlink" title="HttpSessionActivationListener接口"></a>HttpSessionActivationListener接口</h3><p><strong><em>实现了HttpSessionActivationListener接口的JavaBean对象可以感知自己被活化(反序列化)和钝化(序列化)的事件。</em></strong></p><p>当绑定到HttpSession对象中的javabean对象将要随HttpSession对象被钝化(序列化)之前，web服务器调用该javabean对象的void sessionWillPassivate(HttpSessionEvent event) 方法。这样javabean对象就可以知道自己将要和HttpSession对象一起被序列化(钝化)到硬盘中。</p><p>当绑定到HttpSession对象中的javabean对象将要随HttpSession对象被活化(反序列化)之后，web服务器调用该javabean对象的void sessionDidActive(HttpSessionEvent event)方法。这样javabean对象就可以知道自己将要和 HttpSession对象一起被反序列化(活化)回到内存中。(javabean随着HttpSession对象一起被活化的前提是该javabean对象除了实现该接口外还应该实现Serialize接口)。</p><pre><code>public class JavaBeanDemo2 implements HttpSessionActivationListener,    Serializable {private static final long serialVersionUID = 7589841135210272124L;private String name;@Overridepublic void sessionWillPassivate(HttpSessionEvent se) {    System.out.println(name+&quot;和session一起被序列化(钝化)到硬盘了，session的id是：&quot;+se.getSession().getId());} @Overridepublic void sessionDidActivate(HttpSessionEvent se) {    System.out.println(name+&quot;和session一起从硬盘反序列化(活化)回到内存了，session的id是：&quot;+se.getSession().getId());}public String getName() {    return name;}public void setName(String name) {           this.name = name;}public JavaBeanDemo2(String name) {    this.name = name;}</code></pre><p>   }</p><p>***如果某个类(ja888vabean对象)实现了HttpSessionActiveationListener接口后，当对象随着session被钝化和活化时，下面两个方法就会被调用</p><pre><code>public void sessionWillPassivate(HttpSessionEvent se):当对象感知被活化时调用本方法。  public void sessionDidActivate(HttpSessionEvent se):当对象感知被钝化时调用本方法。</code></pre><h3 id="Servlet3-0新特性，注解监听器"><a href="#Servlet3-0新特性，注解监听器" class="headerlink" title="Servlet3.0新特性，注解监听器"></a>Servlet3.0新特性，注解监听器</h3><p><strong>使用@WebListener，该注解用于将类声明为监听器，但是没有定义顺序的标识</strong><br><img src="https://i.imgur.com/oN7iBId.png" alt=""></p><p>这是使用注解和两个监听器实现的实时统计在线人数及IP信息<a href="https://github.com/Lembre/SessionManager" target="_blank" rel="noopener">github源代码</a></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>监听器的启动加载顺序和在web.xml中的注册顺序有关</strong>，当同时存在监听器，过滤器和Servlet时，加载顺序为:<br><img src="https://i.imgur.com/e5cGadN.png" alt=""></p><h3 id="监听域对象属性变化的实际应用"><a href="#监听域对象属性变化的实际应用" class="headerlink" title="监听域对象属性变化的实际应用"></a>监听域对象属性变化的实际应用</h3><p>待更新</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;监听器(Listener)其实就是一个&lt;strong&gt;&lt;em&gt;实现特定接口的普通java程序&lt;/em&gt;&lt;/strong&gt;，监听器是一个&lt;strong&gt;&lt;em&gt;专门用于对其他对象身上(三大域对象)发生的事件或状态改变进行监听和相应处理的对象，它可以监听客户端请求和服务端的操作&lt;/em&gt;&lt;/strong&gt;，当被监视的对象发生情况时，立即采取相应的行动。这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法立即被执行。&lt;/p&gt;
&lt;p&gt;上述概念设计到3个名词概念:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件源:即谁产生的事件&lt;/li&gt;
&lt;li&gt;事件对象:即产生了什么事件&lt;/li&gt;
&lt;li&gt;监听器:监听事件源的动作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于事件源可以产生多个动作(即产生多个事件)，而&lt;strong&gt;&lt;em&gt;监听器中的每一个方法监听一个动作，故每个监听器中都有很多方法。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="JavaWeb" scheme="http://codinglembre.top/tags/JavaWeb/"/>
    
      <category term="Servlet" scheme="http://codinglembre.top/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习之AJAX</title>
    <link href="http://codinglembre.top/2018/09/29/JavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8BAJAX/"/>
    <id>http://codinglembre.top/2018/09/29/JavaWeb学习之AJAX/</id>
    <published>2018-09-29T09:23:38.000Z</published>
    <updated>2018-09-30T03:27:24.191Z</updated>
    
    <content type="html"><![CDATA[<p>客户端向服务器发送请求，若服务器每次响应过来的结果都要重新加载整个界面的话这样会给服务器带来很大的压力。所以ajax出现了，它是在不重新加载整个页面的情况下与服务器交换数据并更新部分网页的技术，是一种使用现有标准的新方法。Ajax在很多方面都有应用，比如，搜索引擎:在搜索引擎中输入关键字，会出现一个下拉框，列出网络上与关键字相关的字眼。注册:注册页面上填写完用户名后移开光标，会显示该用户名是否已被注册。淘宝某个店铺下方的评论框:翻页时的异步操作。</p><a id="more"></a><h3 id="AJAX概念"><a href="#AJAX概念" class="headerlink" title="AJAX概念"></a>AJAX概念</h3><ul><li>1.asynchronous javascript and xml，翻译过来就是<strong><em>异步的javascript</em></strong>和xml。</li><li>2.它能使用javascript语言访问服务器，而且是异步访问。</li><li>3.服务器给客户端的响应一般是整个页面，一个html完整页面但在ajax中因为是局部刷新，那么服务器就不用再响应整个页面而只是响应局部。</li></ul><h3 id="服务器向客户端返回的数据类型"><a href="#服务器向客户端返回的数据类型" class="headerlink" title="服务器向客户端返回的数据类型"></a>服务器向客户端返回的数据类型</h3><p>一般客户端向服务器发送请求，服务器返回的数据类型有三种:</p><ul><li>text类型:返回的数据是纯文本。</li><li>xml类型:返回的数据是xml格式，它是提供js和java交互的数据格式</li><li>json类型:它也是提供js和java交互的数据格式，在ajax中最受欢迎。</li></ul><h3 id="理解同步交互和异步交互"><a href="#理解同步交互和异步交互" class="headerlink" title="理解同步交互和异步交互"></a>理解同步交互和异步交互</h3><ul><li>同步交互:<ul><li>发一个请求，就要等待服务器的响应结束，然后才能发送第二个请求</li><li>刷新的是整个页面</li></ul></li><li>异步交互:<ul><li>发一个请求，无需等待服务器的响应，然后就可以发第二个请求。</li><li>可以使用js来接受服务器的响应，然后使用js来局部刷新界面。</li></ul></li></ul><p>附上uml图解释这两者的区别:<br><img src="src=&quot;http://od2xrf8gr.bkt.clouddn.com/ajax.png&quot;" alt=""></p><h3 id="ajax的优缺点"><a href="#ajax的优缺点" class="headerlink" title="ajax的优缺点"></a>ajax的优缺点</h3><ul><li>优点:<ul><li>异步交互，增强了用户的体验。</li><li>性能:因为服务器无需再响应整个页面，只需要响应部分内容，所以服务器的压力减轻了</li></ul></li><li>缺点:<ul><li>ajax不能应用在所有场景</li><li>ajax无端的增多了对服务器的访问次数，给服务器带来了压力(比较上述优点，在减少了服务器压力的同时又给服务器带来了压力，不知你理不理解哈哈)</li></ul></li></ul><h3 id="如何使用ajax来发送异步请求"><a href="#如何使用ajax来发送异步请求" class="headerlink" title="如何使用ajax来发送异步请求"></a>如何使用ajax来发送异步请求</h3><h4 id="第一步-首先要得到XMLHttpRequest"><a href="#第一步-首先要得到XMLHttpRequest" class="headerlink" title="第一步(首先要得到XMLHttpRequest)"></a>第一步(首先要得到XMLHttpRequest)</h4><p>大多数浏览器都只是得到该对象的方法为:var xmlHttp=new XMLHttpRequest();<br>IE6.0得到的方法为:var xmlHttp = new ActiveXObject(“Msxml2.XMLHTTP”);<br>IE5.0以及更早版本的IE:var xmlHttp=new ActiveXObject(“Microsoft.XMLHTTP”);<br>在&lt;script&gt;中编写创建XMLHttpRequest对象的函数:</p><pre><code>function createXMLHttpRequest(){    try{        return new XMLHttpRequest();    }catch(e){        try{            return new ActiveXObject(“Msxml2.XMLHTTP”);        }catch(e){            try{                return new ActiveXObject(“Microsoft.XMLHTTP”);            }catch(e){                alert(“哥们，你用的是什么浏览器啊”);                throw e;            }        }    }}</code></pre><h4 id="第二步-打开与服务器的连接"><a href="#第二步-打开与服务器的连接" class="headerlink" title="第二步(打开与服务器的连接)"></a>第二步(打开与服务器的连接)</h4><p>xmlHttp.open(“”,””,boolean):用来打开与服务器的连接，它需要三个参数。1.请求参数，可以是get可以是post。2.请求的url:指定服务器端资源。3.请求是否异步，如果为true表示发送异步请求，否则发送同步请求。例如xmlHttp.open(“GET”,”项目名称/AServlet”,true);</p><h4 id="第三步-发送请求"><a href="#第三步-发送请求" class="headerlink" title="第三步(发送请求)"></a>第三步(发送请求)</h4><p>xmlHttp.send(参数):参数为请求体内容。如果请求方式是get，则参数为null(不可以省略null)，因为get请求方式的请求体为空;如果请求方式为post，则参数为请求体，另外还需要在此方法前面增加一个mlHttp.setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”);设置请求头的方法</p><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>给xmlHttp对象注册onreadystatechange监听器，这个方法用于接收从服务器发送过来的响应数据。 在该方法中需要做以下步骤:</p><ul><li>获取xmlHttp对象的状态，xmlHttp对象一共有5个状态:<ul><li>0状态:表示xmlHttp对象刚创建，还没有调用open()方法。</li><li>1状态：请求开始，调用了open方法，但还没有调用send方法</li><li>调用完了send方法</li><li>服务器已经开始响应，但不表示响应结束了</li><li>服务器响应结束(通常我们只关心这个状态)</li></ul></li></ul><p>该状态通过调用xmlHttp.readyState得到。</p><ul><li>得到服务器响应的状态码:通过调用xmlHttp.status得到，例如200，404，500。</li><li><p>得到服务器响应的内容，由于服务器返回的类型不同，所以得到的内容类型也不同，以下3种类型采用3种方法得到:</p><ul><li>var content=xmlHttp.responseText;//服务器返回的文本为text。</li><li>var content=xmlHttp.responseXML;//服务器响应的文本为xml内容。xmlHttp会自动对xml文本进行解析，得到的content为document对象。</li><li><p>var content=eval(“(“+xmlHttp.responsetext+”)”);//服务器返回的文本为json数据。<br>完成第四步我们需要写的完整代码为:</p><p>//xmlHttp的5种状态都会调用本方法<br>xmlHttp.onreadystatechange=function(){<br>if(xmlHttp.readState==4&amp;&amp;xmlHttp.status==200){//双重判断:判断是否为4状态，而且还要判断是否为200<br>  //获取服务器的响应内容<br>  var content=xmlHttp.responseText;//或var content= xmlHttp.responseXML;<br>}<br>}</p></li></ul></li></ul><h3 id="案例-省市联动"><a href="#案例-省市联动" class="headerlink" title="案例:省市联动"></a>案例:省市联动</h3><p>说明，该案例就是在网页上显示两个下拉列表，一个列表用于显示中国所有的省份，一个列表用于显示相应省份下的城市，当然这些数据是存在数据库中的，为了方便展示，我只在数据库中列举了两个省份和部分城市。<br><img src="http://od2xrf8gr.bkt.clouddn.com/province.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/city.png" alt=""><br>servlet包下的CityServlet.java与ProvinceServlet.java，用于向客户端发送响应数据代码如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/cityservlet.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/provinceservlet.png" alt=""><br>dao包下的ProvinceDao.java代码如下:用于与数据库连接:<br><img src="http://od2xrf8gr.bkt.clouddn.com/provincedao.png" alt=""></p><p>最终要的界面代码关于ajax的操作,代码如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/ajax1.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/ajax2.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/ajax3.png" alt=""><br>数据库中的表有两张，一张是省份表province,一张是城市表city,如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/city2.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/province2.png" alt=""><br>结果如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/jiemian.png" alt=""><br>当选择了相应的省份时，ajax会立即向服务器发送请求，然后服务器返回该省份下所有的城市，ajax将这些城市动态的显示在”请选择城市”列表中。达到部分刷新界面的效果。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;客户端向服务器发送请求，若服务器每次响应过来的结果都要重新加载整个界面的话这样会给服务器带来很大的压力。所以ajax出现了，它是在不重新加载整个页面的情况下与服务器交换数据并更新部分网页的技术，是一种使用现有标准的新方法。Ajax在很多方面都有应用，比如，搜索引擎:在搜索引擎中输入关键字，会出现一个下拉框，列出网络上与关键字相关的字眼。注册:注册页面上填写完用户名后移开光标，会显示该用户名是否已被注册。淘宝某个店铺下方的评论框:翻页时的异步操作。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://codinglembre.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaWeb" scheme="http://codinglembre.top/tags/JavaWeb/"/>
    
      <category term="AJAX" scheme="http://codinglembre.top/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习之过滤器</title>
    <link href="http://codinglembre.top/2018/09/29/JavaWeb%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://codinglembre.top/2018/09/29/JavaWeb学习之过滤器/</id>
    <published>2018-09-29T06:57:43.000Z</published>
    <updated>2018-10-03T10:09:27.938Z</updated>
    
    <content type="html"><![CDATA[<p><strong>过滤器可以动态的拦截请求和响应，以变换或使用包含在请求或响应中的信息。</strong>过滤器是可用于Servlet编程的Java类，可以实现以下目的:</p><ul><li><strong>在客户端的请求访问后端资源之前，拦截这些请求。</strong></li><li><strong>在服务器的响应发送回客户端之前，处理这些响应。</strong></li></ul><p><strong><em>当 Web 容器启动 Web 应用程序时，它会为你在部署描述符中声明的每一个过滤器创建一个实例。<br>Filter的执行顺序与在web.xml配置文件中的配置顺序一致</em></strong>，一般把Filter配置在所有的Servlet之前</p><a id="more"></a><h3 id="过滤器的工作原理"><a href="#过滤器的工作原理" class="headerlink" title="过滤器的工作原理"></a>过滤器的工作原理</h3><p><img src="https://i.imgur.com/BsjScWk.png" alt=""></p><p>由此可知，过滤时跳转页面如果使用重定向的方式，那么会造成过滤死循环。所以要用重定向。因为一次请求就加载一次过滤器，而转发是服务器内部转发，是一次请求。</p><h3 id="过滤器的生命周期"><a href="#过滤器的生命周期" class="headerlink" title="过滤器的生命周期"></a>过滤器的生命周期</h3><p><img src="https://i.imgur.com/4fG4alR.png" alt=""></p><h3 id="如何编写过滤器"><a href="#如何编写过滤器" class="headerlink" title="如何编写过滤器"></a>如何编写过滤器</h3><p>1.创建一个类，必须实现Filter接口<br>2.在web.xml中进行配置，一般把Filter配置在所有的Servlet配置之前<br><img src="http://od2xrf8gr.bkt.clouddn.com/filter.png" alt=""><br>方法介绍:</p><ul><li>void init():Filter的初始化，Filter在服务器启动时就创建，创建之后马上执行这个方法。用来初始化一些参数</li><li>void doFilter(req,resp,chain):当向服务器请求的Servlet或jsp页面在过滤器的过滤范围内时,就会执行这个方法。若方法体中没有<strong><em>chain.doFilter()操作</em></strong>，则表示,当向服务器请求该过滤器过滤范围内的资源(如Servlet/JSP页面/html页面等)时，这些资源中的所有方法都不会执行(被过滤掉了);若方法体中有chain.doFilter()操作，表示不对过滤器过滤范围内的资源进行过滤。(即你请求的资源下的方法会执行)</li><li>void destroy():在服务器关闭时对Filter进行销毁，在Filter销毁之前会执行这个方法，用来对非内存资源进行释放。</li></ul><p>对方法中涉及到的类介绍:</p><ul><li>FilterConfig:与ServletConfig相似，该类有如下四个方法:<ul><li>getInitParameter():获取初始化参数。</li><li>getInitParameterNames():获取所有初始化参数的名称</li><li>getFilterName():获取过滤器的配置名称。</li><li>getServletContext():获取application。</li></ul></li><li>FilterChain类:该类中有一个方法:<ul><li><strong>doFilter():是不是会觉得该方法与Filter接口中的doFilter()方法是一样的呢？没错，二者虽然外观看起来一样，但功能却是千差万别的。该方法被FilterChain对象调用，表示对Filter过滤器过滤范围下的资源进行放行。</strong></li></ul></li></ul><h3 id="多过滤器的执行顺序"><a href="#多过滤器的执行顺序" class="headerlink" title="多过滤器的执行顺序"></a>多过滤器的执行顺序</h3><p>Web应用程序可以根据特定的目的定义若干个不同的过滤器，那么就需要在web.xml中对多个过滤器进行多个配置。而<strong>在web.xml中使用<filter-mapping>来控制多个过滤器的执行顺序，即哪个过滤器的<filter-mapping>配置在web.xml中的顺序排在前面那这个过滤器就先执行。</filter-mapping></filter-mapping></strong></p><h3 id="过滤器的四种拦截方式"><a href="#过滤器的四种拦截方式" class="headerlink" title="过滤器的四种拦截方式"></a>过滤器的四种拦截方式</h3><ul><li>拦截直接请求方式:REQUEST</li><li>拦截请求转发方式:FORWARD</li><li>拦截请求包含方式:INCLUDE</li><li>拦截错误转发方式:ERROR</li></ul><p>实现不同的拦截方式需要在中进行不同的配置:</p><ul><li><dispatcher>REQUEST</dispatcher></li><li><dispatcher>FORWORD</dispatcher></li><li><dispatcher>INCLUDE</dispatcher></li><li><dispatcher>ERROR</dispatcher></li></ul><p><strong>若在web.xml配置文件中没有写出上面四个拦截配置时默认该过滤器只拦截请求</strong></p><h3 id="过滤器的应用场景"><a href="#过滤器的应用场景" class="headerlink" title="过滤器的应用场景"></a>过滤器的应用场景</h3><p>1.执行目标资源之前做”预处理”工作，例如<strong>设置编码，这种通常都会放行，只是在目标资源执行之前做一些准备工作。</strong>(例如：几乎是所有的Servlet中都需要写request.setCharacteEncoding(),可以把它放入到一个Filter中。）这种过滤器没有拦截功能。<br>2.<strong>通过条件判断是否放行，例如校验当前用户是否已经登录，或者用户IP是否已经被禁用。(有拦截操作) (粗粒度权限控制，会员有会员的权利、游客有游客的权利)。</strong><br>3.在目标资源执行后，做一些后续的特殊处理工作。例如把目标资源输出的数据进行处理。</p><h3 id="案例1-分IP统计网站的访问次数"><a href="#案例1-分IP统计网站的访问次数" class="headerlink" title="案例1:分IP统计网站的访问次数"></a>案例1:分IP统计网站的访问次数</h3><p>功能分析:1.<strong>统计工作需要在所有资源之前都执行</strong>，那么就可以放到Filter中了。2.我们这个过滤器不打算做拦截操作，因为我们只是用来做统计的。3.用什么东西来装载统计的数据。Map，整个网站只需要一个Map即可4.Map什么时候创建(使用ServletContextListener，在服务器启动时完成创建，并保存到SevletContext中)，Map保存到哪里:Map需要在Filter中用来保存数据;Map需要在页面使用，打印Map中的数据。</p><p>AListener.java:<br><img src="http://od2xrf8gr.bkt.clouddn.com/AListener.png" alt=""><br>AFilter.java:<br><img src="http://od2xrf8gr.bkt.clouddn.com/AFilter.png" alt=""><br>show.jsp:<br><img src="http://od2xrf8gr.bkt.clouddn.com/showjsp.png" alt=""></p><h3 id="案例2-解决全站字符乱码问题"><a href="#案例2-解决全站字符乱码问题" class="headerlink" title="案例2:解决全站字符乱码问题"></a>案例2:解决全站字符乱码问题</h3><p>对于通过jsp页面请求转发到servlet时，若请求方式为POST且请求参数包含中文参数时，我们需要在servlet的doPost()方法中设置POST请求编码问题:request.setCharacterEncoding(“utf-8”);、设置响应编码问题:response.setContentType(“text/html;charset=utf-8”);,这样便可以解决post请求即响应编码问题；</p><p>而对于GET请求，若传递的请求参数包含中文参数时设置请求编码就比较麻烦，需要在servlet的doGet()方法中设置响应编码:response.setContentType(“text/html;charset=utf-8”);以及请求编码:首先获得传递给servlet的请求参数:String username=request.getParameter(“username”)假设传递的请求参数为username,然后再输入代码username=new String(username.getBytes(“ISO8859-1”),”utf-8”);，这样通过jsp页面转发到servlet的参数便解决了编码问题。即可以通过response.getWrite().prinltn(username)正常显示在网页上。</p><p>试想:以后的开发中往往会用到很多的servlet，那我们岂不是要在每一个servlet的doPost()和doGet方法中都写上上述的解决编码代码？这时候我们就可以通过过滤器来解决了</p><p>首先附上页面:</p><pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;$Title$&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;a href=&quot;&lt;c:url value=&quot;/AServlet?username=张三&quot;/&gt; &quot;&gt;点击这里&lt;/a&gt;   &lt;form action=&quot;&lt;c:url value=&quot;/AServlet&quot;/&gt; &quot; method=&quot;post&quot;&gt;        用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;李四&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;  &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>通过”点击这里”的链接我们便完成了通过jsp页面向servlet发送GET请求参数，通过”提交”按钮我们便完成了通过jsp页面向servlet发送POST请求参数。创建一个servlet,我们在servlet中完成响应参数编码的问题</p><pre><code>public class AServlet extends HttpServlet {protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    response.setContentType(&quot;text/html;charset=utf-8&quot;);}protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    response.setContentType(&quot;text/html;charset=utf-8&quot;);}}</code></pre><p>接下来在过滤器中完成请求参数编码的问题，创建一个过滤器Filter，在web.xml中注册:</p><pre><code>&lt;filter&gt;       &lt;filter-name&gt;Filter&lt;/filter-name&gt;       &lt;filter-class&gt;filter.Filter&lt;/filter-class&gt;   &lt;/filter&gt;   &lt;filter-mapping&gt;       &lt;filter-name&gt;Filter&lt;/filter-name&gt;       &lt;url-pattern&gt;/*&lt;/url-pattern&gt;   &lt;/filter-mapping&gt;</code></pre><p>Filter中编码为:</p><pre><code>public class Filter implements javax.servlet.Filter {public void destroy() {}public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException {       }public void init(FilterConfig config) throws ServletException {}}</code></pre><p><strong>对于POST请求参数的编码设置我们直接在doFilter()方法体中添加request.setCharacterEncoding(“utf-8”);代码即可</strong>(此时运行程序，POST请求参数编码的问题成功解决)，对于GET请求参数的编码，有些同学会觉得直接在doFilter()方法体中添加</p><blockquote><p>String  username=request.getParameter(“username”);username=new String(username.getBytes(“ISO-8859-1”),”utf-8”);</p></blockquote><p>这样的参数是不太靠谱的，因为这里我们知道要传递的请求参数为username所以这里可以明了的指出，以后我们不知道请求参数为什么或者请求参数有很多时那就需要更多的上诉代码，<strong>所以这里我们采用装饰者模式对request进行装饰，这就是装饰者模式</strong>(即将本来的request换成我们自己写的request)，创建一个EncodingRequest.java继承HttpServletRequestWrapper,代码如下:</p><pre><code>public class EncodingRequest extends HttpServletRequestWrapper{private HttpServletRequest req;public EncodingRequest(HttpServletRequest request){    super(request);    this.req=request;}@Overridepublic String getParameter(String name) {    String value=req.getParameter(name);    //处理编码问题    try {        value=new String(value.getBytes(&quot;ISO-8859-1&quot;),&quot;utf-8&quot;);    } catch (UnsupportedEncodingException e) {        e.printStackTrace();    }    return value;}}</code></pre><p>在构造方法中，我们<strong>传入系统的request,然后将这个request赋值给我们自己编写的req,然后在重写的getParameter()方法中通过我们自己写的req获取请求参数并解决编码问题，然后返回解决完编码后的参数value(此时这个中文参数已解决编码),然后在Filer中对我们自己编写的request(即Encodingquest对象)放行即可</strong>。现在doFilter()方法的方法体为:</p><pre><code> public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException {    //处理post请求编码问题    request.setCharacterEncoding(&quot;utf-8&quot;);    HttpServletRequest req= (HttpServletRequest) request;    /**     * 处理get请求的编码问题     */    //  String username=request.getParameter(&quot;username&quot;);    //  username=new String(username.getBytes(&quot;ISO-8859-1&quot;),&quot;utf-8&quot;);    /**     * 调包request     * 1.写一个request的装饰类     * 2.在放行时，使用我们自己的request     */        EncodingRequest er = new EncodingRequest(req);        chain.doFilter(er, response);}</code></pre><p>在学习框架之前我们都这样通过Filter解决编码问题，而当我们学习了Spring MVC框架后我们处理POST请求参数的编码问题时直接在web.xml中添加如下配置而不用再写一个过滤器:</p><pre><code>&lt;filter&gt;&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;&lt;init-param&gt;&lt;param-name&gt;encoding&lt;/param-name&gt;&lt;param-value&gt;utf-8&lt;/param-value&gt;&lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p><strong>解决GET请求方式的编码问题时有两种解决方法:1.修改tomcat配置文件添加编码与工程编码一致</strong>，如下:</p><blockquote><connector uriencoding="utf-8" connectiontimeout="20000" port="8080" protocol="HTTP/1.1" redirectport="8443"></connector></blockquote><p>2.<strong><em>对参数进行重新编码</em></strong>:</p><pre><code>String userName new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</code></pre><p><strong>第二种方法需要对每个参数都进行重新编码，比较麻烦。<br>回归我们的过滤器讲解，通过如上包装request的方式便可以通过过滤器解决全站编码问题。</strong></p><h3 id="案例3登录和编码转换整合案例"><a href="#案例3登录和编码转换整合案例" class="headerlink" title="案例3登录和编码转换整合案例"></a>案例3登录和编码转换整合案例</h3><p>首先看代码:<br>LoginServlet.java</p><pre><code>public class LoginServlet extends HttpServlet {public LoginServlet() {    super();}public void destroy() {    super.destroy(); // Just puts &quot;destroy&quot; string in log    // Put your code here}public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    String username = request.getParameter(&quot;username&quot;);    String password = request.getParameter(&quot;password&quot;);    System.out.println(username);    if(&quot;admin&quot;.equals(username) &amp;&amp; &quot;admin&quot;.equals(password)){        //检验通过        HttpSession session = request.getSession();        session.setAttribute(&quot;username&quot;, username);        response.sendRedirect(request.getContextPath()+&quot;/sucess.jsp&quot;);    }else{        //校验失败        response.sendRedirect(request.getContextPath()+&quot;/fail.jsp&quot;);    }}public void init() throws ServletException {    // Put your code here}}</code></pre><p>LoginFilter.java</p><pre><code>public class LoginFilter implements Filter {private FilterConfig config;@Overridepublic void destroy() {}@Overridepublic void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException {    HttpServletRequest request = (HttpServletRequest) arg0;    HttpServletResponse response = (HttpServletResponse) arg1;    HttpSession session = request.getSession();    String noLoginPaths = config.getInitParameter(&quot;noLoginPaths&quot;);    String charset = config.getInitParameter(&quot;charset&quot;);    if(charset==null){        charset = &quot;UTF-8&quot;;//如果没有指定charset的话，将charset设置为UTF-8    }    request.setCharacterEncoding(charset);    if(noLoginPaths!=null){        String[] strArray = noLoginPaths.split(&quot;;&quot;);        for (int i = 0; i &lt; strArray.length; i++) {            if(strArray[i]==null || &quot;&quot;.equals(strArray[i]))continue;            if(request.getRequestURI().indexOf(strArray[i])!=-1 ){                arg2.doFilter(arg0, arg1);                return;            }        }    }    if(session.getAttribute(&quot;username&quot;)!=null){        arg2.doFilter(arg0, arg1);//已经存在session对象了，允许通过过滤器    }else{        response.sendRedirect(&quot;login.jsp&quot;);//防止任何人通过直接输入相对应的登录成功地网址都直接访问这个页面。除非是本人而且浏览器没关闭过    }}@Overridepublic void init(FilterConfig arg0) throws ServletException {    config = arg0;//怎么得到这个初始化参数呢？参数指的是&lt;param-name&gt;noLoginPaths&lt;/param-name&gt;        //&lt;param-value&gt;login.jsp;fail.jsp;LoginServlet&lt;/param-value&gt;}</code></pre><p>web.xml</p><pre><code>&lt;servlet&gt;    &lt;description&gt;This is the description of my J2EE component&lt;/description&gt;    &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt;    &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/servlet/LoginServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;welcome-file-list&gt;    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;&lt;filter&gt;    &lt;filter-name&gt;LoginFilter&lt;/filter-name&gt;    &lt;filter-class&gt;filter.LoginFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;noLoginPaths&lt;/param-name&gt;        &lt;param-value&gt;login.jsp;fail.jsp;LoginServlet&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;charset&lt;/param-name&gt;        &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;LoginFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;/web-app&gt;&lt;!--  &lt;init-param&gt;        &lt;param-name&gt;noLoginPaths&lt;/param-name&gt;        &lt;param-value&gt;login.jsp;fail.jsp;LoginServlet&lt;/param-value&gt;  &lt;/init-param&gt;这里是配置不过滤的路径--&gt;</code></pre><p>本来未配置初始化参数时的写法:<br><img src="https://i.imgur.com/OnRRPVm.png" alt=""><br><strong>但是随着需要忽略过滤路径写法的页面越来越多，这种写法特别麻烦，不符合java开发原则，因此应该改用配置参数的写法，这里注意一下。</strong></p><p>点击获取github源代码<a href="https://github.com/Lembre/LoginFilter" target="_blank" rel="noopener"></a></p><h3 id="异步过滤器"><a href="#异步过滤器" class="headerlink" title="异步过滤器"></a>异步过滤器</h3><p><strong>待更新</strong></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;过滤器可以动态的拦截请求和响应，以变换或使用包含在请求或响应中的信息。&lt;/strong&gt;过滤器是可用于Servlet编程的Java类，可以实现以下目的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在客户端的请求访问后端资源之前，拦截这些请求。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在服务器的响应发送回客户端之前，处理这些响应。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;当 Web 容器启动 Web 应用程序时，它会为你在部署描述符中声明的每一个过滤器创建一个实例。&lt;br&gt;Filter的执行顺序与在web.xml配置文件中的配置顺序一致&lt;/em&gt;&lt;/strong&gt;，一般把Filter配置在所有的Servlet之前&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="JavaWeb" scheme="http://codinglembre.top/tags/JavaWeb/"/>
    
      <category term="Servlet" scheme="http://codinglembre.top/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>Java之反射机制</title>
    <link href="http://codinglembre.top/2018/09/29/Java%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://codinglembre.top/2018/09/29/Java之反射机制/</id>
    <published>2018-09-29T06:09:12.000Z</published>
    <updated>2018-10-02T13:59:20.494Z</updated>
    
    <content type="html"><![CDATA[<p>通俗地说,<strong>反射机制就是可以把一个类,类的成员(函数,属性),当成一个对象来操作,希望读者能理解,也就是说,类,类的成员,我们在运行的时候还可以动态地去操作他们。</strong>反射机制的利用其实我们经常在用，比如数据库JDBC中通过Class.forName(Driver).来获得数据库连接驱动；再比如，工厂模式：Factory类中用反射的话，添加了一个新的类之后，就不需要再修改工厂类Factory；<strong>访问一些不能访问的变量或属性：破解别人代码。</strong></p><a id="more"></a><h3 id="理论介绍"><a href="#理论介绍" class="headerlink" title="理论介绍"></a>理论介绍</h3><p>为了便于理解，在给出代码例子之前，首先用文字给大家说说关于”Java反射机制”的理论介绍。<br><strong>Java反射是Java语言的一个很重要的特征，它使得Java具有了“动态性”。</strong><br>在Java运行时环境中，对于一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？答案是肯定的。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java语言的反射(Reflection)机制。</p><h3 id="Java反射机制提供的功能"><a href="#Java反射机制提供的功能" class="headerlink" title="Java反射机制提供的功能"></a>Java反射机制提供的功能</h3><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li></ul><p><strong>Reflection是Java被视为动态(或准动态)语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，包括modifiers(诸如public,static等等)、superclass(例如Object)、实现之interfaces(例如Serializable)，也包括fields和methods的所有信息，并可于运行时改变fields内容或调用methods。</strong></p><p>一般而言，开发者社群说到动态语言，大致认同的一个定义是:“程序运行时，允许改变程序结构或变凉类型，这种语言成为动态语言”。从这个观点看，Java就不是动态语言。</p><p>尽管在这样的定义与分类下Java不是动态语言，它却有着一个非常突出的动态相关机制:Reflection。这个字的意思是“反射、映像、倒影”，用在Java身上指的是我们可以于运行时加载、探知、使用编译器件完全未知的classes。换句话说，Java程序可以加在一个运行时才得知名称的class，获悉其完整构造(但不包括methods定义)，并生成其对象实体、或对其fields设值、或唤起其methods。这种“看透class”的能力(the ability of the program to examine itselt)被称为introspection(内省、内观、反省)。Reflection和introspection是常被并提的两个术语。</p><h3 id="Java反射机制的API"><a href="#Java反射机制的API" class="headerlink" title="Java反射机制的API"></a>Java反射机制的API</h3><ul><li>Class类：代表一个类。</li><li>field类：代表类的成员变量(成员变量也被称为类的属性)</li><li>Method类：代表类的方法</li><li>Constructor类：代表类的构造方法。</li><li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法。</li></ul><h3 id="获得Class对象"><a href="#获得Class对象" class="headerlink" title="获得Class对象"></a>获得Class对象</h3><p><strong>Java中每个类被加载之后，系统就会为该类生成一个对应的Class对象，通过该Class对象就可以访问到JVM中的这个类。</strong>在Java程序中获得Class对象通常有如下三种方式。</p><ul><li>1.使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定类名(必须包括完整包名)。</li></ul><blockquote><p>代码示例：Class clazz=Class.forName(“demo.Person”);”Demo”代表包名，”Person”代表类名。</p></blockquote><ul><li>2.调用某个类的class属性来获取该类对应的Class对象，例如，Person.class将会返回Person类对应的Class对象</li></ul><blockquote><p>代码示例：Class clazz=Person.class;</p></blockquote><ul><li>3.调用某个对象的getClass()方法，该方法是java.lang.Object类中的一个方法，所以所有的Java对象都可以调用该方法，该方法将会返回该对象所属类对应的Class对象。</li></ul><blockquote><p>代码示例:Person person=new Person();<br>Class clazz=person.getClass();</p></blockquote><p>Class对象可以获得该类里的方法(由Method对象表示)、构造器(由Constructor对象表示)、成员变量(由Field)对象表示，这三个类都位于java.lang.reflect包下并实现了java.lang.reflect.Member接口。程序可以通过Method对象来执行对应的方法，通过Constructor对象来调用对应的构造器创建实例，能通过Field对象直接访问并修改对象的成员变量值。</p><h3 id="创建实例对象"><a href="#创建实例对象" class="headerlink" title="创建实例对象"></a>创建实例对象</h3><p>通过反射来生成实例对象有如下两种方式。</p><ul><li>1.使用Class对象的newInstance()方法来创建该Class对应类的实例，这种方式要求该Class对象的对应类有默认构造器，而执行newInstance()时实际上是利用默认构造器来创建该类的实例。</li></ul><blockquote><p>代码示例:Class clazz=Person.class;<br>Object obj=clazz.newInstance();</p></blockquote><ul><li>先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例。通过这种方式可以选择使用指定的构造器来创建实例。</li></ul><blockquote><p>代码示例:Class clazz=Person.class;<br>Constructor constructor=clazz.getConstructor(String.class);<br>Object obj=constructor.newInstance();</p></blockquote><p>请看，示例:<a href="https://blog.csdn.net/ljphhj/article/details/12858767" target="_blank" rel="noopener">一个例子让你了解Java反射机制</a></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通俗地说,&lt;strong&gt;反射机制就是可以把一个类,类的成员(函数,属性),当成一个对象来操作,希望读者能理解,也就是说,类,类的成员,我们在运行的时候还可以动态地去操作他们。&lt;/strong&gt;反射机制的利用其实我们经常在用，比如数据库JDBC中通过Class.forName(Driver).来获得数据库连接驱动；再比如，工厂模式：Factory类中用反射的话，添加了一个新的类之后，就不需要再修改工厂类Factory；&lt;strong&gt;访问一些不能访问的变量或属性：破解别人代码。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://codinglembre.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="JavaSE" scheme="http://codinglembre.top/tags/JavaSE/"/>
    
      <category term="框架" scheme="http://codinglembre.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习笔记之JSTL标签库</title>
    <link href="http://codinglembre.top/2018/09/29/JavaWeb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BJSTL%E6%A0%87%E7%AD%BE%E5%BA%93/"/>
    <id>http://codinglembre.top/2018/09/29/JavaWeb学习笔记之JSTL标签库/</id>
    <published>2018-09-29T01:27:23.000Z</published>
    <updated>2018-10-02T13:57:42.094Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JSTL标签库介绍"><a href="#JSTL标签库介绍" class="headerlink" title="JSTL标签库介绍"></a>JSTL标签库介绍</h3><p>JSTL标签库的使用是为弥补html标签的不足，规范自定义标签的使用而诞生的。<strong>使用JSLT标签的目的就是不希望在jsp页面中出现java逻辑代码</strong>。<strong>JSTL也是对EL表达式的扩展(也就是说JSTL依赖EL)，是一门标签语言</strong>。JSTL标签使用起来非常方便，它与JSP动作标签一样，只不过它不是JSP内置的标签，需要我们自己导包，一定要指定标签库。</p><p>如果你使用MyEclipse开发JavaWeb，那么把项目发布到Tomcat时，你会发现MyEclipse在lib目录下自动存放了JSTL的Jar包。如果你使用其他IDE，那么你需要手动导入这个JSTL的Jar包:jstl-1.2.jar。</p><h3 id="JSTL标签库的分类"><a href="#JSTL标签库的分类" class="headerlink" title="JSTL标签库的分类"></a>JSTL标签库的分类</h3><ul><li>core:核心标签库(用得最多)</li><li>fmt:国际化标签库(只需学习两个，日期和数字)</li><li>sql:数据库标签库(过时了，不需要学习)</li><li>xml:xml标签库(过时了，不需要学习)</li></ul><h3 id="核心标签库使用说明"><a href="#核心标签库使用说明" class="headerlink" title="核心标签库使用说明"></a>核心标签库使用说明</h3><p>JSTL的核心标签库标签共13个，使用这些标签能够完成JSP页面的基本功能，减少编码工作。<br>从功能上可以分为4类:表达式控制标签、流程控制标签、循环标签、URL操作标签。</p><ul><li>表达式控制标签:out标签、set标签、remove标签、catch标签</li><li>流程控制标签:if标签、choose标签、when标签、otherwise标签</li><li>循环标签:forEach标签、forTokens标签</li><li>URL操作标签</li></ul><p>在JSP页面引入核心标签库的代码为:</p><pre><code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code></pre><h4 id="表达式控制标签——out标签使用"><a href="#表达式控制标签——out标签使用" class="headerlink" title="表达式控制标签——out标签使用"></a>表达式控制标签——out标签使用</h4><h5 id="lt-c-out-gt-标签的功能"><a href="#lt-c-out-gt-标签的功能" class="headerlink" title="&lt;c:out&gt;标签的功能"></a>&lt;c:out&gt;标签的功能</h5><p><strong>&lt;c:out&gt;标签主要是用来输出数据对象(字符串、表达式)的内容或结果。</strong><br>在使用Java脚本输出时常使用的方式为:<strong>&lt;% out.println(“字符串”); %&gt;或者&lt;%=表达式 %&gt;</strong>，在web开发中，<strong>为了避免暴露逻辑代码会尽量减少页面中的Java脚本</strong>，使用&lt;c:out&gt;标签就可以实现以上功能。</p><pre><code>&lt;c:out value=&quot;字符串&quot;/&gt;或者&lt;c:out value=&quot;EL表达式&quot;/&gt;  </code></pre><p>JSTL的使用是和EL表达式分不开的，<strong>EL表达式虽然可以直接将结果返回给页面，但有时得到的结果为空，&lt;c:out&gt;有特定的结果处理功能，EL的单独使用会降低程序的易读性，建议把EL的结果输入放入&lt;c:out&gt;标签中。</strong></p><h5 id="lt-c-out-gt-标签的语法"><a href="#lt-c-out-gt-标签的语法" class="headerlink" title="&lt;c:out&gt;标签的语法"></a>&lt;c:out&gt;标签的语法</h5><p>&lt;c:out&gt;标签的使用有两种语法格式:</p><ul><li>语法1:&lt;c:out value=”要显示的数据对象” [escapeXml=”true|false”][default=”默认值”]/&gt;</li><li>语法2:&lt;c:out value=”要显示的数据对象” [escapeXml=”true|false”]&gt;默认值&lt;/c:out&gt;</li></ul><p>这两种方式没有本质的区别，只是格式上的差别。[escapeXml=”true|false”][defult=”默认值”]这些使用[]属性表示是不是必须的。</p><h5 id="lt-c-out-gt-标签的属性"><a href="#lt-c-out-gt-标签的属性" class="headerlink" title="&lt;c:out&gt;标签的属性"></a>&lt;c:out&gt;标签的属性</h5><p><img src="https://i.imgur.com/zs1yvH1.png" alt=""></p><blockquote><p>default 指定如果value属性的值为null时所输出的默认值<br>注意，这个会直接输出到页面，不管你有没有把他放到table标签中。和&lt;% out.println(“字符串”)的效果一样。</p></blockquote><h5 id="lt-c-out-gt-标签的使用范例"><a href="#lt-c-out-gt-标签的使用范例" class="headerlink" title="&lt;c:out&gt;标签的使用范例"></a>&lt;c:out&gt;标签的使用范例</h5><pre><code>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%--引入JSTL核心标签库 --%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;JSTL: --表达式控制标签“out”标签的使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;&lt;c:out value=&quot;下面的代码演示了c:out的使用，以及在不同属性值状态下的结果。&quot;/&gt;&lt;/h3&gt;&lt;hr/&gt;&lt;ul&gt;&lt;%--（1）直接输出了一个字符串。 --%&gt;&lt;li&gt;（1）&lt;c:out value=&quot;JSTL的out标签的使用&quot; /&gt;&lt;/li&gt;&lt;li&gt;（2）&lt;c:out value=&quot;&lt;a href=&apos;http://www.cnblogs.com/&apos;&gt;点击链接到博客园&lt;/a&gt;&quot; /&gt;&lt;/li&gt;&lt;%--escapeXml=&quot;false&quot;表示value值中的html标签不进行转义，而是直接输出 --%&gt;&lt;li&gt;（3）&lt;c:out value=&quot;&lt;a href=&apos;http://www.cnblogs.com/&apos;&gt;点击链接到博客园&lt;/a&gt;&quot; escapeXml=&quot;false&quot;/&gt;&lt;/li&gt;&lt;%--(4）字符串中有转义字符，但在默认情况下没有转换。 --%&gt;&lt;li&gt;（4）&lt;c:out value=&quot;&amp;lt未使用字符转义&amp;gt&quot; /&gt;&lt;/li&gt;&lt;%--（5）使用了转义字符&amp;lt和&amp;gt分别转换成&lt;和&gt;符号。 --%&gt;&lt;li&gt;（5）&lt;c:out value=&quot;&amp;lt使用字符转义&amp;gt&quot; escapeXml=&quot;false&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;&lt;%--（6）设定了默认值，从EL表达式${null}得到空值，所以直接输出设定的默认值。 --%&gt;&lt;li&gt;（6）&lt;c:out value=&quot;${null}&quot;&gt;使用了默认值&lt;/c:out&gt;&lt;/li&gt;&lt;%--（7）未设定默认值，输出结果为空。 --%&gt;&lt;li&gt;（7）&lt;c:out value=&quot;${null}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;&lt;%--（8）设定了默认值，从EL表达式${null}得到空值，所以直接输出设定的默认值。 --%&gt;&lt;li&gt;（8）&lt;c:out value=&quot;${null}&quot; default=&quot;默认值&quot;/&gt;&lt;/li&gt;&lt;%--（9）未设定默认值，输出结果为空。 --%&gt;&lt;li&gt;（9）&lt;c:out value=&quot;${null}&quot;/&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; </code></pre><p>运行结果如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/1.png" alt=""></p><h3 id="表达式控制标签——set标签的使用"><a href="#表达式控制标签——set标签的使用" class="headerlink" title="表达式控制标签——set标签的使用"></a>表达式控制标签——set标签的使用</h3><h4 id="lt-c-set-gt-标签的功能"><a href="#lt-c-set-gt-标签的功能" class="headerlink" title="&lt;c:set&gt;标签的功能"></a>&lt;c:set&gt;标签的功能</h4><p>&lt;c:set&gt;标签用于把某一个对象存在指定的域范围内，或者将某一个对象存储到Map或者JavaBean对象中。</p><h4 id="lt-c-set-gt-标签的语法"><a href="#lt-c-set-gt-标签的语法" class="headerlink" title="&lt;c:set&gt;标签的语法"></a>&lt;c:set&gt;标签的语法</h4><p>&lt;c:set&gt;标签的编写共有4种语法格式。</p><ul><li>语法1:存值，把一个值放在指定的域范围内.&lt;c:set value=”值1” var=”name1” [scope=”page|request|session|application”]/&gt;<br>含义:把一个变量名为name1值为“值1”的变量存储在指定的scope范围内。</li><li>语法2:&lt;c:set var=”name2” [scope=”page|request|session|application”]&gt;值2&lt;/c:set&gt;<br>含义：把一个变量名为name2，值为值2的变量存储在指定的scope范围内</li><li>语法3: &lt;c:set value=”值3” target=”JavaBean对象” property=”属性名”/&gt;<br>含义:把一个值为“值3”赋值给指定的JavaBean的属性名。相当与setter()方法</li><li>语法4: &lt;c:set target=”JavaBean对象” property=”属性名”&gt;值4&lt;/c:set&gt;<br>含义：把一个值4赋值给指定的JavaBean的属性名</li></ul><p>从功能上分语法1和语法2、语法3和语法4的效果是一样的，只是把value值放置的位置不同，至于使用那个根据个人的喜爱，语法1和语法2是向scope范围内存储一个值，语法3和语法4是给指定的JavaBean赋值。</p><h4 id="lt-c-set-gt-标签的属性"><a href="#lt-c-set-gt-标签的属性" class="headerlink" title="&lt;c:set&gt;标签的属性"></a>&lt;c:set&gt;标签的属性</h4><p><img src="https://i.imgur.com/j22yi14.png" alt=""></p><blockquote><p>注意，有的属性并不支持EL表达式</p></blockquote><h4 id="lt-c-set-gt-标签的使用范例"><a href="#lt-c-set-gt-标签的使用范例" class="headerlink" title="&lt;c:set&gt;标签的使用范例"></a>&lt;c:set&gt;标签的使用范例</h4><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%--引入JSTL核心标签库 --%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;%--使用JSP的指令元素指定要使用的JavaBean --%&gt;&lt;jsp:useBean id=&quot;person&quot; class=&quot;javabean.Person&quot;/&gt;&lt;%--负责实例化Bean，id指定实例化后的对象名，可以通过${person}得到person在内存中的值（或者使用person.toString()方法）。 --%&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;JSTL: --表达式控制标签“set”标签的使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;代码给出了给指定scope范围赋值的示例。&lt;/h3&gt;&lt;ul&gt;&lt;%--通过&lt;c:set&gt;标签将data1的值放入page范围中。--%&gt;&lt;li&gt;把一个值放入page域中:&lt;c:set var=&quot;data1&quot; value=&quot;xdp&quot; scope=&quot;page&quot;/&gt;&lt;/li&gt;&lt;%--ta使用EL表达式从pageScope得到da1的值。--%&gt;&lt;li&gt;从page域中得到值：${pageScope.data1}&lt;/li&gt;&lt;%--通过&lt;c:set&gt;标签将data2的值放入request范围中。--%&gt;&lt;li&gt;把一个值放入request域中:&lt;c:set var=&quot;data2&quot; value=&quot;gacl&quot; scope=&quot;request&quot;/&gt;&lt;/li&gt;&lt;%--使用EL表达式从requestScope得到data2的值。--%&gt;&lt;li&gt;从request域中得到值：${requestScope.data2}&lt;/li&gt;&lt;%--通过&lt;c:set&gt;标签将值name1的值放入session范围中。--%&gt;&lt;li&gt;把一个值放入session域中。&lt;c:set value=&quot;孤傲苍狼&quot; var=&quot;name1&quot; scope=&quot;session&quot;&gt;&lt;/c:set&gt;&lt;/li&gt;&lt;%--使用EL表达式从sessionScope得到name1的值。--%&gt;&lt;li&gt;从session域中得到值:${sessionScope.name1} &lt;/li&gt;&lt;%--把name2放入application范围中。 --%&gt;&lt;li&gt;把一个值放入application域中。&lt;c:set var=&quot;name2&quot; scope=&quot;application&quot;&gt;白虎神皇&lt;/c:set&gt;&lt;/li&gt;&lt;%--使用EL表达式从application范围中取值，用&lt;c:out&gt;标签输出使得页面规范化。 --%&gt;&lt;li&gt;使用out标签和EL表达式嵌套从application域中得到值：      &lt;c:out value=&quot;${applicationScope.name2}&quot;&gt;未得到name的值&lt;/c:out&gt;&lt;/li&gt;&lt;%--不指定范围使用EL自动查找得到值 --%&gt; &lt;li&gt;未指定scope的范围，会从不同的范围内查找得到相应的值：${data1}、${data2}、${name1}、${name2}&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;h3&gt;使用Java脚本实现以上功能&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;把一个值放入page域中。&lt;%pageContext.setAttribute(&quot;data1&quot;,&quot;xdp&quot;);%&gt;&lt;/li&gt;&lt;li&gt;从page域中得到值:&lt;%out.println(pageContext.getAttribute(&quot;data1&quot;));%&gt;&lt;/li&gt;&lt;li&gt;把一个值放入request域中。&lt;%request.setAttribute(&quot;data2&quot;,&quot;gacl&quot;);%&gt;&lt;/li&gt;&lt;li&gt;从request域中得到值:&lt;%out.println(request.getAttribute(&quot;data2&quot;));%&gt;&lt;/li&gt;&lt;li&gt;把一个值放入session域中。&lt;%session.setAttribute(&quot;name1&quot;,&quot;孤傲苍狼&quot;);%&gt;&lt;/li&gt;&lt;li&gt;从session中域得到值:&lt;%out.println(session.getAttribute(&quot;name1&quot;));%&gt;&lt;/li&gt;&lt;%--out.println()方法与&lt;%=%&gt;表达式输出功能一样 但使用表达式输出（&lt;%=%&gt;）明显要比使用out.println()输出更好。--%&gt;&lt;li&gt;&lt;%=session.getAttribute(&quot;name1&quot;) %&gt;&lt;/li&gt;&lt;li&gt;把另一个值放入application域中。&lt;%application.setAttribute(&quot;name2&quot;,&quot;白虎神皇&quot;);%&gt;&lt;/li&gt;&lt;li&gt; 从application域中得到值：&lt;%out.println(application.getAttribute(&quot;name2&quot;));%&gt;&lt;/li&gt;&lt;li&gt;&lt;%=application.getAttribute(&quot;name2&quot;)%&gt;&lt;/li&gt;&lt;li&gt;未指定scope的范围，会从不同的范围内查找得到相应的值：    &lt;%=pageContext.findAttribute(&quot;data1&quot;)%&gt;、    &lt;%=pageContext.findAttribute(&quot;data2&quot;)%&gt;、    &lt;%=pageContext.findAttribute(&quot;name1&quot;)%&gt;、    &lt;%=pageContext.findAttribute(&quot;name2&quot;)%&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h3&gt;操作JavaBean，设置JavaBean的属性值&lt;/h3&gt;%--设置JavaBean的属性值，等同与setter方法，Target指向实例化后的对象，property指向要插入值的参数名。注意：使用target时一定要指向实例化后的JavaBean对象，也就是要跟&lt;jsp:useBean&gt;配套使用，也可以java脚本实例化，但这就失去了是用标签的本质意义。使用Java脚本实例化：&lt;%@page import=&quot;javabean.Person&quot;%&lt;% Person person=new Person(); %&gt; --%&gt;&lt;c:set target=&quot;${person}&quot; property=&quot;name&quot;&gt;孤傲苍狼&lt;/c:set&gt;c:set target=&quot;${person}&quot; property=&quot;age&quot;&gt;25&lt;/c:set&gt;&lt;c:set target=&quot;${person}&quot; property=&quot;sex&quot;&gt;男&lt;/c:set&gt;&lt;c:set target=&quot;${person}&quot; property=&quot;home&quot;&gt;中国&lt;/c:set&gt;&lt;ul&gt;&lt;li&gt;使用的目标对象为：${person}&lt;/li&gt;&lt;li&gt;从Bean中获得的name值为：&lt;c:out value=&quot;${person.name}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;&lt;li&gt;从Bean中获得的age值为：&lt;c:out value=&quot;${person.age}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;&lt;li&gt;从Bean中获得的sex值为：&lt;c:out value=&quot;${person.sex}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;&lt;li&gt;从Bean中获得的home值为：&lt;c:out value=&quot;${person.home}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h3&gt;操作Map&lt;/h3&gt; &lt;%         Map map = new HashMap();    request.setAttribute(&quot;map&quot;,map); %&gt; &lt;%--将data对象的值存储到map集合中 --%&gt;&lt;c:set property=&quot;data&quot; value=&quot;gacl&quot; target=&quot;${map}&quot;/&gt;        ${map.data}&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行结果如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/2.png" alt=""></p><h3 id="表达式控制标签——remove标签的使用"><a href="#表达式控制标签——remove标签的使用" class="headerlink" title="表达式控制标签——remove标签的使用"></a>表达式控制标签——remove标签的使用</h3><h4 id="lt-c-remove-gt-标签的功能"><a href="#lt-c-remove-gt-标签的功能" class="headerlink" title="&lt;c:remove&gt;标签的功能"></a>&lt;c:remove&gt;标签的功能</h4><p><strong>&lt;c:remove&gt;标签主要用来从指定的JSP范围内移除指定的变量。</strong></p><h4 id="lt-c-remove-gt-标签的语法"><a href="#lt-c-remove-gt-标签的语法" class="headerlink" title="&lt;c:remove&gt;标签的语法"></a>&lt;c:remove&gt;标签的语法</h4><p>&lt;c:remove var=”变量名” [scope=”page|request|session|application”]/&gt;其中var属性是必须的，scope可以以省略。</p><h4 id="lt-c-remove-gt-标签的使用范例"><a href="#lt-c-remove-gt-标签的使用范例" class="headerlink" title="&lt;c:remove&gt;标签的使用范例"></a>&lt;c:remove&gt;标签的使用范例</h4><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;%--引入JSTL核心标签库 --%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;JSTL: --表达式控制标签“remove”标签的使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;    &lt;c:set var=&quot;name&quot; scope=&quot;session&quot;&gt;孤傲苍狼&lt;/c:set&gt;    &lt;c:set var=&quot;age&quot; scope=&quot;session&quot;&gt;25&lt;/c:set&gt;    &lt;li&gt;&lt;c:out value=&quot;${sessionScope.name}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;    &lt;li&gt;&lt;c:out value=&quot;${sessionScope.age}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;    &lt;%--使用remove标签移除age变量 --%&gt;    &lt;c:remove var=&quot;age&quot; /&gt;    &lt;li&gt;&lt;c:out value=&quot;${sessionScope.name}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;    &lt;li&gt;&lt;c:out value=&quot;${sessionScope.age}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行结果如下:<br><img src="src=&quot;http://od2xrf8gr.bkt.clouddn.com/3.png&quot;" alt=""></p><h3 id="表达式控制标签——catch标签的使用"><a href="#表达式控制标签——catch标签的使用" class="headerlink" title="表达式控制标签——catch标签的使用"></a>表达式控制标签——catch标签的使用</h3><h4 id="lt-c-catch-gt-标签的功能"><a href="#lt-c-catch-gt-标签的功能" class="headerlink" title="&lt;c:catch&gt;标签的功能"></a>&lt;c:catch&gt;标签的功能</h4><p><strong>&lt;c:catch&gt;标签用于捕获嵌套在标签体中的内容抛出的异常。</strong></p><h4 id="lt-c-catch-gt-标签的语法"><a href="#lt-c-catch-gt-标签的语法" class="headerlink" title="&lt;c:catch&gt;标签的语法"></a>&lt;c:catch&gt;标签的语法</h4><p>其语法格式如下：&lt;c:catch [var=”varName”]&gt;容易产生异常的代码&lt;/c:catch&gt;<br>var属性用于标识&lt;c:catch&gt;标签捕获的异常对象，它将保存在page这个Web域中。</p><h4 id="lt-c-catch-gt-标签的使用范例"><a href="#lt-c-catch-gt-标签的使用范例" class="headerlink" title="&lt;c:catch&gt;标签的使用范例"></a>&lt;c:catch&gt;标签的使用范例</h4><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%--引入JSTL核心标签库 --%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;JSTL: --表达式控制标签“catch”标签实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;catch标签实例&lt;/h4&gt;&lt;hr&gt;&lt;%--把容易产生异常的代码放在&lt;c:catch&gt;&lt;/c:catch&gt;中，自定义一个变量errorInfo用于存储异常信息 --%&gt;&lt;c:catch var=&quot;errorInfo&quot;&gt;   &lt;%--实现了一段异常代码，向一个不存在的JavaBean中插入一个值--%&gt;   &lt;c:set target=&quot;person&quot; property=&quot;hao&quot;&gt;&lt;/c:set&gt;&lt;/c:catch&gt;&lt;%--用EL表达式得到errorInfo的值，并使用&lt;c:out&gt;标签输出 --%&gt;异常：&lt;c:out value=&quot;${errorInfo}&quot; /&gt;&lt;br/&gt;异常 errorInfo.getMessage：&lt;c:out value=&quot;${errorInfo.message}&quot; /&gt;&lt;br /&gt;异常 errorInfo.getCause：&lt;c:out value=&quot;${errorInfo.cause}&quot; /&gt;&lt;br /&gt;异常 errorInfo.getStackTrace：&lt;c:out value=&quot;${errorInfo.stackTrace}&quot; /&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行代码如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/4.png" alt=""></p><h3 id="流程控制标签——if标签使用总结"><a href="#流程控制标签——if标签使用总结" class="headerlink" title="流程控制标签——if标签使用总结"></a>流程控制标签——if标签使用总结</h3><h4 id="lt-c-if-gt-标签的功能"><a href="#lt-c-if-gt-标签的功能" class="headerlink" title="&lt;c:if&gt;标签的功能"></a>&lt;c:if&gt;标签的功能</h4><p><strong>&lt;c:if&gt; 标签和程序中的if语句作用相同，用来实现条件控制。</strong></p><h4 id="lt-c-if-gt-标签的语法"><a href="#lt-c-if-gt-标签的语法" class="headerlink" title="&lt;c:if&gt;标签的语法"></a>&lt;c:if&gt;标签的语法</h4><ul><li>语法1:没有标签体内容:&lt;c:if test=”testCondition” var=”varName” [scope=”{page|request|session|application}”]/&gt;</li><li>语法2: 有标签体内容。&lt;c:if test=”testCondition” [var=”varName”] [scope=”{page|request|session|application}”]&gt;标签体内容。&lt;/c:if&gt;</li></ul><p>参数说明:</p><ul><li>test属性用于存放判断的条件，一般使用EL表达式来编写。</li><li><strong>var属性用来存放判断的结果，类型为true或false，即把值放在这个变量中</strong></li><li>scopes属性用来指定var属性存放的范围。</li></ul><h4 id="lt-c-if-gt-标签的属性"><a href="#lt-c-if-gt-标签的属性" class="headerlink" title="&lt;c:if&gt;标签的属性"></a>&lt;c:if&gt;标签的属性</h4><p><img src="https://i.imgur.com/lL3BM3b.png" alt=""></p><h4 id="lt-c-if-gt-标签的使用范例。"><a href="#lt-c-if-gt-标签的使用范例。" class="headerlink" title="&lt;c:if&gt;标签的使用范例。"></a>&lt;c:if&gt;标签的使用范例。</h4><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%--引入JSTL核心标签库 --%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;JSTL: --流程控制标签 if标签示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;if标签示例&lt;/h4&gt;&lt;hr&gt;&lt;form action=&quot;JSTL_if_tag.jsp&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;uname&quot; value=&quot;${param.uname}&quot;&gt;     &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt;&lt;%--使用if标签进行判断并把检验后的结果赋给adminchock，存储在默认的page范围中。 --%&gt;&lt;c:if test=&quot;${param.uname==&apos;admin&apos;}&quot; var=&quot;adminchock&quot;&gt;&lt;%--可以把adminchock的属性范围设置为session，这样就可以在其他的页面中得到adminchock的值，使用&lt;c:if text=”${adminchock}”&gt;&lt;c:if&gt;判断，实现不同的权限。 --%&gt;    &lt;c:out value=&quot;管理员欢迎您！&quot;/&gt;&lt;/c:if&gt;&lt;%--使用EL表达式得到adminchock的值，如果输入的用户名为admin将显示true。 --%&gt;${adminchock}&lt;/body&gt;&lt;/html&gt;  </code></pre><h3 id="流程控制标签——choose标签、when标签、otherwise标签配合使用讲解"><a href="#流程控制标签——choose标签、when标签、otherwise标签配合使用讲解" class="headerlink" title="流程控制标签——choose标签、when标签、otherwise标签配合使用讲解"></a>流程控制标签——choose标签、when标签、otherwise标签配合使用讲解</h3><h4 id="lt-c-choose-gt-、-lt-c-when-gt-和-lt-c-otherwise-gt-标签的功能"><a href="#lt-c-choose-gt-、-lt-c-when-gt-和-lt-c-otherwise-gt-标签的功能" class="headerlink" title="&lt;c:choose&gt;、&lt;c:when&gt;和&lt;c:otherwise&gt;标签的功能"></a>&lt;c:choose&gt;、&lt;c:when&gt;和&lt;c:otherwise&gt;标签的功能</h4><p>&lt;c:choose&gt;、&lt;c:when&gt;和&lt;c:otherwise&gt;这3个标签通常情况下是一起使用的，&lt;c:choose&gt;标签作为&lt;c:when&gt;和&lt;c:otherwise&gt;标签的父标签来使用。<br><strong>使用&lt;c:choose&gt;，&lt;c:when&gt;和&lt;c:otherwise&gt;三个标签，可以构造类似 “if-else if-else” 的复杂条件判断结构</strong></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>&lt;c:choose&gt; &lt;c:when test=&quot;条件1&quot;&gt;         //业务逻辑1 &lt;/c:when&gt; &lt;c:when test=&quot;条件2&quot;&gt;         //业务逻辑2 &lt;/c:when&gt; &lt;c:when test=&quot;条件n&quot;&gt;         //业务逻辑n &lt;/c:when&gt; &lt;c:otherwise&gt;         //业务逻辑 &lt;/c:otherwise&gt;&lt;/c:choose&gt;</code></pre><h4 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h4><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%--引入JSTL核心标签库 --%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;JSTL: -- choose及其嵌套标签标签示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;choose及其嵌套标签示例&lt;/h4&gt;&lt;hr/&gt;&lt;%--通过set标签设定score的值为85 --%&gt;&lt;c:set var=&quot;score&quot; value=&quot;85&quot;/&gt;&lt;c:choose&gt;&lt;%--使用&lt;c:when&gt;进行条件判断。如果大于等于90，输出“您的成绩为优秀”；如果大于等于70小于90，输出“您的成绩为良好”；大于等于60小于70，输出“您的成绩为及格”；其他（otherwise）输出“对不起，您没能通过考试”。 --%&gt;    &lt;c:when test=&quot;${score&gt;=90}&quot;&gt;    你的成绩为优秀！    &lt;/c:when&gt;    &lt;c:when test=&quot;${score&gt;70 &amp;&amp; score&lt;90}&quot;&gt;    您的成绩为良好!    &lt;/c:when&gt;    &lt;c:when test=&quot;${score&gt;60 &amp;&amp; score&lt;70}&quot;&gt;    您的成绩为及格    &lt;/c:when&gt;    &lt;c:otherwise&gt;    对不起，您没有通过考试！    &lt;/c:otherwise&gt;&lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="循环标签——forEach标签的使用"><a href="#循环标签——forEach标签的使用" class="headerlink" title="循环标签——forEach标签的使用"></a>循环标签——forEach标签的使用</h3><h4 id="lt-c-forEach-gt-标签的功能"><a href="#lt-c-forEach-gt-标签的功能" class="headerlink" title="&lt;c:forEach&gt;标签的功能"></a>&lt;c:forEach&gt;标签的功能</h4><p><strong>该标签根据循环条件遍历集合（Collection）中的元素。</strong></p><h4 id="lt-c-forEach-gt-标签的语法"><a href="#lt-c-forEach-gt-标签的语法" class="headerlink" title="&lt;c:forEach&gt;标签的语法"></a>&lt;c:forEach&gt;标签的语法</h4><pre><code>&lt;c:forEach var=”name” items=”Collection” varStatus=”StatusName” begin=”begin” end=”end” step=”step”&gt;本体内容&lt;/c:forEach&gt;</code></pre><p>参数说明:</p><ul><li><strong>var设定变量名用于存储从集合中取出元素。</strong></li><li>items指定要遍历的集合</li><li>varStatus设定变量名，该变量用于存放集合中元素的信息。</li><li>begin、end用于指定遍历的起始位置和终止位置（可选）。</li><li>step指定循环的步长</li></ul><p>Dome:</p><pre><code>&lt;c:forEach items=&quot;${itemsList}&quot; var=&quot;item&quot; varStatus=&quot;s&quot;&gt;        &lt;tr&gt;            &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;itemsList[${s.index}].id&quot; value=&quot;${item.id}&quot;&gt;&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;itemsList[${s.index}].name&quot; value=&quot;${item.name}&quot;&gt; &lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;itemsList[${s.index}].price&quot; value=&quot;${item.price}&quot;&gt; &lt;/td&gt;            &lt;td&gt;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;/td&gt;            &lt;td&gt;${item.detail }&lt;/td&gt;            &lt;td&gt;&lt;a href=&quot;${pageContext.request.contextPath }/items/editItems.action?id=${item.id}&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;/c:forEach&gt;</code></pre><h4 id="lt-c-forEach-gt-标签的属性"><a href="#lt-c-forEach-gt-标签的属性" class="headerlink" title="&lt;c:forEach&gt;标签的属性"></a>&lt;c:forEach&gt;标签的属性</h4><p><img src="https://i.imgur.com/PjqWhHR.png" alt=""><br>其中varStatus有4个状态属性，如下表所示:<br><img src="https://i.imgur.com/l8uSSnP.png" alt=""></p><h4 id="lt-c-forEach-gt-的使用范例"><a href="#lt-c-forEach-gt-的使用范例" class="headerlink" title="&lt;c:forEach&gt;的使用范例"></a>&lt;c:forEach&gt;的使用范例</h4><pre><code>OCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;JSTL: -- forEach标签实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;&lt;c:out value=&quot;forEach实例&quot;/&gt;&lt;/h4&gt;&lt;%    List&lt;String&gt;list = new ArrayList&lt;String&gt;();    list.add(0, &quot;贝贝&quot;);    list.add(1, &quot;晶晶&quot;);    list.add(2, &quot;欢欢&quot;);    list.add(3, &quot;莹莹&quot;);    list.add(4, &quot;妮妮&quot;);    request.setAttribute(&quot;list&quot;, list); %&gt;&lt;B&gt;&lt;c:out value=&quot;不指定begin和end的迭代：&quot; /&gt;&lt;/B&gt;&lt;br&gt;&lt;%--不使用begin和end的迭代，从集合的第一个元素开始，遍历到最后一个元素。 --%&gt;&lt;c:forEach var=&quot;fuwa&quot; items=&quot;${list}&quot;&gt;    &amp;nbsp;&lt;c:out value=&quot;${fuwa}&quot;/&gt;&lt;br/&gt;&lt;/c:forEach&gt;&lt;B&gt;&lt;c:out value=&quot;指定begin和end的迭代：&quot; /&gt;&lt;/B&gt;&lt;br&gt;&lt;%--指定begin的值为1、end的值为3、step的值为2，从第二个开始首先得到晶晶，每两个遍历一次，则下一个显示的结果为莹莹，end为3则遍历结束。 --%&gt;&lt;c:forEach var=&quot;fuwa&quot; items=&quot;${list}&quot; begin=&quot;1&quot; end=&quot;3&quot; step=&quot;2&quot;&gt;   &lt;c:out value=&quot;${fuwa}&quot;/&gt;&lt;br/&gt;   &lt;/c:forEach&gt;&lt;B&gt;&lt;c:out value=&quot;输出整个迭代的信息：&quot; /&gt;&lt;/B&gt;&lt;br&gt;    &lt;%--指定varStatus的属性名为s，并取出存储的状态信息 --%&gt;    &lt;c:forEach var=&quot;fuwa&quot; items=&quot;${list}&quot; begin=&quot;3&quot; end=&quot;4&quot; varStatus=&quot;s&quot; step=&quot;1&quot;&gt;         &lt;c:out value=&quot;${fuwa}&quot; /&gt;的四种属性：&lt;br&gt;       所在位置，即索引：&lt;c:out value=&quot;${s.index}&quot; /&gt;&lt;br&gt;         总共已迭代的次数：&lt;c:out value=&quot;${s.count}&quot; /&gt;&lt;br&gt;         是否为第一个位置：&lt;c:out value=&quot;${s.first}&quot; /&gt;&lt;br&gt;         是否为最后一个位置：&lt;c:out value=&quot;${s.last}&quot; /&gt;&lt;br&gt;      &lt;/c:forEach&gt;&lt;/body&gt;/html&gt;</code></pre><p>运行结果为:<br><img src="http://od2xrf8gr.bkt.clouddn.com/7.png" alt=""></p><h3 id="URL操作标签——import标签的使用"><a href="#URL操作标签——import标签的使用" class="headerlink" title="URL操作标签——import标签的使用"></a>URL操作标签——import标签的使用</h3><h4 id="lt-c-import-gt-标签的功能"><a href="#lt-c-import-gt-标签的功能" class="headerlink" title="&lt;c:import&gt;标签的功能"></a>&lt;c:import&gt;标签的功能</h4><p><strong>该标签可以把其他静态或动态文件包含到本JSP页面，与<a href="jsp:include" target="_blank" rel="noopener">jsp:include</a>的区别为：<a href="jsp:include" target="_blank" rel="noopener">jsp:include</a>只能包含同一个web应用中的文件。而&lt;c:import&gt;可以包含其他web应用中的文件，甚至是网络上的资源。</strong></p><h4 id="lt-c-import-gt-标签的语法"><a href="#lt-c-import-gt-标签的语法" class="headerlink" title="&lt;c:import&gt;标签的语法"></a>&lt;c:import&gt;标签的语法</h4><ul><li>语法1:&lt;c:import url=”url” [context=”context”][value=”value”] [scope=”page|request|session|application”] [charEncoding=”encoding”]/&gt;</li><li>语法2:&lt;c:import url=”url” varReader=”name” [context=”context”] [charEncoding=”encoding”]/&gt;</li></ul><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明:"></a>参数说明:</h4><ul><li><strong>URL为资源的路径，当引用的资源不存在时系统会抛出异常，因此该语句应该放在&lt;c:catch&gt;&lt;/c:catch&gt;语句块中捕获。</strong></li><li>引用资源有两种方式：绝对路径和相对路径。</li></ul><blockquote><p>使用绝对路径的示例如下：&lt;c:import url=”<a href="http://www.baidu.com”&gt;" target="_blank" rel="noopener">http://www.baidu.com”&gt;</a></p><p>使用相对路径的示例如下：&lt;c:import url=”aa.txt”&gt;，<strong><em>aa.txt放在同一文件目录。</em></strong></p></blockquote><ul><li>如果以“/”开头表示应用的根目录下。例如：tomcat应用程序的根目录文件夹为webapps。导入webapps下的文件bb.txt的编写方式为：&lt;c:import url=”/bb.txt”&gt;</li><li>context属性用于在访问其他web应用的文件时，指定根目录。例如，访问root下的index.jsp的实现代码为：&lt;c:import url=”/index.jsp” context=”/root”&gt;。等同于webapps/root/index.jsp</li><li>var、scope、charEncoding、varReader是可选属性。</li></ul><h4 id="lt-c-import-gt-标签使用范例"><a href="#lt-c-import-gt-标签使用范例" class="headerlink" title="&lt;c:import&gt;标签使用范例"></a>&lt;c:import&gt;标签使用范例</h4><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%--引入JSTL核心标签库 --%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;       &lt;title&gt;JSTL: -- import标签实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;&lt;c:out value=&quot;import实例&quot;/&gt;&lt;/h4&gt;&lt;hr/&gt;&lt;h4&gt;&lt;c:out value=&quot;绝对路径引用的实例&quot; /&gt;&lt;/h4&gt;&lt;%--使用绝对路径导入百度首页,导入时使用&lt;c:catch&gt;&lt;/c:catch&gt;捕获异常。--%&gt;    &lt;c:catch var=&quot;error1&quot;&gt;        &lt;c:import url=&quot;http://wwww.baidu.com&quot; charEncoding=&quot;utf-8&quot;/&gt;    &lt;/c:catch&gt;        ${error1}    &lt;hr/&gt; &lt;h4&gt;&lt;c:out value=&quot;相对路径引用本应用中的文件&quot; /&gt;&lt;/h4&gt; &lt;%--使用相对路径导入同一文件夹下的“JSTL的import标签使用说明”文件，接收的字符编码格式使用charEncoding设置为utf-8。 --%&gt;     &lt;c:catch var=&quot;error2&quot;&gt;         &lt;c:import url=&quot;JSTL的import标签使用说明&quot; charEncoding=&quot;utf-8&quot;/&gt;     &lt;/c:catch&gt;          ${error2}     &lt;hr/&gt;  &lt;h4&gt;&lt;c:out value=&quot;使用字符串输出相对路径引用的实例，并保存在session范围内&quot; /&gt;&lt;/h4&gt;  &lt;%--导入“JSTL的import标签使用说明.txt”，使用var定义的变量接收要导入的文件，并存储在session中，  如果在其他页面同样也要导入该文件，只须使用&lt;c:out&gt;输出“JSTL的import标签使用说明.txt”的值即可。--%&gt;      &lt;c:catch var=&quot;error3&quot;&gt;       &lt;c:import var=&quot;myurl&quot; url=&quot;JSTL的import标签使用说明&quot; scope=&quot;session&quot; charEncoding=&quot;utf-8&quot;/&gt;           &lt;c:out value=&quot;${myurl}&quot;&gt;&lt;/c:out&gt;       &lt;hr/&gt;        &lt;c:out value=&quot;${myurl}&quot; /&gt;      &lt;/c:catch&gt;           ${error3}   &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="URL操作符——url标签的使用"><a href="#URL操作符——url标签的使用" class="headerlink" title="URL操作符——url标签的使用"></a>URL操作符——url标签的使用</h3><h4 id="lt-c-url-gt-标签的功能"><a href="#lt-c-url-gt-标签的功能" class="headerlink" title="&lt;c:url&gt;标签的功能"></a>&lt;c:url&gt;标签的功能</h4><p>标签用于在JSP页面中构造一个URL地址，其主要目的是实现URL重写。</p><h4 id="lt-c-url-gt-标签的语法"><a href="#lt-c-url-gt-标签的语法" class="headerlink" title="&lt;c:url&gt;标签的语法"></a>&lt;c:url&gt;标签的语法</h4><ul><li>语法1:指定一个url不做修改，可以选择把该url存储在JSP不同的范围中。&lt;c:url value=”value” [var=”name”][scope=”page|request|session|application”] [context=”context”]/&gt;</li><li>语法2:配合 &lt;c:param&gt;标签给url加上指定参数及参数值，可以选择以name存储该url。</li></ul><blockquote><p>&lt;c:url value=”value” [var=”name”] [scope=”page|request|session|application”] [context=”context”]<br>    &lt;c:param name=”参数名” value=”值”&gt;<br>&lt;/c:url&gt;`</p></blockquote><h4 id="lt-c-url-gt-标签的主要属性"><a href="#lt-c-url-gt-标签的主要属性" class="headerlink" title="&lt;c:url&gt;标签的主要属性"></a>&lt;c:url&gt;标签的主要属性</h4><p><img src="https://i.imgur.com/rDMpJVJ.png" alt=""></p><h4 id="lt-c-url-gt-标签使用范例"><a href="#lt-c-url-gt-标签使用范例" class="headerlink" title="&lt;c:url&gt;标签使用范例"></a>&lt;c:url&gt;标签使用范例</h4><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;%--引入JSTL核心标签库 --%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;JSTL: -- url标签实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;c:out value=&quot;url标签使用&quot;&gt;&lt;/c:out&gt;&lt;h4&gt;使用url标签生成一个动态的url，并把值存入session中.&lt;/h4&gt;&lt;hr/&gt;&lt;c:url value=&quot;http://www.baidu.com&quot; var=&quot;url&quot; scope=&quot;session&quot;&gt;&lt;/c:url&gt;&lt;a href=&quot;${url}&quot;&gt;百度首页(不带参数)&lt;/a&gt;&lt;hr/&gt;&lt;h4&gt;配合 &amp;lt;c:param&amp;gt;标签给url加上指定参数及参数值，生成一个动态的url然后存储到paramUrl变量中&lt;/h4&gt;&lt;c:url value=&quot;http://www.baidu.com&quot; var=&quot;paramUrl&quot;&gt;    &lt;c:param name=&quot;userName&quot; value=&quot;codingxiaxw&quot;/&gt;    &lt;c:param name=&quot;pwd&quot;&gt;123456&lt;/c:param&gt;&lt;/c:url&gt;&lt;a href=&quot;${paramUrl}&quot;&gt;百度首页(带参数)&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>If you have some questions after you see my blog , you can tell your doubts in the comments area or you can find some infos by clicking these links or ask me by sending me an email：</p></blockquote><ul><li><p><a href="https://github.com/Lembre" target="_blank" rel="noopener">Github@codinglembre</a></p></li><li><p><a href="https://www.zhihu.com/people/yan-zhong-hui-11/activities" target="_blank" rel="noopener">Zhihu@codinglembre</a></p></li><li><p><a href="https://codinglembre.top">Blog@codinglembre</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JSTL标签库介绍&quot;&gt;&lt;a href=&quot;#JSTL标签库介绍&quot; class=&quot;headerlink&quot; title=&quot;JSTL标签库介绍&quot;&gt;&lt;/a&gt;JSTL标签库介绍&lt;/h3&gt;&lt;p&gt;JSTL标签库的使用是为弥补html标签的不足，规范自定义标签的使用而诞生的。&lt;st
      
    
    </summary>
    
      <category term="前端" scheme="http://codinglembre.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaWeb" scheme="http://codinglembre.top/tags/JavaWeb/"/>
    
      <category term="Servlet" scheme="http://codinglembre.top/tags/Servlet/"/>
    
      <category term="JSP" scheme="http://codinglembre.top/tags/JSP/"/>
    
  </entry>
  
</feed>
